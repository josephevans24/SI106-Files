
_ Combinatory _ 

Logic 
in Programming 



Library " JurlnfoR" 



-Founded in 1994 



Series: Computer Science and Information 
Technologies 



Project: Applicative Computational Systems 

Project Leader, Dr. 

L. Yu. Ismailova 



Published on the occasion of 60th anniversary of Moscow Engineering 
Physics Institute 



Institute for Contemporary Education 
"JurlnfoR-MSU" 



Department of Advanced Computer Studies 
and Information Technologies 



V. E. Wolfengagen 



COMBINATORY 

LOGIC 

in PROGRAMMING 



Computations with objects through examples and exercises 



2nd edition 



Moscow 
Jurlnf( 
2003 



AlpiHi • "Center JurlnfoR" Ltd. • fP"* 



T Rr "^9 97 Library of "JurlnfoR" 



_Founcledm 1994 



UUC 004 Series: Computer Science and Information 

oiZl Technologies 



V. E. Wolfengagen 

Combinatory logic in programming. Computations with ob- 
jects through examples and exercises. — 2-nd ed. — Moscow.: 
Center "JurlnfoR", 2003. — X+337 p. 

ISBN 5-89158-101-9 

The book is intended for computer science students, programmers 
and professionals who have already got acquainted with the basic 
courses and background on discrete mathematics. It may be used 
as a textbook for graduate course on theoretical computer science. 

The book introduces a reader to the conceptual framework for think- 
ing about computations with the objects. The several areas of the- 
oretical computer science are covered, including the following: type 
free and typed A-calculus and combinatory logic with applications, 
evaluation of expressions, computations in a category. The topics, 
covered in the book accumulated much experience in teaching these 
subjects in graduate computer science courses. 

A rich set of examples and exercises, including solutions, has been 
prepared to stimulate the self studying and to make easier the job of 
instructor. 

ISBN 5-89158-101-9 © J^' ^/fff-' l.^^^^ 

© Center JurlnfoR , 1997-2003 

Center "JurlnfoR" 

Institute for Contemporary Education "JurlnfoR-MSU" 

Fax: +7(095)956-25-12. E-mail: vew@jmsuice.iiisk.ru 



Contents 



Preface of the editors of the series 1 

Special Preface 3 

The spectrum of problems 5 

Preface to the first edition 7 

Preface to the second edition 12 

Introduction 18 

1 PreMminaries 27 

1.1 The spectrum of ideas 29 

1 .2 Layout of a chapter 30 

1.3 State-of-the-art in an area 32 

1 .4 Typical task 35 

1 .5 Variants of task 37 

1.6 A recommended order of solving the tasks 44 

2 Derivation of Object 45 

2.1 Principle of combinatory completeness 46 

2.1.1 Combinatory characteristic 46 

2.1.2 Systems of concepts 47 

V 



VI Contents 

2.1.3 Combinatory completeness 47 

2.1.4 Elementary combinatory logic 49 

2.2 Deriving main combinators: tasks 51 

2.3 Historical remark 62 

3 Fixed Point 65 

3.1 Theoretical background 65 

3.1.1 Abstraction 66 

3.1.2 Multiabstraction 66 

3.1.3 Local recursion 67 

3.2 Main tasks 68 

Exercises 73 

4 Extensionality 75 

4.1 Theoretical background 75 

4.2 Tasks 77 

Exercises 79 

5 Numerals 81 

5.1 Numbers and numerals 81 

5.2 Combinatory arithmetic 82 

5.3 Tasks 87 

Exercises 91 

6 Typed combinators 93 

6.1 Notion of a type 93 

6.1.1 Combinatory terms 96 

6.1.2 A-terms 97 

6.2 Tasks 97 

7 Basis I, K,S 113 

7.1 Theoretical background 113 

7.2 Tasks 114 

Exercises 115 



Contents VII 

8 Basis I, B,C,S 117 

8.1 Theoretical background 117 

8.2 A property of being basic 118 

8.3 Elementary examples 120 

Exercises 121 

9 Applications of fixed point combinator y 123 

9.1 Fixed point theorem 123 

9.2 Elements of recursive computations 124 

9.3 Using the combinator y 125 

9.4 Evaluation of a function 127 

Exercises 131 

10 Function /istl 133 

10.1 Theoretical background 133 

10.2 Tasks 134 

10.3 Functor-as-object 137 

Exercises 138 

11 Isomorphism of c.c.c. and ACS 139 

11.1 Theoretical background 139 

11.2 Tasks 141 

12 Currying 143 

12.1 Theoretical background 143 

12.1.1 Operators and functions 143 

12.1.2 Comprehension 144 

12.1.3 Connection between operators and functions . 144 

12.2 Tasks 145 

Exercises 147 

13 Karoubi's shell 149 

13.1 Theoretical background 149 

13.2 Tasks 150 



VIII Contents 

Exercises 154 

14 Products and projections 157 

14.1 Theoretical background 157 

14.2 Task 157 

14.3 Product and cartesian closed category 161 

15 Embedding Lisp into ACS 163 

15.1 Theoretical background 163 

15.2 A main task 164 

15.3 Concluding remarks 170 

16 Supercombinators 171 

16.1 Theoretical background 171 

16.1.1 Notion of supercombinator 172 

16.1.2 Process of compiling 174 

16.1.3 Transformation to supercombinators 175 

16.1.4 Eliminating redundant parameters 177 

16.1.5 Orderingof the parameters 178 

16.1.6 The lambda-lifting with a recursion 182 

16.1.7 Execution of the lambda-lifting algorithm . . 185 

16.1.8 Other ways of lambda-lifting 188 

16.1.9 FuUlazyness 190 

1 6. l.lOMaximal free expressions 192 

16.1.11 Lambda-lifting with MFE 194 

1 6. 1.1 2 Fully lazy lambda-lifting with /etrec 196 

1 6. 1.13Compound example 197 

16.2 Task 200 

16.3 Answers to exercises 202 

17 Lazy implementation 211 

17.1 Tasks 211 

Exercises 214 



Contents IX 

18 Permutation of parameters 215 

18.1 Task 215 

Exercises 219 

Test 219 

19 Immediate computations 221 

19.1 Task 221 

Exercises 223 

Test 224 

20 de Bruijn's encoding 225 

20.1 Tasks 225 

Exercises 230 

21 Abstract machine: CAM 233 

21.1 Theoretical background 233 

21.1.1 CAM structure 233 

21.1.2 Instructions 235 

21.2 Tasks 239 

Exercises 240 

22 Optimizing CAM-computations 243 

22.1 Task 243 

Exercises 252 

Test 253 

23 Variable objects 255 

23.1 Models 255 

23.1.1 Applicative structure 256 

23.1.2 Typed models 259 

23.1.3 Partial objects 267 

23.1.4 Data object models 270 

23.2 The main task 274 

23.2.1 Elementary types 275 



X Contents 

23.2.2 Typed variable objects 276 

23.2.3 Computational models 278 

23.2.4 Indexed objects 280 

23.3 Interpretation of evaluating environment 288 

Bibliography 289 

Index 309 

Glossary 313 

Practical work 329 

Dissertations 333 

About the Author 336 



Preface of the editors of the series 1 

Preface of the editors of the series 

Computer science and information technologies have become om- 
nipresent and continue to promise changes that more and more in- 
volve, practically speaking, all the spheres of our life. First of all, the 
new technologies make it easier to get access to diverse information 
and produce masses of information in electronic form, changing by 
this both the character ofwork and its results. Indeed, many products, 
being of great demand, are produced in the form of a sequence of bits, 
with an exceptionally high tempo of their changes. 

Changes involve both separate professions, and the whole bran- 
ches of industry and knowledge. In real state of things, the develop- 
ment of information technologies has led to the appearance of virtual 
reality. Contemporary society is just beginning to get adapted to vir- 
tual reality, the capabilities of which are being appropriated quickly 
enough. 

While at its early stages of development programming was a kind 
of art with a programmer creating a program in order to solve a def- 
inite task and providing it with more or less detailed documentation. 
By now, a powerful industry of programming has been created, com- 
plete with accompanying software engineering. At present, in the 
research in the field of programming or in the sphere of computer sci- 
ences, as a rule, support is given to works in which a slight improve- 
ment is introduced in the solution of the already well-known problem. 
At the same time no attention is paid to really important and basic re- 
search, being the way to search for new computation concepts, while 
insufficient attention is given to accumulation of knowledge in the 
field of programming. 

This series of volumes is meant as a continuing row of publi- 
cations in the field of computer science, information technologies 
and programming, promoting the accumulation of knowledge in the 
above-mentioned fields. It is assumed that these publications may 
be used for presentation of separate courses and can also promote 



Z Preface OF THE EDITORS OF THE SERIES 

scientific research. As a rule, the volumes of the series are meant to 
satisfy the needs of readers of various levels, starting with students 
that have the aim of getting initial familiarization with the subject 
itself, up to specialists in different branches of computer sciences. 

Thus, the publications of the planned series are meant to reflect 
the current status of the given field and also to provide the basis for 
systematic study of different sections of computer sciences, informa- 
tion technologies and programming. 

The Editors of The Series 



Special Preface d 

Special Preface 

One of the virtues of combinatory logic is that it provides a smart 
universe of discourse to computer scientists, programmers, applied 
theoreticians, practitioners. In practice, however, a sophisticated ap- 
plied theoretician and an applied programmer must have a thorough 
grasp of what the system of objects does in response to an evaluation 
request. To make the most transparent use of the evaluation sys- 
tem, one must have insight of such things as what kind of thing is 
an object or data structure, how to optimize the execution plan of a 
program for given set of objects, to understand the impact of avoiding 
the bound variables on a program code, the importance of sub- and 
super-partitioning of an object set, etc. When used or studied, all 
these trends are interrelated and involve some self contained local 
universes of mathematical ideas. 

This book covers the commonly used computational ideas related 
to combinatory logic. 

Nevertheless, the lifting from undergraduate to graduate teach- 
ing of applicative computations topics initiates unusual didactic chal- 
lenges which can be explained by the visible distance between the 
rigorous mathematical apparatus and applied research papers. 

This volume addresses this problem by providing a graduate text- 
book which covers the principle topics for classroom teaching. In 
this book the gradual progression of topics is supported by examples 
and exercises. By solving them, the students are introduced to the 
research issues at the forefront of computer science. The book is 
written by the author who is a specialist in the covered areas, and 
who has accumulated a rich experience in teaching graduate courses 
in those areas. 

To use this book a minimal knowledge of theoretical computer 
science is needed to reach the following aims: 

• to provide an introduction to the principle areas of current research 
in computer science in order to give students the needed knowl- 



4 Special Preface 

edge and intuition for more advanced study and research; 

• to provide both the practitioners and researchers with a conceptual 
background of computational ideas that are expected to be used in 
applied computer science in the coming years. 

To achieve the second aim the author has used the general notations 
of mappings between the classes of objects, in order to bring in more 
independency from a particular formal system. Most of attention is 
paid to the main computational ideas and their implementation within 
a formal framework. 

Nobody argues that A-calculus is a theory of functions. This the- 
ory gives a philosophy and reasons to view the idealized entities as 
functions. It is more important that A-calculus is related to other 
theories and the kind of these relations gives important insight into 
how to build different models of computation. 

The spectrum of other theories usually starts with set theory. The 
question is how set theory provides a theory of functions. E.g., Zer- 
melo's theory has a limited view of sets observing separate set A as 
extremely small with respect to the size of V , the universe of all sets. 
Any particular map f : A ^ B from one set A into other set B gives 
no information concerning maps from V to V, thus the classes of 
operations on all sets are hardly ever known within set theory. Usual 
assumption takes set A as an element of V, A £ V m spite of class 
B which is subcollection of V, B C V. The connections between 
A-calculus and class theory have been established and studied. This 
does not mean that A-calculus depends on the set theory. 

If we want a theory of functions be not derived from the set theory 
we need a pure theory of functions within which functions are ob- 
served as particular entities. A category theory gives a universe of 
discourse for selected functions, or better: functional entities. The 
middle way between pure category theory and a set theory is given by 
cartesian closed categories. 



The SPECTRUM OF PROBLEMS 5 

The spectrum of problems 

"It has long been my personal view that the separation of practical 
and theoretical work is artificial and injurious. Much of the practical 
work done in computing, both in software and in hardware design, is 
unsound and clumsy because the people who do it have not any clear 
understanding of the fundamental design principles of their work. 
Most of the abstract mathematical and theoretical work is sterile be- 
cause it has no point of contact with real computing. One of the central 
aims of the Programming Research Group [in Oxford University] as a 
teaching and research group has been to set up an atmosphere in which 
this separation cannot happen." 

Christopher Strachey 

http://vmoc .museophile . com/pioneers/str achey.html 

From the moment of their emergence, combinatory logic and lambda- 
calculus are referred to as "non-classical" by logicians. The point is 
that combinatory logic appeared in the 20-ies, while lambda-calcu- 
lus, in the 40-ies, as a branch of mathematics with sufficiently clear- 
cut purpose of rendering foundation to mathematics. It means that, 
having constructed the required "applied" mathematical theory, i.e. 
object theory, reflecting processes and phenomena in real environ- 
ment, it is possible to make use of a "pure" metatheory as a shell for 
finding out the capabilities and properties of the object theory. 

Combinatory logic and lambda-calculus are such formal systems 
in which the central elaborated essence is the concept of an object. 
Within the framework of the first of them, i.e. the combinatory logic, 
the mechanism of binding variables is absent in its explicit form, while 
being present in the second one. The presence of this explicit mecha- 
nism of binding assumes both the presence of bound variables (how- 
ever, in this case, free variables are also assumed), as well as mech- 
anisms of replacement of formal parameters, i.e. bound variables, by 
actual parameters, that is substitution. 

The initial purpose of combinatory logic was namely the analysis 
of this substitution process. In the capacity of its essences, it was 



b The SPECTRUM OF PROBLEMS 

planned to use objects as combinations of constants. Lambda- 
calculus was assigned the role of means for specifying the notions of 
an algorithm and computability. As a consequence, combinatory 
logic provides a tool for analysis of the process of substitution. After 
a short period of time, it turned out that both the systems could be 
treated as programming languages. 

Both the systems, in which objects are computed, are calculi or 
languages of higher order, i.e., there are means for describing map- 
pings or operators, which are defined on a set of mappings or oper- 
ators, while also generating mappings and operators as a result of 
it. The most important thing is that it is precisely mapping that is 
considered to be an object. This constitutes its basic difference from 
the whole variety of other systems, for which the notion of set and its 
elements is usually taken as their primary basics. 

Currently, both these languages have become the basis for the 
whole domain of research in the field of computer science and are 
also widely used in the theory of programming. The development 
of computational power of computers has led to the automation of 
a considerable part of theoretical — both logical and mathematical, — 
knowledge, while combinatory logic together with lambda-calculus 
are recognized as a basis for considerations in terms of objects. 

Without the mastering of their methods, it is impossible to fully 
develop the basic technique of computations with objects, since the 
set-theoretic style, still widely used in the object-oriented languages 
of programming and development, makes it difficult to avoid getting 
buried in masses of secondary details and, as a result, losing sight of 
the really important issues of the interaction of objects. 



Preface to the first edition of the volume / 

Preface to the first edition of the volume 

Whom is the volume addressed to? 

This volume has been written to assist those readers who study com- 
puter science or are engaged in this sphere of activity, who want to 
systemize their knowledge and have another look at the spectrum of 
ideas they have to deal with in their everyday work. The volume is 
meant to help in reading and studying the original research publica- 
tions in the field of system and theoretical programming, as well as, 
if need be, to effect accurate mathematical analysis of newly created 
programming mechanisms and data models. The detailed explana- 
tions and a great number of analyzed examples and problems will 
assist the reader in getting the message without any considerable 
effort of making a good choice of the required literature and starting 
own research work in this interesting and promising field. That is 
promoted by a considerable amount of independence in the study of 
separate sections, which is reasonable in view of the specific character 
of the mathematical discipline itself, i.e. combinatory logic. A more 
experienced reader in the field of mathematics may be interested in the 
applied aspects of the theory. 

Why should objects be calculated? 

Work with computers provided with a shell, which can take over upon 
itself the control of software objects, lays the basis for the utmost 
state-of-the-art technique of programming. Presently, hundreds of 
applied programs, such as Windows, AutoCAD, Designer and many 
others deal with objects. On the other hand, the instrumental systems 
of programming, such as Small Talk, C++, Actor and some others 
require a programmer to exercise systematic speculations in terms 
of objects and relationship between them, which, in their turn, can 
be treated as objects. Programming in terms of objects requires the 
development and maintenance of their own mathematical culture that 



o Preface to the first edition of the volume 

provides the whole spectrum of stimulating ideas. In the process of 
solving a specific task, a programmer becomes a researcher, who is 
required to create his own language with its own capabilities. Such 
capabilities are not always intuitively self-evident and may require 
purely mathematical evaluation of their expressive abilities. Apart 
from that, very often it is not only necessary to create a certain pro- 
gram code but also to fulfill its optimization without losing the prop- 
erties of its equivalence to the initial code. For doing careful and 
professional work, it is required to have its own "mathematical shell", 
supporting all significant and interesting mathematical applications. 

The principal thing is the adequate way of thinking 

It is a well-known fact that in the practice of programming, different 
approaches, developing in different directions, have taken shape. The 
most evident differences manifest themselves in the difference in com- 
prehension and writing of programs. The major part of programmers 
is engaged in procedure-oriented programming. Apart from that, 
there exist rule-oriented programming, logical programming, par- 
allel 'pvogvammxng, oisMa/ programming, and programming in terms 
of dataflows. If need be, this list can be continued, but, evidently, it will 
be incomplete without also including object-oriented programming, 
displaying a vividly expressed tendency for growth. 

Approaches and styles of programming. Approaches and styles 
of programming are numerous, which reflects the tendency of up- 
grading and propagating of still newer computer architectures. The 
emerging new architectures are oriented at new approaches to pro- 
gramming that are still taking shape in research laboratories. 

The abundance and great variety of approaches to programming 
in computer science are reflected in the development and propaga- 
tion of different approaches to mathematics. And indeed, surpris- 
ingly many mathematical theories have been built, each of them being 



Preface to the first edition of the volume y 

an absolutely unique language of communication for a comparatively 
narrow circle of specialists who understand each other perfectly well. 
At the same time, any attempt of an "uninitiated" person to under- 
stand practical usefulness and significance of the new mathematical 
language meets with obstacles. It turns out that, first of all, it is 
necessary to change one's own way of thinking so as to be able to 
have a different look at certain difficulties. Thus, the spread of object- 
oriented programming also requires the use of different ways of rea- 
soning, which more often than not radically differ from the stereotypes 
of reasoning adopted in procedure-oriented programming. 



Speculations in terms of objects. Similarly, only just few and 
comparatively young mathematical theories are oriented at specula- 
tion in terms of objects rather than in terms of operators, as goes 
from the experience in studying mathematical analysis at the majority 
of universities, including those technically or computer oriented. Un- 
fortunately, a programmer has no opportunity to attend a university 
course that might lay down the basis of mathematical thinking in 
terms of objects. At best, only some information about purely mathe- 
matical results is given, which are obtained in the framework of com- 
binatory logic, lambda-calculus or category theory and which are 
far from being easy to apply to practical programming, if you are not 
versed in theory. 

It is possible to assert that combinatory logic has had a consider- 
able influence on the contemporary status of programming. Coming 
into life as a science about the nature of substitutions in mathe- 
matical theories, it has then given birth to functional programming, 
programming in terms of supercombinators, as well as some other 
highly productive approaches to programming. In particular, only 
after one really understands the very spirit of combinatory logic, it 
is possible to fully comprehend and put into practice the system of 
programming, having no predetermined set of instructions. 



10 Preface to the first edition of the volume 



Computation theory. The programming paradigms of the 90-ies 
emerged, to a great extent, from the mathematical way of consider- 
ations, adopted in the computation theory. In particular, one of its 
initial premises was the concept of 'information flow' along a certain 
'possible' channel, which gave rise to the appearance of a very fruitful 
concept of a program, controlled by a data flow. Another example has 
to do with the idea of using a certain part of combinatory logic by 
building special instructions-objects within it. Those objects form a 
system of commands of a categorical abstract machine, which can 
successfully serve as a foundation of quite practical (albeit, object- 
oriented) systems of programming. More than that, the rules of com- 
binatory logic make it possible to optimize the compiled program 
code by reducing it to a certain normal form. For a specialist in 
combinatory logic, it was something taken for granted from the very 
beginning, since that was one of the aims for developing combinatory 
logic as a mathematical discipline. 

The contemporary research in the field of computer science has 
shown that combinatory logic and its various categorial dialects be- 
come an indispensable mathematical language of the programmer, 
used for exchanging ideas between colleagues. The point is that one 
of the subject matters of its research is the study of objects and devel- 
opment of different calculuses of objects, satisfying a set of aspects of 
each applied task. In other words, the solution of any particular task 
requires the creation of a specific exact language. As is well known 
by programmers, that is the language of the software interface. In 
terms of a computer science specialist, it is a specialized dialect of 
combinatory logic. 



Objects and a systemic approach 

If a programmer chooses an object-oriented approach to the develop- 
ment, it would most probably be a mistake to adjust the task under 
solution to a certain already known mathematical model. Probably, 



Preface to the first edition of the volume 1 1 

it would be much better to look for some nonstandard solution that 
adequately matches the specific features related to the very nature of 
the applied domain. In computer science, the metatheory is cho- 
sen for this purpose, within the framework of which the research is 
done and which is "adjusted" to the specific character of the applied 
domain. One of the means for such an adjustment is to embed the 
applied theory (a "smaller" theory) into pure metatheory (a "bigger" 
theory). Besides, from the mathematical viewpoint, within the frame- 
work of combinatory logic, it is convenient to build up sub-theories, 
i.e. special mathematical modules which in their finished form preset 
the computation mechanisms having a value of their own. Such rea- 
soning can easily find response with a programmer who has to deal 
with a big software project, when the advantages of considerations 
in terms of objects and their properties become especially evident. 
Combinatory logic makes it possible, by using mathematically ideal- 
ized objects, to preliminarily "play out" all the most complicated and 
delicate issues of interactions of mechanisms within a big software 
project. 

The City of Moscow 

September 1994 V.E. Wolfengagen 



12 Preface TO THE SECOND EDITION 

Preface to the second edition 

Applicative Computing Systems. The systems of calculuses of 
objects, based on combinatory logic and lambda-calculus, are tradi- 
tionally treated as applicative computing systems, or ACS. The only 
thing that is being essentially developed within such systems is the 
notion of an object. In combinatory logic the only meta-operator 
is application, or, within a different system of terms, the using the 
action of one object to another . Lambda-calculus has two meta- 
operators, i.e. application and functional abstraction that makes it 
possible to bind one variable within one object. 

Objects arising in such systems behave as functional entities, dis- 
playing the following features: 

• a number of argument places, or the arity of an object, is not fixed 
in advance but manifests itself gradually in interaction with other 
objects; 

• in designing a composite object, one of the initial objects, i.e. a 
function, is applied to another object, i.e. an argument, while in 
other contexts they may exchange their roles, meaning that func- 
tions and arguments are equally treated as objects; 

• self-applicability of functions is allowed, i.e. an object can be ap- 
plied to itself. 

Computing systems with this most general and least restrictive qual- 
ities turn out to be the center of attention of the contemporary com- 
puter science community. It is precisely these systems that cur- 
rently ensure the required meta-theoretical means, making it possible 
to study the properties of target applied theories, provide the basis 
for building semantic means of programming languages and ensure 
means for building data/metadata models within the informational 
systems. 



Preface TO THE SECOND EDITION 13 

The second half of the 70-ies — the beginning of the 80-ies wit- 
nessed an explosion in the development of applicative computing sys- 
tems, which has led to the progress in a whole range of trends of 
research and brought about an abundance of scientific publications. 
They were written in a special language, their reading and under- 
standing, to say nothing about mastering the very essence of the mat- 
ter, required a considerable theoretical background. There were a few 
reasons for that. 

In the first place, back in 1980 the theory of applicative compu- 
tations was still being actively developed, while one of the purposes 
of the authors of the publications was to arouse interest and involve 
mathematically talented students into the research in that field. 

In the second place, in the course of time, the role and place, 
assigned to the applicative systems in the curriculum, have changed 
with time. If earlier, in order to master the most important ideas, it 
was necessary to get closely familiar with a whole set of mathematical 
disciplines, now the study of basic elements of applicative computa- 
tions is included into a standard curriculum, being compulsory for 
the students in the first and second years. It means that, in writing 
a volume, preference should be given to the intensional method of 
presentation of the material, which involves only basic means in order 
to make the subject matter easily understood. 

In the third place, in the meantime, the courses in computer 
science have changed from purely mathematical and conceptual into 
a fairly prescriptional ones, giving something similar to a "quick 
overview" of a mass of ready-made solutions, methods, technologies 
and recommendations for use. 

In the fourth place, the attitude towards computer science has be- 
come, to a great extent, purely practical and even that of a consumer. 
In the majority of cases, it is expected that the mastering of this or 
that branch of computer science should immediately bring about a 
certain return. Students even display quite evident unwillingness to 
do exercises or solve tasks of creative or theoretical character, being 



14 Preface TO THE SECOND EDITION 



of a fundamental importance. In order to preserve the required level of 
education in applicative computations, the present volume contains 
examples and exercises of different character in the field of program- 
ming and their solutions are given by using basic means, without 
assuming any preliminary mathematical background. 

The required level of background. In this volume the main set 
of problems is presented using basic means and, as is expected, will 
cause no difficulties for students familiar with logic and the principles 
of proof methods. It is assumed that the reader is also familiar with 
the basics of programming, having a certain knowledge of data struc- 
tures. At the same time, the presentation of the material as a whole 
and partly inside separate sections is built following the ever growing 
degree of complexity, meaning to please those advanced readers who 
avoid books intended for "easy reading". The mastering of a number 
of sections will help the readers to achieve the level of the up-to-date 
research and stimulate their own scientific studies. 

Examples and exercises. The volume contains series of examples 
and exercises, the major part of which is provided with directions and 
solutions. As a rule, the solution itself includes a sufficient store of 
theoretical knowledge that will help not only understand the solution, 
but also look for other options. It stands to reason that such a book 
cannot be completely free from mistakes. In case you detect any 
mistakes or in case you have any suggestions as to how they should 
be corrected, please, do not hesitate to inform the author about it. If 
you have new tasks and exercises, the author will be especially glad 
to learn about it. However, if you decide to send them over, please, 
provide them with solutions before submitting them to the following 
e-mail address: vew@jmsuice.msk.ru. 

Source material and laboratory exercises. This volume is based 
on a course of lectures, delivered by the author at the Moscow En- 



Preface TO THE SECOND EDITION 15 



gineering and Physical Institute (MEPhl). The courses of lectures, 
delivered at the MEPhl on the basis of the present volume, are pro- 
vided with Laboratory Exercises. The Laboratory Exercises prod- 
uct is compatible with the IBM PC and is distributed on machine- 
readable media. 



Acknowledgements. The author highly appreciates the contribu- 
tion made by Dr. R.V. Khrapko, and N.PMasliy, A.S. Afanasyev, 
T.V. Syrova, who displayed a high level of interest in and profound 
professional understanding of the problems involved and their great 
erudition. In developing software, they strived to use applicative or 
purely object technologies and solutions, as well as the technique of 
dynamic formation of objects. 

The conditions and possibilities for application of the object ap- 
proach to software development were provided by V.V. Ivanchenko, 
who did his best to organize the scientific research process. 

l.V. Papaskiry's assistance and well-meaning attention made it 
possible to establish a permanently acting workshop, as well as a 
unique atmosphere of scientific debates during which the main range 
of ideas presented in the volume were discussed. 

Prof. L.T. Kuzin paid considerable attention to the methods and 
means for work with abstract objects, promoting research in that di- 
rection, its development, application and extension to the solution of 
various tasks in the field of cybernetic simulation. A whole number of 
results obtained was discussed at scientific workshops of the 'Applied 
Problems of Cybernetics" Section, chaired by him, while their appli- 
cation was presented within the framework of a cycle of disciplines, 
headed by him, for the students of the Cybernetics faculty of MEPhl 
as part of training engineers-mathematicians, specializing in applied 
mathematics. 

Sincere gratitude is due to K-A. Sagoyan for the preparation and 
check-up of solutions of all the examples, given in Section 6, that 
were also used in the Preprint publications. His thoroughness, hard 



16 Preface TO THE SECOND EDITION 

work and resourcefulness evoke genuine admiration. Various vari- 
ants of their solutions were tested by him in the course of conduction 
of laboratory exercises with the students at the MEPhI Cybernetics 
Department. 

Enormous patience and readiness to show a whole range of ap- 
plications for object calculus were shown by I.V. Chepurnova, who 
took upon herself the responsibility for the publication of the Preprint 
version of this volume. It would be impossible to overestimate her 
work of many years in organizing and conducting workshops for the 
MEPhI full-time students and for the post-graduate students of the 
MEPhI enhancement courses. Her special courses were based on the 
sections contained in the present volume, which were updated and 
extended at her suggestions. 

LA. Goryunova took upon herself a difficult assignment in picking 
up tasks for Section 16. Enthusiasm, displayed by her, and pro- 
found understanding of the mechanism of dynamic formation of ob- 
jects made it possible to select exercises, provided with solutions. 

A.G. Panteleev offered a number of valuable comments on Sec- 
tion 15. 

Wu-Hoang Ham indicated other possible variants of solutions for 
some examples. 

Profs. B.V. Biryukov and A.S. Kuzichev, who chaired the scien- 
tific workshop in the history and methodology of natural sciences at 
the Moscow State University (MSU), provided valuable recommen- 
dations in selecting bibliography. Prof. V.A. Smirnov indicated addi- 
tional possible areas of applications of intensional methods in combi- 
nation with object calculuses. 

Prof. S.Kh. Aytyan provided remarks for parts of the volume ma- 
terial in the course of its writing. Some aspects of object applications 
were discussed with Prof. G.G. Belonogov, Prof. G.Ya. Voloshin, 
Prof. S.N. Seletkov, and Prof. E.N. Syromolotov. 

Prof. P-L.Curien of Universite Paris VII, LITP, one of the au- 
thors of the categorical abstract machine concept, was very kind to 



Preface TO THE SECOND EDITION 17 



provide me with a number of his publications, which made it possible 
to speed up the work on the first publication of the volume. 

Dr. V.Ya. Yatsuk, shared his procedures and experience he gained 
while presenting object calculi in the courses, delivered by him. 
I.V. Mazhirin indicated some possibilities in developing versions of 
abstract machines. Dr. G.S. Lebedev, initiated the teaching of de- 
ductive extensions of object calculi. 

E.M. Galstyan rendered technical support in the preparation of 
the preliminary version of the volume text. 

The preparation of the present volume for publication was stret- 
ched in time and became feasible thanks to collaboration with the 
following numerous interested specialists, who took part in the work 
of scientific workshops held on the problems of computer science 
and information technologies at the Moscow Engineering and Phys- 
ical Institute, as well as organized practical lessons for students of 
different years of education, and supervised their course and diploma 
projects: Yu.G. Gorbanev, V.l. Vasiliyev, O.V. Voskresenskaya, 
M.Yu. Chuprikov, O.V. Barinov, LA. Alexandrova, G.K-Sokolov, 
S.V. Kosikov, l.A.Volkov, S.K- Saribekyan, K-A. Sagoyan,A.l.Mih- 
kaylov, T.V. Volshanik, Z.I. Shargatova, LA. Goryunova, A.V. Gav- 
rilov, L.V. Goltseva, E.V. Burlyaeva, V.A. Donchenko, I.V. Chepur- 
nova, A.V. Myasnikov, K-E. Aksyenov, S.l. Dneprovsky, S.V. Bryz- 
galov, S.V. Zykov, Ye.S. Pivovarova, A.Yu. Rukodanov, S.A.Kasta- 
nov, L.A. Dmitrieva, Yu.Yu. Parfenov, R.K- Barabash, A.l.Odrova, 
A.L. Brin, R.V Snitsar, A.L. Zabrodin, A.M. Grigoryev, G.G.Pogo- 
daev, B.B.Gorelov, M.L. Faybisovich, K-V Pankin, N.V Pishchimo- 
va, A.L Vaizer. 

Finally, it has become possible to issue the present volume "Com- 
binatory Logic in Programming" only thanks to the enormous time 
and energy, rendered by the employees of the Institute for Contempo- 
rary Education "JurlnfoR-MSU". 

The City of Moscow 

January 2003 V.E. Wolfengagen 



18 Introduction 

Introduction 

Objects and modes of combining the objects represent all that is es- 
sential in combinatory logic. Combination of objects with some other 
objects is implemented by initial identification of objects-constants, 
called combinators. There are just a few such initial combinators, 
however, by using them one can build such well-known formal sys- 
tems as the logic of statements, the logic of predicates, arithmetic 
systems' and a whole number of others. In the past ten years, combi- 
natory logic has become one of the basic metamathematical tech- 
niques of computer science, having shown its capabilities in the 
sphere of programming. There has appeared a whole family of func- 
tional programming languages. Miranda, ML, KRC, being suffi- 
ciently well known to programmers, give us an idea of their possible 
application. However, the object-oriented approach to programming 
and designing of applied systems as a whole, which has already 
displayed its overall potential, raises fundamental questions, refer- 
ring to the method of operation itself in terms of objects. For this 
purpose, a preselected universe of discourse is required, being a sort 
of theoretical shell that guarantees mathematical fruitfulness of the 
performed investigation. This is felt especially acutely in the process 
of implementation of large software projects when the choice of a 
systematic method of representation and operation of objects acquires 
decisive importance. 

Discussion of the volume structure 

The structure of this volume and the layout of separate sections are 
implemented in such a way as to enable the reader to fully concentrate 
the attention on the matter of computations with objects being of 
fundamental importance. 



More rigorously: the systems of numerals 



Introduction 19 



• Synthesis of a new object 

One of the most important tasks, solved within the framework of 
combinatory logic, is formulated as a task of synthesis of an object 
with preset properties out of the available objects by using the already 
known modes of combining. At the initial stage, the availability of 
only three objects-combinators is assumed: /, K, S, as well as that 
of their properties, preset by characteristic equations. To preserve 
the intuitive clarity, one can assume that there exists a system of 
programming with these three instructions and, using exclusively 
these instructions, one will have to build up a system of programming, 
being rich enough in its expressive capabilities. The resultant system 
will contain solely objects-combinators. 



• Characteristics of a fixed point combinator 

The transparency of combinatory logic makes it rather easy to study. 
After the first steps, it may seem that within it we always have to deal 
with simple and finite in their nature objects. However, that impres- 
sion is deceptive, and, by using combinators, it is possible to represent 
processes, including loop computations, which are problems with a 
recursion stack, being well known in programming. 



• The use of the extensionality principle 

The characteristic feature of combinatory logic is that it is possible to 
build and apply functions within it, having a number of arguments 
that is not fixed a priori. It means that one should be cautious 
enough while answering the question about how many argument po- 
sitions the applied function-object has in reality. Indeed, careful use 
of sufficiently simple principles of extensionality (expansibility) makes 
it possible to overcome that indefiniteness. 



20 Introduction 



• Numerals and their properties 

Note that, from the very beginning, there are no . . . numerals among 
primary objects in combinatory logic. The point is that the concept of 
a numeral can be developed independently, by using known combi- 
nators. In such a case, numerals present themselves in a somewhat 
unusual aspect, being objects, which display their arity, depending on 
the used system of postulates. In the same way, arithmetical opera- 
tions are successfully developed in the form of combinators. In other 
words, arithmetical entities are built into combinatory logic. This 
situation is well known in object-oriented programming, i.e. an ap- 
plication (arithmetical objects with their rules) is built into a software 
environment (combinatory logic). 

• Study of properties of combinators with types 

The concept of a class is one of the most important in object-oriented 
speculations. In this case, a class is understood as a sample for cre- 
ating specimens of concrete objects. Moreover, classes themselves 
can be treated as objects. Similarly, combinators are classified or 
typified. The high order of functional spaces turns out to be important 
for combinators. Nevertheless, the intuitive clarity of the work with 
combinators as objects does not get lost. 

• Expansion of terms in the /, K, S basis 

Let us concentrate on the simplest system of programming with only 
three instructions: /, K, S. It is possible to synthesize a new object 
by a purely mechanical use of the algorithm of expansion in the basis, 
being quite similar to the process of compilation. 

• Expansion of terms in the /, B, C, S basis 

As it turns out, the /, K, S basis is not the only one, and the set of 
combiners /, B, C, S also displays the property of a basis. Compila- 



Introduction 21 



tion (expansion) of an object in that basis also resolves the problem of 
synthesis of an object with preset properties. Evidently, it is possible 
to use the freedom of selecting a basis, depending on some criteria. 



• Expression of function definition using the fixed point opera- 
tor y 

The case of recursive definitions of objects is considered. By using the 
fixed point theorem, being fundamental for functional programming, 
recursive definitions can be successfully reduced to the conventional 
equational form. 



• Study of properties of the listl function 

Capabilities for building a function-object in a parameterized form are 
shown. By assigning particular values to arguments — and functions 
can also be these particular values, — it is possible to get a whole 
family of definitions for particular functions. 



• EstabMshment of isomorphism for the Cartesian closed cate- 
gory and applicative computation system 

Now, we begin to move into the depths of mathematical abstractions 
and start coordinating the operational way of thinking with combi- 
natory approach. Note that within combinatory logic, use is made 
of only one operator, i.e. the application operator, or the operator 
of application of one object to another. The system of computations, 
arising as a result of it, is called an applicative computation sys- 
tem. It is linked up with the conventional computation system, being 
represented by a special object, i.e. the Cartesian closed category. 



22 Introduction 



• Building of representation, currying the n-ary function 

Within combinatory logic, n-ary functions-operators, used in opera- 
tional programming, have images in the form of objects, which inherit 
all their substantial properties. 



• Deriving of basic properties of the Karoubi's Shell 

A special category, called the Karoubi's shell, makes it possible to 
laconically express a whole body of knowledge, related to operators, 
in terms of combinatory logic. In this case, the types are also encoded 
by objects. As a result, we implement the immersion or embedding of 
the typed application into the type free software environment. 

• Cartesian product and projections: embedding into ACS 

The final completion of the started process of embedding is achieved 
by the introduction of ordered populations of objects into considera- 
tion. It has turned out that applicative computations also allow their 
representation. 

• Lisp Representation by means of lambda-calculus or combi- 
natory logic 

A non-trivial application is built into the applicative computation sys- 
tem: a considerable and, actually, complete fragment of the well- 
known Lisp system of programming. 

• Implementation of computation of expressions values with 
the help of supercombinators 

It is discussed how the object-oriented systems, built into combina- 
tory logic, work. Thus, it is possible to directly satisfy the need in 
denotational computation of instructions of programming languages. 



Introduction 23 



when objects are used to express the functional meaning of a pro- 
gram. It is significant that computation begins with a certain a priori 
known set of instructions. In the process of the program value com- 
putation, new instructions dynamically arise, being earlier unknown 
but indispensable in the process, which are additionally fixed in the 
system of programming. 



• Fully lazy implementation of supercombinators 

When the dynamic formation of objects is performed "on-fly", the 
efficiency of the resulting code may be lost because of the need to 
repeatedly calculate the value of one and the same object. The ap- 
plication of the mechanism of lazy evaluations makes it possible to 
avoid it: once the value of an object has been calculated, this already 
calculated value will always be used further on. 



• Optimization of computation process by permutation of pa- 
rameters 

The use of combinators makes it possible to build up an optimized 
program code, while, in the course of synthesis of the resulting object, 
analyzing the order of the possible substitution of formal parameters 
with actual ones. 



• Implementation of direct computations of expressions of 
programming languages 

The technique of evaluating the expressions is reconsidered in the 
view of systematic build-up of both syntactic and semantic equa- 
tions, implementing the selected paradigm of object-oriented com- 
putations. 



24 Introduction 



• Evaluation of the de Bruijn's code 

A technique for re-designation of bound variables (formal param- 
eters) is introduced into consideration, which makes it possible to 
avoid binding collisions in replacing formal parameters by actual 
ones. This technique of re-designation is called de Bruijn's encod- 
ing and allows, in fact, the lambda-calculus apparatus to be used on 
the same legal basis as for the combinatory logic apparatus. 

• Implementation of machine instructions of the categorical 
abstract machine (CAM) 

A special version of the theory of computation, named categorical 
abstract machine, is being built. For this purpose, a special fragment 
of combinatory logic, i.e. categorical combinatory logic, is introduced 
into consideration. It is represented by a set of combinators, each of 
which being of a self-sustained significance as an instruction of the 
system of programming. Thus, one more useful application, i.e. the 
system of programming, based on the Cartesian closed category, is 
being built into combinatory logic. It allows the connection between 
the operative and applicative styles of programming to be reconsid- 
ered once again but at a new level. 

• Capabilities of optimization in computation on the CAM 

The use of Cartesian closed category opens up additional capabilities 
for the optimization of the resulting program code. In addition to the 
properties of combinatory logic per se, used as a shell, it is allowed to 
use special categorical equations, borrowed from the Cartesian closed 
category, as from an application. 

• Variable objects 

The concluding part of considering the calculi of objects deals with 
generic questions of mathematical representation of objects. It is 



Introduction 25 



shown that the use of the concept of the functor-as-an-object allows 
the basic laws of the object-oriented computations to be reviewed in 
a compact and laconic form. In particular, the emphasis is laid on 
the systems of changing (variable) notions-concepts, which are con- 
ventional objects of combinatory logic but display properties, being 
useful for programming. For example, with the help of variable con- 
cepts, the theory of computations is built without any complications, 
as well as the semantics of the programming systems and the models 
of data objects. The data-as-objects display new degrees of freedom 
in computer considerations. 



Short recommendations about the order of studying the 
volume 

It is possible to outline the order for reading of the given volume. 
Stand-alone reading of Sections 2—4, 6 requires only minor efforts on 
the part of a reader. This material gives you a feeling about flexibility 
and impressibilities of the language of combinatory logic. 

To this preliminary part. Sections 5, 9, 7—8 can be added, which 
deal with numerals, recursion, and expansions in basis. 

Then, one may read Sections 10, 15—18, introducing a body of 
concepts for programming by means of combinators with the dy- 
namic system of instructions. 

Other sections can be added to one's taste. In particular, a more 
detailed acquaintance with the categorial abstract machine in Sec- 
tions 19—22 will require one to refer to the literature cited in the bib- 
liography. Sections 11 — 14 are aimed at those readers, who want to 
independently begin reading original research papers in the field of 
computer science. Having mastered the basic ideas of the theory 
of computation, one can start reading papers, devoted to this topic. 
On the other hand. Section 23 may of interest to those readers, who 
would like to go deeper into the very essence of creating "built-in 
applications", requiring modification of the software environment. In 



26 Introduction 

such a case, the researcher encounters variable notions or, in other 
terms, variable concepts. 



Chapter 1 

Preliminaries 



Nowadays the theoretical studies in an area of computer science are 
grounded at the stable main mathematical means. As it happened, 
this is just the several interrelated branches, giving rise both to logic 
and computer science. Among them are \-calculus, combinators, 
type systems, category theory and programming languages. 

A-calculus. In this branch those modes of constructing the pure 
calculus of functional abstraction and application of functions are 
studied, that obtain the application areas in metamathematics, logic 
and computer science. 

Combinatory logic. In developing this branch it has been shown, 
that bound variables can be excluded without lost of expressive power 
of the formal system. The most important applications of combinatory 
logic have been found in constructing the foundations of mathemat- 
ics, and in constructing methods and and tools for implementing the 
programming languages. 

Type systems. Currently, A-calculus gives the main means for 
studying the type systems, and its results gave an important insights 

27 



28 Chapter 1 : Preliminaries 



both for the foundations of mathematics and for the practice of con- 
structing and applying of programming languages. 



Category theory. This branch, from a mathematical point of view, 
deals just with two entities — objects and mappings, — but the last, 
in turn, can be considered as objects. Applying the methods of cate- 
gory theory seems especially important in case of research, develop- 
ment and application of the object programming systems. 



Programming languages. It is rather difficult to consider these 
three main branches: A-calculus, combinatory logic and type sys- 
tems, — singularly, separated each from others. They are interrelated, 
and current point of view is in their mutual studies. Moreover, namely 
these three branches give a sound ground to construe the program- 
ming languages. 

Currently, there are more and more reasons to add to this list, on 
equal rights, one more branch — category theory, which involves the 
only notion, namely: representation of an abstract object that covers 
the mappings as well. 

At a first look, a spectrum of ideas, covered in these branches, 
is not homogeneous, resulting in growth of seemingly disparate for- 
malisms and mathematical means. Actually, it happens even more: 
every current research, as a rule, includes the constructing of its own 
mathematical means. Rather often, the main mathematical ideas, 
used by the author, are hidden by the complicated evaluations. 

Studying of the branches, mentioned above, helps to discover the 
intrinsic unity of the disparate researches, and their regular appli- 
cation supplies a researcher or developer by both the conceptually 
transparent and flexible and powerful theoretical means. 



Chapter 1 ; Preliminaries 29 

1.1 The Spectrum of ideas 

Currently, after more careful consideration, it appears that the fulfilled 
in an area of computer science researches use some or other ideas 
either of category theory, or of combinatory logic, or of calculi of 
X-conversions, or of all these three disciplines altogether. 

Importance of getting acquainted the knowledge of these bran- 
ches of mathematics is so evident, that, opening practically occa- 
sional proceedings of any conference in computer science, you can 
find not only pure nominal usage of A-notations, but actual con- 
structing of own mathematical language, which is based on using 
the applications and abstractions. Nevertheless, the attempts of self- 
studying the foundations of A-calculus or combinatory logic meet the 
difficulties from the very early steps: a known effort is needed "to fit 
a way of thinking" from operational point of view of mathematical 
notations to applicative one, when there is no generic separation of 
mathematical entities into 'functions' and 'arguments', but there are 
the only 'objects'. It is interesting to observe, that the same object, 
depending on a context, can be used in different roles, sometimes 
playing the role of an argument and sometimes — the role of a func- 
tion. 

From the syntax point of view, the objects are indicated either by 
the notations with parentheses, or by using an agreement of omitting 
the non-significant parentheses, when they, by need, can be restored 
without any ambiguity. Another significant feature is to establish a 
property of being basic for some pre-specified objects. Any time it 
is evident, that newly introduced object can be rather suitably repre- 
sented by combining of generic objects, which, under such a circum- 
stance, can be called the combinators. It is difficult to overestimate 
this ability to disassemble the arbitrary introduced object into basis: 
in place of studying of properties of complicated applied theory with 
a great amount of distinct objects, it could be possible to study the 
properties just of several objects, without any loss of generality of the 



30 Chapter 1 : Preliminaries 

obtained result. 

For a specialist in computer science this is rather desirable prop- 
erty. It is evident, that the basic combinators can be assumed as a 
system of commands of some abstract computing system, and the 
rest of the objects can be expressed, i.e. "programmed", by using 
namely this set of commands. In spite of seeming evidence, this abil- 
ity of means of the combinatory logic is not yet properly applied in 
practice of computer studies. 



1.2 Layout of a chapter 

A discussion of philosophical, pure mathematical or technical aspects 
of applicative computations can lead far distant to the side of founda- 
tions of mathematics. Nevertheless, there is rather acceptable way. 
For a beginning, it can be reasonable to restrict yourself by solving 
some — however, for a first look, abstract, — problems, and after that 
make a conclusion, if is it needed to move further, in depth of ideas of 
applicative computations. 

This chapter is to be assumed as some kind of menu, in which the 
main questions are indicated, and interaction of which, at first, could 
be seen immediately, but after that, in detailed study, getting clear its 
deeper essence. 

The current chapter contains the sets of variants of the tasks, 
which are recommended to use in self studying. 

In case of organizing the studying in the classes of A-calculus 
and combinatory logic, it can be recommended to select out the spe- 
cial units of tasks by variants, allowing to make not "so large", but 
rather acceptable steps in learning of new mathematical, or, better, 
computational ideas. These variants of the tasks are arranged in the 
Table l.I. The tasks for self studying are composed by such a way, 
that covers most of the chapters in this volume. 



Chapter 1 ; Preliminaries 



31 





Table 1.1 


: The variants of tasks 


Variant N° 


R( 


^commended unit of tasks 


1 


1.1 


2.6 


3.3 


4.7 


5.1 


6-r 


2 


1.2 


2.5 


3.1 


4.6 


5.2 


6-2° 


3 


1.3 


2.4 


3.2 


4.5 


5.3 


6-3° 


4 


1.4 


2.3 


3.3 


4.4 


5.4 


6-4° 


5 


1.5 


2.2 


3.1 


4.3 


5.1 


6-5° 


6 


1.6 


2.1 


3.2 


4.2 


5.2 


6-6° 


7 


1.7 


2.5 


3.3 


4.1 


5.3 


6-7° 


8 


1.8 


2.4 


3.1 


4.7 


5.4 


6-8° 


9 


1.9 


2.3 


3.2 


4.6 


5.1 


6-9° 


10 


1.10 


2.2 


3.3 


4.5 


5.2 


6-1° 


11 


1.11 


2.1 


3.1 


4.4 


5.3 


6-2° 


12 


1.12 


2.5 


3.2 


4.3 


5.4 


6-3° 


13 


1.1 


2.4 


3.3 


4.2 


5.1 


6-4° 


14 


1.2 


2.3 


3.1 


4.1 


5.2 


6-5° 


15 


1.3 


2.2 


3.2 


4.7 


5.3 


6-6° 


16 


1.4 


2.1 


3.3 


4.6 


5.4 


6-7° 


17 


1.5 


2.5 


3.1 


4.5 


5.1 


6-8° 


18 


1.6 


2.4 


3.2 


4.4 


5.2 


6-9° 


19 


1.7 


2.3 


3.3 


4.3 


5.3 


6-1° 


20 


1.8 


2.2 


3.1 


4.2 


5.4 


6-2° 


21 


1.9 


2.1 


3.2 


4.1 


5.1 


6-3° 


22 


1.10 


2.5 


3.3 


4.7 


5.2 


6-4° 


23 


1.11 


2.4 


3.1 


4.6 


5.3 


6-5° 


24 


1.12 


2.3 


3.2 


4.5 


5.4 


6-6° 


25 


1.1 


2.2 


3.3 


4.4 


5.1 


6-7° 


26 


1.2 


2.1 


3.1 


4.3 


5.2 


6-8° 


27 


1.3 


2.5 


3.2 


4.2 


5.3 


6-9° 


28 


1.4 


2.4 


3.3 


4.1 


5.4 


6-1° 


29 


1.5 


2.3 


3.1 


4.7 


5.1 


6-2° 


30 


1.6 


2.2 


3.2 


4.6 


5.2 


6-3° 


31 


1.7 


2.1 


3.3 


4.5 


5.3 


6-4° 



32 Chapter 1 : Preliminaries 

1.3 State-of-the-art in an area 

For advanced and deeper learning of the chapters of this volume, for 
those, who will not be satisfied with rather elementary level, some 
papers and books can be recommended. A part of them is quite acces- 
sible as a material for the first reading, while others have a character 
of originally performed research. In the last case, a possibility to be in 
touch with that, what is done like a mathematical theory in computer 
science, is left. For this purpose best of all is to use the originally 
published works in its author's edition, to read and understand which 
it can be quite possible to get ready by solving the recommended 
tasks. 

Pioneer for the computer science research has been conducted 
by J. McCarthy (J. McCarthy, [101]). He constructed a language 
for list processing Lisp, which is quite object-oriented and, in addi- 
tion, a functional programming language. During the years. Lisp was 
one of the most popular programming systems in an area of artificial 
intelligence, getting acquainted the name of 'knowledge assembler'. 
Note, that Lisp is a computer implementation of A-calculus, giving to 
a programmer practically all the means of this powerful mathematical 
theory. An effective implementation of the Lisp-interpreter, done by 
A.G. Panteleev (A.G. Panteleev, [ ]; M.A. Bulkin, Yu.R. Gabovich, 
A.G. Panteleev, [ ]), have revealed a lot of details, concerning the 
implementation of object and functional languages, and the ways and 
methods of their efficient usage. The methods of implementing the 
mechanisms of binding the variables, the data structures, the pro- 
cedures, the functions and recursion, established in works on this 
project, have been stimulated the entire direction of research activity 
in a programming. 

In the books (L.T. Kuzin, [25], [2fi]) it can be found a short and 
acceptable for an engineer introduction to the notations in A-calculus 
and combinatory logic. A complete covering of all the spectrum of 
mathematical ideas is in the book (H. Barendregt, [ ]), however, to 



Chapter 1 ; Preliminaries 33 

learn it, a preliminary mathematical background is needed. Clas- 
sic, very detailed, transparent and circumstantial discussion of log- 
ical means of applicative computational systems, given in the book 
(H. Curry, [ ]), will help to form a vision, possibly, of all the object- 
oriented approach, which was developed in the mathematical bran- 
ches of computer science. It ought to have in mind, that due to the 
efforts of H. Curry, combinatory logic has been formulated not only as 
a general mathematical discipline, but as the necessary foundation for 
computer studies. 

Different assistance in methods of solving the problems, giving 
insight for applications of applicative computational systems (ACS), 
can be found, e.g., in (A.A. Stogniy, V.E. Wolfengagen, V.A. Kushni- 
rov, V.I. Sarkisyan, V.V. Araksyan, and A.V. Shitikov, [39]), (V.E. Wol- 
fengagen,[4 1]), (V.E. Wolfengagen and V.Ya.Yatsuk,[ ]), (V.E. Wol- 
fengagen and K-A. Sagoyan, [43]), (V.E. Wolfengagen, K-E. Aksenov, 
L.Yu.Ismailova, and T.V Volshanik, [44]), (A.A. Ilyukhin, L.Yu.Is- 
mailova, and Z.I. Shargatova, [12]), (K-E. Aksenov, O.T. Balovnev, 
V.E. Wolfengagen, O.V Voskresenskaya, A.V. Gannochka, and 
M.Yu.Chuprikov, [ ]). 

Research work (V.E. Wolfengagen and VYa. Yatsuk, [ ]) reflects 
the early state-of-the-art and contains the detailed constructions for 
several variants of applied applicative systems, valuable for solving 
the applied problems aimed to development of information systems. 

A distinctive place is occupied by the work (D. Scott, [1 15]). Its 
soundness and a range of influence for several generations of the- 
oreticians in computer science hardly ever might be overestimated. 
Evidently, far not all the ideas from this paper have found its imme- 
diate application. In particular, an idea to construe the systems of 
combinators for special classes of computations stimulates the deep 
and vital studies. 

The papers (G. Cousineau, P.-L.Curien, and M.Mauny [ ]), 
(P.-L. Curien, [76], [77]) contain the constructing of a special kind 
of combinatory logic called categorical combinatory logic. It gave 



34 Chapter 1 : Preliminaries 

a foundation for constructing the abstract machine, which is both 
an enhanced notion of computation and self standing programming 
system, aimed to pursue the research in an area of programming. 

Several supplementary works, given in bibliography, will assist 
to start with your own research in various applied areas, using the 
possibilities of applicative computational systems. In (R.B. Banerji, 
[62]), (V. Wolfengagen, [ l Z5]) the applications in artificial intelligence 
could be found. 

A particular attention could be paid to the research papers by 
D. Scott (D. Scott, [1 10], [1 1 1], [1 12], [1 13], [1 14], [1 15], [1 16], [1 17], 
[1 18]). These (and many other) of his works gave not only the math- 
ematical foundations, but all the contemporary system of thinking in 
computer science. Computation theory, semantic of programming 
languages, object based computations — this is far not complete list 
of research directions, inspired by this mathematician. 

An introduction to mathematical problems of combinatory logic 
and A-calculus can be found in a series of papers (A.S. Kuzichev, 
[16],[17], [18], [19],[20], [21], [22], [23],[24]). In theses papers a re- 
search experience of expressive power of the systems with operators 
of application and (functional) abstraction is covered. The elementary 
basics of combinatory logic are covered in (J. Hindley, H. Lercher, and 
J.Seldin, [ ]). 

The research works by N. Belnap could be useful in constructing 
a theory of computattional information systems (N. Belnap, [3], [64], 
[65]). Similar topics are covered in (M. Coppo, M. Dezani, G. Longo, 
[74]). 

The programming systems in terms of objects, based on applica- 
tive computations, with various details are covered in [5], [54], [59], 
[60], [67], [84], [85], [91], [95], [102], [105], [124]. As an introduction 
into the spectrum of ideas, how to develop a semantic of programming 
languages, the book (V.E. Wolfengagen, [51]) can be used. 

As a source work — for supercombinator programming, — a par- 
ticular attention could be paid to the research (R.J.M. Hughes, ["^]) 



Chapter 1 ; Preliminaries 35 

and (S.L. Peyton Jones, [ ]). 

The advance in formal methods is in (R. Amadio and P.-L. Curien, 
[56]), (J. Lambelt and P. Scott, [ ]), and, in application to event- 
driven computations, is in (V. Wolfengagen, [130]). 

The rest of the citations, given in the bibliography, could assist to 
get intuitive vision in the adjacent to mentioned here questions and 
start with your own research in applicative computing. 

1.4 Typical task 

General advice to solving a typical task. 

Task formulation. Derive via K and S the object with combinatory 
characteristic: 

la = a, (/) 

using postulates a, (i, fi, v, a, r, ^ of A-conversion. 
Solution. 

I— 1 . List the postulates, which determine a relation of conver- 
sion '=' : 

{a) \x .a = \z .\z I x\a\ (/3) {\x .a)h = \b j x\a\ 
a = b , , a = b 

(0 

1—2. Define the combinatory characteristics of the objects K 
and S: 

v{Kxy) = vx, (K) 

v{Sxyz) = v{xz{yz)), (S) 

which are expressible in A-calculus by the equalities K = Xxy.x 
and S = \xyz.xz{yz). 



ac= be 


VH'J 


ca = cb^ 








a = b 


(r) 


a = b; b = c 


{<y) 


a = 


- b 


Xx.a = Xx.b^ 


a = c 


b = 


- a 



36 Chapter 1 : Preliminaries 

1—3. Using schemes (K) and (S), get confidence in that: 



a = Ka{Ka) (K) 

= SKKa. {S) 



Checking. Make sure, that actually / = SKK. Let v = empty 
(empty object). 



I— I. SKKa = Ka{Ka), because in scheme (S) can be set 
X = K,y = K, z = a. Then it is evident, that by postulate (a): 



Sxyz = SKKa, xz{yz) = Ka{Ka), SKKa = Ka{Ka). 



1—2. Using in a similar way the scheme (K), conclude, that 
Ka{Ka) = a. 



1—3. By rule of transitivity (r), if the equalities SKKa = 
Ka{Ka) and Ka{Ka) = a are valid, then SKKa = a. 



Answer. Object / with given combinatory characteristic la = a is 
SKK, i.e. / = SKK. 



Chapter 1 ; Preliminaries 37 

1.5 Variants of task 

X Work 1. Derive via K and S the objects with given combinatory 
characteristics: 



1) 


Babe 


= a{bc), 




2) 


Cabc 


= acb, 




3) 


Wab 


= abb, 




4) 


^abcd 


= a{bc){bd), 




5) 


C^^^abcd -- 


= acdb, 




6) 


C[2]Cibcd 


= adbc, 




7) 


B^abcd 


= a{bcd), 




8) 


Ya 


= a(Ya) (prove, that Y = 


= WS{BWB)) 


9) 


C^^^ abode = 


= acdeb, 




10) 


Cmabcde = 


= aebcd, 





11) B^abcde = a{bcde), 

12) ^abcd = a{bd){cd). 



X Work 2. Determine a combinatory characteristic of the following 
objects: 

1) {\x.{P{xx)a)){\x.{P{xx)a)) = Y, 

2) Y = S{BWB){BWB), 

where B = Xxyz.x{yz), S = Xxyz.xz{yz), W = Xxy.xyy, 

3) r = WS{BWB), 

where Wab = abb, Sabc = ac{bc), Babe = a{bc), 

4) Fo = \f.X{X), where X = \x.f{x{x)), 

5) Fi = yo(Ay.A/./(y(/))), 

where Yq = Xf.X{X), X = Xx.f{x{x)). 
(Hint: prove, that Yia = a(Yia).) 



38 Chapter 1 : Preliminaries 



t Work 3. Prove, that: 

1) X = Xx.Xx,x^X, 

2) Yo = Xf.fiYoif)), where Yo = Xf.X{X), 

X = Xx.f{x{x)), 

3) Fi = A/./(yi(/)), where Y, = Yo{Xy.Xf-f{y{f))), 

lo = Xf.X{X), X = Xx.f{x{x)). 

X Work 4. Determine a combinatory characteristic of the following 
objects' (prove it!): 



1) S = C{BCF)I, 

2)F = bIcb'^B)E, 

i)P = ^EK, 

4)& = B'^{CEI){C{BB^P)P), 

5) V = B\CEI){C{B^B{B{<^Sz))P)P), 

6)- = CP{UI), 

7) 3* = B{WiB^i<^P)CE))K, where 3[a] = 3*[a], 3 = 3[I]. 



Hints. 



1) Cabc = acb, la = a, Babe = a{bc). 

2) Babe = a{be), B^abed = a{bed), Eab = Fabl. 

3) ^abed = a{be){bd), Kab = a. 

4) Babe = a{be), B^abed = a{bed), la = a, Cabe = acb. 

5) Babe = a{be), B^abed = a{bed), la = a, 
^abcd = a{bd){cd), kab = E{B^{Pa)Pb)I. 

6) Cabe = acb, la = a, II = EWE, Wab = abb. 

7) Prove, that 3[b]a = P{Ea{Kb))b. 



' Notations; P — implication, S — formal implication, F — operator of function- 
ality, & — conjunction, V — disjunction, n — universal quantifier, -i — negation, 3 - 
existential quantifier. The objects E, F, P, &, V are two placed, and the objects -i, 
n, 3 are one placed. 



Chapter 1 ; Preliminaries 39 



Use the following equalities: 

Babe = a{bc), Boated = a{bcd), Wab = abb, 

Cabc = acb, ^abcd = a{bd){cd). 

if Work 5. Verify the validity of the the following combinatory char- 
acteristics: 

1) S{KS)Kabc=a{bc), 

2) S{BBS){KK)abc=acb, 

3) B{BW{BC)){BB{BB))abcd= a{bc){bd), 

4) B{BS)Babcd= a{bd){cd). 

Hint. Kab = a, Sabc = ac{bc), Babe = a{bc), Cabc = acb, Wab = 
abb. 

X Work 6. Perform the following target studies: 

6- 1 ° study a disassembling of terms into the basis /, K, S; 

6-2° study a disassembling of terms into the basis /, B, C, S; 

6-3° express definitions of the functions, using a fixed point combi- 
nator y; 

6-4° study the properties of the function: 

listl a g f X = if null x 
then a 
else g(f{car x)) (listl a g f{cdr x)); 

6-5° establish the isomorphism between a cartesian closed category 
(c.c.c.) and applicative computational system (ACS); 

6-6° derive the mapping, which corresponds to the currying mapping 
of a function (for n-ary function); 

6-7° derive the main properties of Karoubi's shell; 



40 Chapter 1 : Preliminaries 

6-8° determine the encoding of a product of n objects (n > 5) by 
terms of type free A-calculus and derive the corresponding ex- 
pressions for projections; 

6-9° represent the main functions of the applicative programming 
language Lisp by means of A-calculus and combinatory logic. 

Formulation of the tasks for corresponding target studies in the 
Work6, p. 39. 

6-1° Let the definition of term Xx.P be given by induction on con- 
structing P: 

1.1) Xx.x = I, 

1.2) Xx.P = KP, \ix<^FV{P), 

1.3) Xx.P'P" = S {Xx.P') {Xx.P"). 

Exclude all the variables from the following A-expressions: 
Xxy.xy, Xfx.fxx, f = Xx.B{f{Ax)). 

6-2° Let the definition of term M such, that x G FV{M), be given 
by induction on constructing M: 

2.1) Xx.x = I, 

' {a) BP{Xx.Q), if X <^FV{P) 

and a; G FV{Q), 

{b)C{Xx.P)Q, \ix€FV{P) 

and x ^ FV{Q), 

(c) S{Xx.P){Xx.Q), if a; G FV{P) 

and X G FV{Q). 

Exclude all the variables from the following A-expressions: 
Xxy.xy, Xfx.fxx, f = Xx.B{f{Ax)). 



2.2) Xx.PQ= < 



Chapter 1 ; Preliminaries 



41 



6-3° Using the fixed point function y, represent the following defini- 
tions of functions, given by examples: 



length(a^, a2, ae) 
sum(l,2,3,4) 
product{l, 2, 3,4) 
append{l, 2)(3,4, 5) 
concat((l, 2), (3,4), 0) 
map square{l, 2, 3, 4) 



3, 

10, 

24, 

(1,2,3,1,1), 

(1,2,3,4), 

(1,4,9,16). 



6-4' 



For the examples, given above, perform a detailed verification of 
the steps of computations. 

Using definition of the function listl and the following defi- 
nitions: Ix = X, Kxy = X, postfix x y = append y{ux), 
where (ux) is the notation of a singular list, containing a single 
element x, express the functions, given below: 

(a) length, sunisquares, reverse, identity; 

(b) sum, product, append, concat, map. 

6-5° Derive the following equalities: 

h = eo < (Ah) op^q >, 
k = A(eo < A; op, g >), 



where: 



<f,g > 

h 

k 
sbc 

J^ABC 
P 

q 

eo < k o p,q > 



Xr.rxy, 

Xt.[f{t),g{t)] = Xt.Xz.z{ft){gt), 

AxB ->C, 

A^{B^ C), 

{B ^C) X B 

{Ax B ^C) 

Ax B ^ A, 

AxB -> B, 

AxB ^C. 



C,x:A,y:B, 
(A^iB^C)), 



42 Chapter 1 : Preliminaries 



6-6° Concerning a family of functions h: 



h2 
hi 
hi 



Ax B ^C, 
Ax B xC ^ D, 
Ax B xC X D ^ E, 



find the family of mappings 

AaBC, A(^xB)CZ3) ^{AxBxC)DEi ■ ■ ■ , 

which make currying of the functions above, i.e. transform the 
functions from "operator" form to applicative form. 

6-7° By Karoubi's shell we mean the category, which contains for 
aoh = Xx.a{bx): 

sets of 

objects: {a \ ao a = a}, 
morphisms: Hom{a, b) = {f \ b o f o a = /}, 

and morphisms of 

identity: id a = a, 
composition: fog. 

Assume, that 

[x, y] = Xr.rxy, 
<f,g> = Xt.[f{t),g{t)] = Xt.\z.z{ft){gt). 

Verify, that: 

h = so < (Ah) o p,q >, k = A(eo < k o p,q >), 



Chapter 1 ; Preliminaries 43 



where 



h-.AxB^C, 






k:A^{B^C), 






EBC ■■ {B ^ C) X B - 


^C, X 


■A,y:B, 


Aabc :{AxB^C)- 


.{A^ 


(B ^ C)) 


p-.AxB-^A, 






q:AxB->B, 






eo <kop,q> : Ax B —> C. 







(Hint. Use the encoding of functions as f : A ^ B hy the 
terms Bo foA = Xx.B{f{Ax)). Next, use the equality: AoA = 
A{= Xx.A{A{x))). Take into account, that Ah = Xxy.h[x, y].) 

6-8° Derive a term of lambda-calculus, which corresponds to the 
product of n objects. In addition, derive such n terms, that 
behave as the projections. 
(Hint. In case of n=2: 

AoxAi = \u.[AoiuK),AiiuiKI))], 
ttq = Xu.{Ao X Ai){u)K, 

Xu.{Ao X Ai){u){KI).) 



^2 



6-9° Represent via combinators the following set of function of the 
language Lisp: 

{Append, Nil, Null, List, Car, Cdr}. 

(Hint. For Append =-^ and for Nil =<>: 

(1) A^{B ^C) = {A^ B) ^ C 

(2) A^<> = <>^ A = A 

,. „ . f 1, if ^ = Nil, 

(3) Null A = < ' ., , , ,,.,' 
^ ^ \ 0, if A/ Nil, 

(4) List X = < X >, 

(5) Car < xi,X2,. . . ,Xn > = xi, 

(6) Cdr < Xi,X2,. ■■ ,Xn> = < X2,. . . ,Xn > .) 



44 Chapter 1 : Preliminaries 

1.6 A recommended order of solving the tasks 

1 ) By a variant number, select out the corresponding formulation of a 
task. 

2) Learn of the solution of a typical task, included in the text. Sim- 
ilar to the solution of a typical task, perform the steps of the needed 
derivation. 

3) Check the correctness of the obtained result (answer), performing 
the computations in a reversed order. 



Chapter 2 



Derivation of Object 



A question what are the 'data' or what is the 'program' is so nice 
that we would not even make an attempt to answer it. It's possible 
to assume that "a data structure complexity is exchanging for an 
algorithmic complexity", but this needs to determine what are the 
representations for algorithm and data structure. Any case, usually 
the programs are observed vs data, but not always. 

Possibly, of course, that there is a need to deal with the objects. 
Then a chance to consider programs by the same way as data still 
exists. 

One of the most important issues in combinatory logic is to deter- 
mine how to derive from the available objects an object with the given 
properties by applying the known combining modes. At a starting 
stage only three objects-combinators are available: /, K, S, along 
with their properties given by their characteristic equalities. For rea- 
sons of intuitive clarity, assume that there is a programming system 
with these three instructions, using only which a rather rich in ex- 
pressive power programming system will be constructed. A resulting 
system will contain only the objects-combinators. 

45 



46 Chapter 2; Derivation OF Object 

2.1 Principle of combinatory completeness 

2.1.1 Combinatory characteristic 

As known, the system of combinators /, K, S allows to construe 
such a programming system, or, in other words, it has a property of 
combinatory completeness. 

Definition 2.1 (combinatory completeness). Theset of combina- 
tors Xi, ..., Xm, which is determined by the proper conversions, 
is assumed combinatory, or functionally complete, if for any ob- 
ject X, combined from distinct variables xi, . . ., x„, there is such a 
combinator U , expressible in terms of Xi, . . ., X^, and such, that 

Uxi...Xn = X. (U) 

The property ([/) can be considered as a characteristic rule for 
conversion of combinator U , or combinatory characteristic of U . 

Thus, the system /, K, S gives a guarantee of possibility to con- 
strue such an object U , i.e. it is possible to construe, or 

derive a "program", or "procedure" U , which, when it is called 
on the actual parameters xi, . . . , Xn, results m X — and this 
is a combination of variables xi, . . . ^x^. 

While dealing with an applicative computational system, note the 
conventions concerning the notations in use. Assume by agreement 
that 

U xiX2...Xn = {{...{{Uxi)x2) ...)a;„), 

n ones 

i.e. the omitted parentheses are to be restored by association to the 
left. 

Example 2.1. 

UxiX2X-i = {{{Uxi)x2)xs). 



Chapter 2; Derivation of Object 47 

2.1.2 Systems of concepts 

Untyped combinatory logic is a main mathematical mean to construe 
the calculi for objects, which are abstract in their nature. In fact, 
combinatory logic is a pure calculus of concepts, making it possible 
by need to generate or modify "on the fly" its own system of con- 
cepts. Studying the systems of "variable" concepts has a priority 
in all the valid applied areas including the development of object- 
oriented programming systems. In spite of visible simplicity, — in fact, 
combinatory logic could be used just after learning only the combi- 
nators K and S, — a deep understanding of all the possibilities within 
combinatory calculus needs a special computational experience. First 
of all this is caused by namely the applicative style of notations in use. 
However, this is not unexpected: a forty years practical experience 
with programming system Lisp had already prepared a ground for re- 
thinking of "minimal theoretical knowledge of programmer" which 
contains combinatory logic as well as A-calculus and some other top- 
ics from logic, traditionally mentioned as non-classic logics. 

2.1.3 Combinatory completeness 

Combinatory logic is a branch of mathematical logic which stud- 
ies combinators and their properties. More details can be found in 
the book (H. Curry, [6]). Combinators and the similar operators can 
be defined in terms of A-conversion, and that is why the diversity of 
calculi of A-conversion is assumed as a part of combinatory logic. 

Principle of combinatory completeness 

The calculi of A-conversion and systems of combinatory logic are 
combinatory complete theories. 

Definition 2.2 (combinatory completeness). Combinatory com- 
pleteness in the calculi of A-conversion is determined by the axiom 



48 Chapter 2; Derivation OF Object 

scheme (/?): 

{Xx.a)b = [b/x]a, (/?) 

where A is an abstraction operator, expression '[b/x]a denotes a re- 
sult of substituting object b for each free occurrence of variable x in 
object a, and '=' is a symbol of relation of conversion. 

Given an arbitrary object a in the systems of combinatory logic, a 
new object can be constructed 

U = [xi,...,Xn]a, 

via K, S, I, where [xi,. . . ,Xn\ for n > has a role of abstraction 
operator by the variables xi, . . . , x^- The principle of combinatory 
completeness: 

Ubi...bn = {[xi,...,Xri]a)bi...bn 
= [bi,...,bn/xi,...,Xn]a, 

can be proved for abstraction operator, where the expression '[6i, . . . , 
bn/xi, ..., Xr,\a denotes a result of simultaneous substituting the 
objects 6i, . . . , 6„ in the object a instead of the corresponding occur- 
rences of graphically distinct variables xi, . . ., Xn for n > 0. 
An intuitive interpretation is as follows: 

"procedure" U with a formal, ov substitutional parameters 

X\ , . . . , X^i 
is called with the actual parameters 6i, . . . , 6„, resulting in 

[6i,...,6„/a;i,...,a;„]a. 



Chapter 2; Derivation of Object 49 

2.1.4 Elementary combinatory logic 

Systems of combinators serve the same functions that the systems of 
A-conversion, but without using the bound variables. Thus, the tech- 
nical difficulties caused by a substitution and congruence, disappear. 

Introducing a concept by tbe combinator 

Combinators can be used to determine a concept which corresponds 
to some law. In other words. This law is comprehended to a concept 
— this is one of the most important virtues of combinatory logic as a 
metatheory. 

Consider a commutativity law in arithmetics: 

Va;, y.x + y = y + x. 

This law can be rewritten without any usage of bound variables x and 
y by defining 

\tx,y.A{x,y) = x + y 

and introducing metaoperator C: 

V/,a;,y.(C(/))(a;,y) = f{y,x). 
This law is written as follows: 

CA = A. 

Metaoperator C can be called as a 'combinator' which repre- 
sents a commutativity law for the operation A. 

In below, instead of indicating these metaoperators in bold face, the 
italics is used. 

Exercise 2.1. Write, without using the variables, a commutativity 
law for multiplication. 



50 Chapter 2; Derivation OF Object 

Simplest combinators 

To begin with, list the combinators which are most usable in practice. 

Identity. A simplest combinator is the identity combinator /: 

// = /• 

Compositor. Elementary compos/tor : 

Bfgx = f{gx) 
determines a composition of the functions / and g. 

Duplicator. Elementary duplicator W: 

Wfx = fxx 
duplicates the second argument. 

Permutator. The combinator , mentioned earlier, is called elemen- 
tary permu/ator and is re-written as C: 

Cfxy = fyx. 

Connector. Elementary connector S is defined by the rule: 

Sfgx = fx{gx). 

Cancellator. Elementary cancellator 

Kcx = c 
determines the constant (constant function) as a function of x. 



Chapter 2; Derivation of Object 51 

Example 2.2. Let / = sin be the function 'sine', g = exp^ be the 
function of fifth power. Then Bfg is the sine of x to the fifth power: 

Bfgx = B sin exp^ x = sin{exp^ x) = sin x^, 

Bgf is the fifth power of sine, 

Bgfx = B exp^ sin x = exp^{sin x) = sin^x. 

Example 2.3. If Q is the second power operation, then BQQ or 
WBQ is the fourth power operation: 

WBQ x = BQQ x = Q{Q x) = x^. 

Example 2.4. From the equation (conversion): 

B{Bf)gxy = Bf{gx)y = f{gxy), 

it follows, that if / is a differentiation operator D, then B{Bf) is that 
for the function of two arguments: 

B{BD)gxy = BD{gx)y = D {gxy). 

2.2 Deriving main combinators: tasks 

Let now to acquire the technical experience of establishing (and case 
studies) of a newly generated concept. Select the practically used 
combinators as those concepts. The general problem is to establish 
the concept/combinator by the specified combinatory characteris- 
tics (see p. 46). 

Task 2.1. Specify the combinatori? . 

Task formulation. Specify the object with the given combinatory 
characteristics by K and S: 

Babe = a{bc), (B) 

using the postulates a, (3, ^i, v, a, r, ^ from the calculus of A- 
conversions. 



52 Chapter 2; Derivation OF Object 

Solution. 

B—\. Give the formulation of the postulates for relation '=': 
{a) Xx.a = Xz.[z/x]a; (/3) {Xx.a)b = [b/x]a; 

a=b a=b 



ac= be ca = cb^ 

a = b a = b; b = c a = b 

Xx.a = Xx.b^ a = c ' b = a 

B—2. Establish the combinatory characteristics of the objects 
K and S: 

x{Kyz) = xy, (K) 

x{Syzw) = x{yw{zw)), (S) 

which within the A-calculus are expressed by: K = Xxy.x and 
S = Xxyz.xz{yz). 

Indeed, by postulate (/?): 

x(Kyz) = x{{Xxy.x) yz) = xy, 

=K 

x{Syzw) = x{{Xxyz.xz{yz)) yzw) = x{yw{zw)), 



B—3. The schemes (K) and (S) result in: 

a{bc) = Kac{bc) {K) 

= S{Ka)bc Is) 

= KSa{Ka)bc (K) 

= S{KS)Kabc. {S) 

Checking. A verification that B = S{KS)K is given below. 



Chapter 2; Derivation of Object 53 

B- 1 . S{KS)Kabc = KSa{Ka)bc, because in the scheme (S) 
it can be assumed that y = (KS), z = K,w = a. Then: 

Syzw = S{KS)Ka, yw{zw) = {KS)a{Ka), 

i.e. S{KS)Ka = {KS)a{Ka). Omitting the non-significant 
parentheses resuhs in S{KS)Ka = KSa{Ka). Twice applying 
of postulate {v) to this expression, results in: S{KS)Kabc = 
KSa{Ka)bc. 

B—2. The same reasons by scheme {K) give KSa = S. Tak- 
ing into account postulate (j/), obtain KSa{Ka)bc = S{Ka)bc. 

B—3. The same way successive applying of schemes (S) and 
(K), and postulate (u) and omitting the nonsignificant paren- 
theses leads to the equations: 

S{Ka)bc = Kac{bc)\ (K ac)bc = a{bc) . 

B—A. Repeatedly using the transitivity (r), obtain 
S{KS)Kabc = a{bc). (This equation is valid for if S{KS)Kabc 
= KSa{Ka)bc and KSa{Ka)bc = S{Ka)bc, then S{KS)Kabc 
= S{Ka)bc etc.) 

Answer. The object B with a combinatory characteristic Babe = 
a{bc) is S{KS)K, i.e. B = S{KS)K. 

Task 2.2. Specify an expression for combinator C . 

Task formulation. Using K, S and other predefined objects derive 
the object with combinatory characteristic: 

Cabc = acb, (C) 

by postulates a, /?, fi, v, a, r, ^ of A-calculus. 
Solution. 



54 Chapter 2; Derivation OF Object 

C— 1. List the postulates which determine a conversion rela- 
tion '=' (see task given above). 

C— 2. Recall the combinatory characteristics of the objects in 
use: 



(K) 


Kxy = 


= X, 


(S) 


Sxyz = 


-- xz{yz), 


(I) 


Ix = 


= a;, 


(B) 


Bxyz = 


= x{yz). 



Note that the scheme {B), derived in task 2.1 on p. 51 is added 
to already known schemes {K), (S) (/). As was shown, this 
newly derived scheme can be expressed in terms of schemes 
{K)and{S). 

C— 3. Applying these schemes to (ac5), obtain: 

acb = ac{Kbc) (by scheme (K)) 

= Sa{Kb)c (by schemers')) 

= B{Sa)Kbc (by scheme (5)) 

= BBSaKbc (by scheme (5)) 

= BBSa{KKa)bc (by scheme (K)) 

= S{BBS){KK)abc. (by scheme (S)) 

Using transitivity postulate (r), obtain: 

S{BBS){KK)abc= acb, 

i.e.C = S{BBS){KK). 

Answer. The object with a combinatory characteristic Ca6c = ac6 is 
C = SiBBS)iKK). 

Task 2.3. Derive combinator M^. 

Task formulation. Derive combinator W with the following charac- 
teristic: 

Wab = abb. (W) 



Chapter 2; Derivation of Object 55 

Solution. 

W—\. Write down the characteristics of objects in use as fol- 
lows: 

{S) Sxyz = xz{yz), (/) Ix = x, (C) Cxyz = xzy. 
W—2. Apply these schemes to abh: 



abb = 


= ab{Ib) 


(by(/)) 


= 


= Salb 


(by(S)) 


= 


= CSIab. 


{^y{c)) 



Using the postulates, obtain: CSIab = abb. Thus, W = CSI. 

W—3. The additional two variants of derivations for W are as 
follows: 

abb = ab{Kba) abb = ab{Kb{Kb)) 

= ab{CKab) = ab{SKKb) 

Sa{CKa)b = Sa{SKK)b 

= SS{CK)ab = Sa{K{SKK)a)b 

= SS{K{SKK))ab. 

Answer. The object W with a characteristic Wab = abb is as follows: 
W = CSI ( = SSiCK) = SS{K{SKK)) ). 

Task 2.4. Derive the expression for combinator $. 

Task formulation. Derive combinator $ with the following charac- 
teristic: 

^ abed = a{bc){bd) . ($) 

Solution. 

$— 1 . List the postulates for conversion relation. 



56 Chapter 2; Derivation OF Object 

$—2. Recall the combinatory characteristics of the objects in 
use: 

(C) Cxyz = xzy, (W) Wxy = xyy, (B) Bxyz = x{yz). 

$—3. Applying these schemes to a{bc){bd), obtain: 

a{bc){bd) = B{a{bc))bd (B) 

= BBa{bc)bd (B) 

= B{BBa)bcbd (B) 

= BB{BB)abcbd (B) 

= C{BB{BB)ab)bcd (C) 

= BC{BB{BB)a)bbcd (B) 

= W{BC{BB{BB)a))bcd {W) 

= BW{BC){BB{BB)a)bcd (B) 

= B{BW{BC)){BB{BB))abcd. (B) 

Using the needed postulates, conclude that: 
B{BW{BC)){BB{BB))abcd = a{bc){bd), i.e. 
* = B{BW{BC)){BB{BB)). 

Answer. The object \1/ with the combinatory characteristic ^abcd = 
a{bc){bd) is * = B{BW{BC)){BB{BB)). 

Task 2.5. Derive the expression for combinator B^. 

Task formulation. Derive via K and S and other predefined objects 
the object with the following combinatory characteristic: 

B^abcd= a{bcd). (5^) 

Solution. 

B^—l. List the postulates for relation of conversion. 

B^—2. Recall a combinatory characteristic of the object in use: 
{B) Bxyz = x{yz). 



Chapter 2; Derivation of Object 57 

B^—3. Applying this scheme to a{bcd), obtain: 

a{bcd) = Ba{hc)d (by scheme (i?)) 

= B{Ba)hcd (by scheme (B)) 

= BBBabcd. (by scheme (B)) 

Using the postulates, obtain: BBBabcd = a{bcd), i.e. B^ = BBB. 

Answer. The object B^ with a combinatory characteristic B^abcd = 
a{bcd) is B"^ = BBB. 

Task 2.6. Specify the expression for combinator B^ . 

Task formulation. Derive via K and S and other predefined objects 
an object with combinatory characteristic: 

B^ abode = a{bcde). (B^) 

Solution. 

B^—l. Use the postulates which determine a relation of con- 
version. 

B^—2. Combinatory characteristics of the objects in use are 
the following: (B) Bxyz = x{yz), (i?^) B^xyzw = x{yzw). 

B^—3. Using these schemes to a{bcde), obtain: 

a(bcde) = B'^a(bc)de (by scheme (i?^)) 

= B{B'^a)bcde (by scheme (B)) 

= BBB^abcde. (by scheme (B)) 

Using the postulates, obtain: BBB^abcde = a{bcde), i.e. 
B^ = BBB'^. 

Answer. The object B^ with a combinatory characteristic B^ abode = 
a{bode) is B^ = BBB'^. 



58 Chapter 2; Derivation OF Object 

Task 2.7. Specify the expression for combinator C^^l . 

Task formulation. Derive via K and S and other predefined objects 
the object with a combinatory characteristic: 

d'^^abcd= acdb. (C^]) 

Solution. 

Cl^l — 1 . Use the postulates, which determine a relation of con- 
version. 

C'^l— 2. Recall the combinatory characteristics of the objects 
in use: 

(B) Bxyz = x{yz), (C) Cxyz = xzy. 

Cl^l— 3. Using these schemes with acd6, obtain: 

acdb = C{ac)bd (by scheme (C)) 

= BCacbd (by scheme (B)) 

= C{BCa)bcd (by scheme (C)) 

= BC{BC)acbd. (by scheme (5)) 

From the postulates, conclude: BC{BC)acbd = acbd, i.e C'^l = 
BC{BC). 

Answer. The object C'^' with given combinatory characteristic 
C^'^^abcd = acbd is Cl^l = BC{BC). 

Task 2.8. Specify an expression for combinator Cpj . 

Task formulation. Derive, using K and S and other predefined ob- 
jects an object with combinatory characteristic: 

Cmabcd = adbc. (C'pl) 



Chapter 2; Derivation of Object 59 

Solution. 

C[2] — 1. Use the needed postulates. 

C[2]— 2. Write down the combinatory characteristics of the ob- 
jects in use: 

{B ) B xyzw = x{yzw), (C) Cxyz = xzy. 

C[2]— 3. Using these schemes with adbc, obtain: 

adbc = Cabdc (by scheme (C)) 

= C'{Cab)cd (by scheme (C)) 

= B'^CCabcd. (by scheme (5^)) 

From the postulates, obtain: B^CCabcd = adbc, i.e. Cpj = B^CC . 

Answer. The object Cpj with given combinatory characteristic 
Cy2\abcd = adbc is Cp] = B'^CC . 

Task 2.9. Derive an expression for combinator C^^] . 

Task formulation. Derive using K and S and other predefined ob- 
jects an object with combinatory characteristic: 

C^^^abcde = acdeb. (C^l) 

Solution. 

C'^l — 1 . Select out the needed postulates. 

Cl^l— 2. Write down the combinatory characteristics of objects 
in use: 

(C) Cxyz = xzy, (B) Bxyz = x{yz), 

(Ct^l) Cxyzw = xzwy. 



60 Chapter 2; Derivation OF Object 



C^l— 3. Using these schemes to acdeb, obtain: 

acdeb = C^'^\ac)bde (by scheme (C^l)) 

= BC^^^acbde (by scheme (B)) 

= C{BC^^^a)bcde (by scheme (C)) 

= BC{BC^^^)abcde. (by scheme (B)) 

From the postulates, obtain: BC{BC^^^)abcde = acdeb, i.e. C^^l = 
BC{BC^^^). 

Answer. The object C^'^l with a combinatory characteristic C^^^abcde 
= acde6isCP] = BC{BC^^^). 

Task 2.10. Specify an expression for combinator Cp] . 

Task formulation. Derive via K and S and other predefined objects 
an object with combinatory characteristic: 

Cmabcde = aebcd. (C'pi) 

Solution. 

C[3] — 1. Select out the postulates. 

Cpi— 2. Write the combinatory characteristics of objects in 
use: 

(i?^) B'^xyzw = x{yzw), (C) Cxyz = xzy, 

(C[2]) C[2]xyzw = xwyz. 

Using these schemes with aebcd, obtain: 

aebcd = Cabecd (by scheme (C)) 

= C[2](Ca6)cde (by scheme (Cpj)) 

= B^C[2]Cabcde. (by scheme (B^)) 

From the postulates, obtain: B'^Cy2\Cabcde = aebcd, i.e. Cp] = 
B C[2]C. 



Chapter 2; Derivation of Object 61 

Answer. The object Cp] with a combinatory characteristic C^^j'^bcde 
= aebcd is Cp] = B^C[2]C. 

Task 2.1 1 . Specify an expression for combinator <|). 

Task formulation. Derive using K and S and other predefined ob- 
jects an object with combinatory characteristic: 

^abcd = a{bd){cd). (<|)) 

Solution. 

$— 1 . Use the postulates for a relation of conversion. 

$—2. The combinatory characteristics of the objects in use are 
as follows: 

(B^) B'^xyzw = x{yzw), (B) Bxyz = x{yz), 

(S) Sxyz = xz{yz). 

$—3. Using these schemes with a(6d)(cd), obtain: 

a{bd){cd) = Babd{cd) (by scheme (i?)) 

= S{Bab)cd (by scheme (S)) 

= B^SBabcd. (by scheme (5^)) 

From the postulates, obtain: B'^SBabcd = a{bd){cd), i.e. <|) = 
B'^SB. 

Answer. The object <|) with a combinatory characteristic ^abcd = 
a(6d)(cd)is$ = B^SB. 

Task 2.12. Specify an expression for combinator y. 

Task formulation. Derive using K and 5* and other predefined ob- 
jects an object with combinatory characteristic: 

Ya=a{Ya). (Y) 



62 



Chapter 2; Derivation of Object 



Solution. 

Y—l. Use the postulates for a relation of conversion. 

Y—2. Write down the combinatory characteristics of the ob- 
jects in use: 

(S) Sxyz = xz{yz), (W) Wxy = xyy, (B) Bxyz = x{yz). 

Y-3. ProvaAhatY = WSiBWB). 
Ya = WS{BWB)a 



= S{BWB){BWB) a 

= BWBa{BWBa) 

= W{Ba){BWBa) 

= Ba{BWBa){BWBa) 

= a{BWBa{BWBa)) 

= al s{BWB){BWB) a) 

= a{ WS{BWB) a) 

= a{Ya). 



(by assumption) 
(by scheme {W)) 
(by scheme {S)) 
(by scheme {B)) 
(by scheme {W)) 
(by scheme {B)) 
(by scheme {S)) 
(by scheme {W)) 
(by assumption) 



Hence, one of the representations of object Y is as follows: Y 
WS{BWB). 

Answer. The object Y with a combinatory characteristic Ya 
a{Ya)\sY = WS{BWB). 



2.3 Historical remark 

Purely chronologically, combinatory logic as a mathematical mean 
was introduced by Moses Shonfinkel in 1920. His paper was pub- 
lished in 1924 with a title "On building blocks of mathematical logic". 
In those years an idea to reduce logic to simplest possible basis of 
primitives was attractive, however, in our days this seems not so im- 
portant. It has been shown in this paper that the logic can be avoided 



Chapter 2; Derivation of Object 63 

of the usage of bound variables. The higher order functions made it 
possible to reduce logic to a language with a single constructor — 
applying function to argument, — and three primitive constants — 
U, C (which in our days is denoted as K) and S. Function is called 
'higher order function', if its argument can in turn be a function, or 
results in a function. All these three constants are the higher order 
functions. The formal definitions are as follows. 
Constant C, defined by 

Cxy = {C{x)){y) = X, 

is a constant function, which for any x returns x. 
Constant S, defined by 

Sfgx={{S{f)){g)){x) = {f{x)){g{x)), 

is a combination of two functions / and g. For x it results in a value, which 
is obtained as an application of function / of argument x to function g of 
argument x. 

Constant U, defined by 

UPQ = {U{P)){Q) = Vx.-(P(x) A Q{x)), 

is a generalization of Stieffer's operation. This operation is applied to two 
predicates, and results in a universal generalization of negated conjunction 
of these two predicates. 

Note. These combinators are sufficient to express the arbitrary first order 
predicates without bound variables, which are used in first order logic with 
quantification. The same result can be achieved, when the algorithm of 
translation the A-expressions to combinators is used. In this case the rest- 
rictions for the first order of the predicates in use is eliminated. However, 
an unlimited using of this translation for the typed objects can violate a 
consistency. Combinatory logic tends to get rid of the typed system and 
the associated restrictions to overcome the strict requirements to preserve 
consistency. 

The paper by M. Shonfinkel is an introduction to combinatory 
logic, which gives a clear vision, what are the initial motivations for 
its advances. 



64 



Chapter 2; Derivation of Object 



Chapter 3 

Fixed Point 



Conceptual transparency of combinatory logic makes it rather easy to 
learn of. After the first advances it may seems, that objects in use are 
always simple and finite in there nature. But this is just imaginable, 
and combinators can be used to represent processes, and, among 
them, the computations with cycles, which represent the known in 
programming manipulation with stack of recursion. 

These cyclic computations are the mappings, which contain a 
fixed point. 

3.1 Theoretical background. 

Computations with a fixed point are the representations of the cycles 
in programs. One of the main results of A-calculus is the Theo- 
rem 3. 1 , concerning a fixed point. 

Theorem 3.1 . For any object F there is the object X such, that X = 
FX: 

yF3X {X = FX). 

Proof. See ['>], p. 140. Let P = Xx.F{xx) and X = PP. Then 
X = {Xx.F{xx))P = F{PP) = FX, 

65 



66 Chapter 3; Fixed Point 



and this turns X into a fixed point of F . D 

The feature of this proof is in starting from term X and convert- 
ing it to F X, but not vice versa. Combinatory logic gives a special 
concept-combinator Y , called as fixed point combinator, a mathe- 
matical meaning of which is a cycle in computations — given a map 
F, it returns its fixed point {Y F). 

3.1.1 Abstraction 

For any term M and variable x the term [x\M, called the abstraction 
M of X, is defined by' induction on constructing the term M: 

(i) [x]x = I; 

(ii) [x]M = KM, if a; does not belong to M; 

(iii) [a;][/a; = U ,\[x does not belongto U; 

(iv) [x]{UV) = S{[x]U){[x\V), if neither (ii), nor (iii) are valid. 

Example 3.1. [x]xy = S{[x]x){[x]y) = SI{[x]y) = SI{Ky). 

Theorem 3.2 (comprehension principle). For any objects M, N 
and variable x an application of abstraction ([a;]M) to object A^ is 
comprehended by a principle: 'substitute A^ for each free occurrence 
of a; in M': 

VM, N,x: {[x]M)N = [N/x]M. 

Proof. See in [co]. D 

3.1.2 Muitiabstraction 

For any variables xi, . . . ,2;^ (not obviously distinct) define: 

[xi, . . .,x^]M = [xi]([2;2](. . . (MM) . . .)). 
Example3.2. [x,y]x = [x]{[y]x) = [x]{Kx) = K. 



The term '[x]M', or '[x].M' for our purposes can, for a while, be considered 
similar to the term 'Ax.M'. 



Chapter 3; Fixed Point 67 

3.1.3 Local recursion 

An important application of a fixed point combinator is given by the 
programs with recursive definitions. Consider a local recursion with 
the elementary means. A local recursion of 

El where x = . . . x . . . 

transforms into 

i[x]El)iYi[x]i...x...))), 

where F is a fixed point combinator, which is defined by the equation: 

Yf = f{Yf). 

For function / the expression y / is a fixed point of /. 

When a mutual recursion is used with tr/iere-clauses in the text 
of program 

El where f x = ... g ... 
g y = • • • i ■■■ 

then it is, first of all, transformed into the expression: 

El where f = [x] ( . . . g . . . ) 
g = [y] (... f ...), 

where all free occurrences of variables x and y are omitted. After that 
these two recursive definitions are transformed into general recursive 
definition: 

El where (f,g) = ( [x] ( . . . g ...), [y] ( . . . f ...) ), 

which can be compiled into expression: 

([f,g]El) (Y ([f,g]([x](... g ...), [y](... f ...)) )) 

using already known rule. 



68 Chapter 3; Fixed Point 

3.2 Main tasks 

Task 3.1. Learn of properties of the object 

Y = {\x.{P{xx)a)){\x.{P{xx)a)). 

Task formulation. Find out a combinatory characteristic of the ob- 
ject, using postulates a, /?, fi, v, a, r, £, of calculus of A-conversions 
and schemes {K), (S): 

Y = {Xx.{P{xx)a)){Xx.{P{xx)a)). (Y) 
Solution. 

Y— 1. The expression for object Y is already known: 

Y = {Xx.{P{xx)a)){Xx.{P{xx)a)). 

Y— 2. Using rule of substitution (/3) for its representation gives 
the following: 

Y = {Xx.{P{xx)a)){Xx.{P{xx)a)) 

= {P{{Xx.{P{xx)a)){Xx.{P{xx)a)))a (/?) 

= P{Y)a. 

Thus, Y = PYa = P{PYa)a = .... 

Answer. Combinatory characteristic of the initial object 
Y = {Xx.{P{xx)a)){Xx.{P{xx)a)) is: Y = PYa. 

Task 3.2. Learn of properties of the object: 

Y = S{BWB){BWB). 

Task formulation. Find out a combinatory characteristic of the ob- 
ject, using postulates a, /?, /x, ly, a, r, £, of calculus of A-conversions 
and schemes {K), (S): 

Y = S{BWB){BWB). (Y) 



Chapter 3; Fixed Point 69 

Solution. 

Y- 1 . The object Y is determined hy: Y = S{BWB) (BWB) . 

Y— 2. Write down combinatory characteristics of the following 
objects: Babe = abc, Sabc = ac{bc), Wab = abb. 

Y— 3. Make an application of object Y to a: 
Ya = S{BWB){BWB)a (byDf.) 

^ V ' 

=Y 

= BWBa{BWBa) (by scheme 5") 

= W{Ba){BWBa) (by schemed) 

= Ba{BWBa){BWBa) (by scheme VF) 

= a{BWBa{BWBa)) (by schemed) 

= a{S{BW B){BW B) a) (by scheme S*) 

s. ^ 

=Y 

= a{Ya). (byDf.) 

Thus, Ya is a fixed point for a. 

Answer. Combinatory characteristic of the initial object 
Y = S{BWB){BWB) is: Ya = a{Ya). 

Task 3.3. Learn of properties of the object: 

Y = WS{BWB). 

Task formulation. Find out a combinatory characteristic of the ob- 
ject, using postulates a, /?, /x, v, a, r, £, of calculus of A-conversions 
and schemes {K), (S): 

Y = WS{BWB). (Y) 
Solution. 

Y-1. The object Y is determined by: Y = WS{BWB). 



70 Chapter 3; Fixed Point 

Y— 2. Write down combinatory characteristics of the following 
objects: 

Babe = abc, Sabc = ac{bc), Wab = abb. 

Y— 3. By scheme (M^), we obtain: 

Y = WS{BWB) = S{BWB){BWB). 

Thus, object Y has the same combinatory characteristic as the 
object Y from the previous task. 

Y— 4. Make an application of object Y to a: 

Ya = S{BWB){BWB)a (byDf.) 

= BWBa{BWBa) (by schemed) 

= W{Ba){BWBa) (by schemed) 

= Ba{BWBa){BWBa) (by scheme VF) 

= a{BWBa{BWBa)) (by scheme 5) 

= a{S{BWB){BWB)a) (by schemes') 

= alYa) (by Df.). 

Y— 5. Finally, we obtain Ya = a{Ya). 

Answer. Combinatory characteristic of the object Y = S{BWB) is: 
Ya = a{Ya). 

Task 3.4. Learn of properties of the object: 

Yo = \f.XX, where X = Xx.f{xx). (Yo) 

Task formulation. Find out a combinatory characteristic of the ob- 
ject, using postulates a, /?, fi, v, a, r, £, of calculus of A-conversions 
and schemes {K), (S): 

Yo = \f.XX, where X = Xx.f{xx). 



Chapter 3; Fixed Point 71 



Solution. 

Yq—\. The object Yq is as follows: Yq = Xf.XX, where X = 
Xx.f{xx). 

Yo-2. At first, consider the object (XX). 

XX = {Xx.f{xx))(Xx.f(xx)) (byDf.) 

= f{{Xx.f{xx)){Xx.f{xx))) (by/3) 
= f{XX). (byDf.) 

Hence, 

XX = f{XX). (*) 

lo~3. Now the object Yq is applied to any object a: 

Yoa = {Xf.XX)a (byDf.) 

= {Xf.f{XX))a (by(*)) 

= iXf.fiiXx.fixx))iXx.fixxma (byDf.X) 

= a{{Xx.a{xx)){Xx.a{xx))) (by/?) 

= a{{Xf.{{Xf.f{xx)){Xx.f{xx))))a) (by/3,0 

= a((A/.(XX))a) (byDf.X) 

= aiYoa). (byDf. Fo) 

Using transitivity T, we obtain: Yoa = a(Yoa). 

Answer. Combinatory characteristic of object Yq is as follows: Y^a = 
a (Yoa). 

Task 3.5. Learn of properties of the object: 

Fi = Yo{Xy.Xf.f{yf)), where Fq = Xf-XX, X = Xx.f{xx). 

Task formulation. Find out a combinatory characteristic of the ob- 
ject, using postulates a, (3, fi, v, a, r, £, of calculus of A-conversions 
and schemes {K), (5): 

Fi = Yo{Xy.Xf.f{yf)), where Fq = A/.XX, X = Xx.f{xx). (Y^) 



72 Chapter 3; Fixed Point 

Solution. 

Yi-1. The object Yi is as follows: Yi = Yo{\y.\f.f{yf)), 
where the equalities Yq = Xf.XX, and X = Xx.f{xx) are valid. 

Yi— 2. Hence, Yoa = a(Yoa), 

Y,a = Yo{Xy.Xf.f{yf))a (byDf.) 

= {Xy.Xf.f{yf)){Yo{Xy.Xf.f{yma {hy (Yo)) 

= (Xyf.fiyfW.a (by(ri)) 

= a{Yia). (by/3) 

Thus, the equality Yia = a(Yia) is derived. 

Answer. Combinatory characteristic of object Yi is as follows: Yia = 
a(Yia). 

Task 3.6. Use function Y for representing a circular list L. 

Task formulation. Circular list L, which is defined by 

L= (1 :2 : 3:L), 

results in an infinite periodic list 

Find out a finite representation for this data structure, which does not 
use the self referenced definitions. 

Solution. This circular construction gives L as a list, where the first 
element is 1 , second element is 2, third element is 3, fourth element is 
1 and so on. 

L— 1 . Consider a chain of transformations: 

L = (1 : 2 : 3 : L) 

= (AL.(1 : 2 : 3 : L))L. by(/3) 



Chapter 3; Fixed Point 73 

L-2. Whenever L ^ (AL.(1 : 2 : 3 : L)), then, by fixed point 
theorem, 

L = Y{\L.{1 :2 : 3: L)). 
Answer. L = Y{\L.{1 : 2 : 3 : L)). 

Exercises 

Exercise 3.1 . Consider a circular definition 

s(ii,k) = 

if k = 1 

then 1 

else if k = n 

then 1 

else s(n - 1, k - 1) + k * s (n - 1, k) 

of Stirling numbers of the second kind. Find out a finite representa- 
tion for this function, which does not contain self referenced defini- 
tions. 

Hint. As, for instance, we have 

s(4,2) = s(3,l) + 2 * s(3,2) 

= 1 + 2 * (s(2,l) + 2 * s(2,2)) 
=1+2* (1+2*1) =7, 

then we deal with recursive computations. Try to determine the A- 
abstraction of n and k, and, after that, to use a fixed point theorem. 

Exercise 3.2. Avoid the cycles in the following definitions: 



74 Chapter 3; Fixed Point 

length X = 

if null X 

then 

else 1 + length (tail x) 

factorial n = 

if zero n 

then 1 

else n X factorial (n - 1) 

Hint. A circular definition can be transformed into a standard form, 
where a left part is the identifier, and a right part is the expression. 
This can be done by self referenced function, which involves the fixed 
point function Y . Characteristic property of this function is as follows: 
Yf = f{Yf). 

Self referencing definition of the function is determined by the 
equality / = Ef, where expression E does not contain free occur- 
rences of /. One of the solutions for this equation is / = YE. 



Chapter 4 

Extensionality 



Combinatory logic has a specific feature that allows to construe and 
use the functions with a priori not fixed number of arguments. This 
means that the answering for a question, how many argument places 
has the function-object in actual use, needs some care. Nevertheless, 
a careful using of rather simple principles of extensionality enables 
overcoming of this uncertainty. 



4.1 Theoretical background 

The model M, as a rule, needs in validation of some property. In par- 
ticular, let object F be built from, at most, free variables xq, . . . , Xn-i 
using the modes of combining. Besides namely these free variables 
F does not contain any other free variables. Then combinatory com- 
pleteness of model M is understood as existing in it of such an object 
(concept) /, that for any variables xq, . . . ,Xn-i the following equality 
is valid: 

fxo...Xn-l = F. 

In other words, a self standing concept / does explicitly exist — as an 
object in the model, — having the same meaning as _F-combination 

75 



76 Chapter 4: Extensionality 

of other objects (with a restriction on the usage of free variables). 

The models, in which the equality of functions / and g, evaluated 
with an arbitrary argument d, implies an equality of these functions 
as the objects, are practically often used: 

W£D.{fd=gd) 

, {ext) 

f = 9 

where, by agreement, assume, that fd = (fd) and gd = (gd). This 
kind of models is called the extensional models (ext). 

In case of applicative structures, a stronger version of combina- 
tory completeness is valid: there is such a concept f that for any 
free in F variables xq, . . . , x^-i: 

fXQ... Xn-l = F{xo, ..., Xn-l), 

or, formally: 

I/.Va;o...Va;„_i(/a;o ...Xn-i = F{xo, . . . ,Xn-i)). 

In this statement a symbol of the description 'I' is used as an ab- 
breviation for 'such ... , that ...'. This, in fact, is a principle of 
comprehension: 

combination of objects F, among which as the free variables 
the only xq, . . . , Xn-i are used, is comprehended to a single 
object (concept) / with those and only properties, that are 
attributive to the combination F{xo, ■ ■ . , Xn-i)- 

This is true only for extensional applicative structures and allows to 
transform the complicated expression into a single object, decreasing 
the complexity of reasoning. 
The postulate 

Xx.Xx = X, X ^ X, [t]) 

plays an important role and, as will be shown, is similar to extension- 
ality in applicative structure. 



Chapter 4; Extensionality 77 

4.2 Tasks 

Task 4.1. Prove the equality: 

Xxy.xy = Xx.x. 
Task formulation. Prove, that equality: 

Xxy.xy = Xx.x (1) 

is derivable in ry^-calculus of A-conversion (the symbol '=' represents 
a relation of conversion). 

Proof. 

rj—l. The following postulates are used: 

(r/) Xx.Xx = X, X <^X, (0 

(r) 



Xx.a = Xx.b 
a = b, b = c 



a = c 
Here: 'x ^ X' is the same as 'x has no free occurrences in X'. 

rj—2. Using the postulates, we obtain: 

(1) Xxy.xy = Xx.{Xy.xy), (by definition) 

(2) Xy.xy = x, (by scheme (ry)) 

(3) Xx.{Xy.xy) = Xx.x, ((2), (O) 

(4) Xxy.xy = Xx.x. ((1), (3); (r)) 

Thus, in r/^-system the equality Xxy.xy = Xx.x is derivable. D 

An abbreviated form of this proof could be given as a tree-like deriva- 
tion, which is growing in the direction 'from-top-to-bottom'. Its 



78 Chapter 4: Extensionality 

premises are written above the horizontal line, and conclusions — 
below. The line is understood as a replacement of the word 'therefore': 

\y.xy X 

— iv) 



Xy.xy = X 
Xxy.xy = Xx.x 

Task 4.2. Using A-notations ([ ]-notations), define a construction: 

f(x) + f(f(7)) where f (x) = sqr(x) + 3 

Task formulation. This task assumes that the constructions 

M where f (x) = N or let f (x) = N M, 

will be used, whose particular cases 

M where x = N or let x = N M, 

could be represented by the A-term: 

{Xx.M)N. 

Solution. Construction where corresponds to a programming 'from- 
top-to-bottom', when, at first, it is supposed that the objects exist, 
and after that they are defined. Construction let corresponds to a 
programming 'from-bottom-to-top', when the objects are defined be- 
fore they are used. 

rj— 1 . Each of these expressions consists of two parts: 

1 ) expression M, called main expression, or body; 

2) definition of one of the forms: 

where f(x) = N or let (x) = N. 
ry— 2. In a general case, the expression 



Chapter 4; Extensionality 79 

M where f (x) = N 

can be transformed into expression witli operator/operand, us- 
ing two stages: 

1 ) at first, we establish the expression 

M where f = Ax.N; 

2) at second, we obtain the expression 

(Af.M) (Ax.N). 

77—3. Thus, for objects 

M = f(x) + f(f(7)), N = sqr(x) + 3 

we obtain, that 

(Af.f(x) + f(f(7))) (Ax.sqr(x) + 3). 

Answer. The initial construction of programming language can be 
represented by: 

(Af.f(x) + f(f(7))) (Ax.sqr(x) + 3), 

or, in other notations: 

([f].f(x) + f(f(7))) ([x].sqr(x) + 3). 

Exercises 

Exercise 4.1 . Learn of a solution for task 4.2 and find, where and in 
what context the postulate (r/) is used. 

Exercise 4.2. Re-formulate a self referenced definition 



80 Chapter 4: Extensionality 

length X = 

if null X 

then 

else 1 + length (tail x) 

to standard form, where the definable identifier in written in the left 
part, and the defining expression — in the right. 

Hint. A chain of transformations: 

length = [x] . if null x 
then 

else 1 + length (tail x) 
= ( [length] . [x] . if null x 
then 

else 1 + length (tail x)) length 
= Y ( [length] . [x] .if null x 
then 
else 1 + length (tail x) ) 

could be determined. Postulate (77) is used. Now the definition has a 
standard form, and its right part does not contain the definable iden- 
tifier length, because the variable length is bound. 



Chapter 5 

Numerals 



We pay your attention that from the very beginning combinatory 
logic does not contain . . . numbers — among the generic objects. This 
is so, because the notion of a number can be constructed using the 
known combinators. Then the numbers look like some unusual enti- 
ties — they are the objects with their arity depending on the involved 
postulates. Similarly, the arithmetic operations could be derived us- 
ing combinators. In other words, arithmetic entities are embedded 
into combinatory logic. This is the known ability of object-oriented 
programming — an application (the arithmetic objects with their as- 
sociated rules) is embedded into programming environment (combi- 
natory logic). 

5.1 Numbers and numerals 

As known, one of the generic concepts in mathematics is a notion of 
number. Using the numbers, an investigator can establish other ob- 
jects, that are more meaningful to represent the concepts in a problem 
domain. In the theoretical studies this is a "good manner" to reduce 
an applied theory to some predefined arithmetic system. 

A question is that is it so necessary to use as a generic concept 

81 



82 Chapter 5: Numerals 

the notion of a number. This is one of the most intriguing question in 
modern mathematics, the attempts to get an answer for which lead to 
the far growing research conclusions. 

Nevertheless, combinatory logic or A-calculus among the generic 
objects has no numbers. Is an expressive power of these systems 
rich enough? As known, combinatory logic or A-calculus allows the 
introducing of those combinators or, respectively, A-terms, whose 
behavior is similar to that of numbers. These representations of the 
numbers are called numerals. Numerals, as combinators, conform to 
all the laws of combinatory logic. Moreover, the combinators, which 
represent the arithmetic operations, for instance, addition, can be de- 
fined. The research in this area is yet far from final stage. 

5.2 Combinatory arithmetic 

The constructing of arithmetic usually starts with an introducing the 
natural numbers (see A. S. Kuzichev, [IH]). For this purpose in a com- 
binatory logic two objects are introduced and use the abstraction op- 
erator (see point 3.1.1 on page 66 and so forth): 

Zo = [xy]y d = [xyz\{y{xyz)). 

First of them is a representation of the number 0, and second — is a 
representation of operation of adding one '+1' and is called the suc- 
cessor combinator. 

Combinatory numbers, or numerals are generated step by step, 
by induction on constructing, or by structural induction: 

i) Zo is a combinatory number; 

ii) combinatory number Zk+i, as a representation of the natural 
number /c + 1, assumed to be equal to aZ^ for A: > 0. 

Statement 5. 1 . It can be shown that combinator Zn has a property: 

Zr^XY = X{X{...X{XY)...)), 



Chapter 5; Numerals 83 

where X and Y are the objects, and n > 0. 
Proof. By induction on n. 

i) Zo = [xy]y, and ZqXY = ^^Y; 



ii) Zi = aZo, and 

ZiXY = oZqXY 

= {[xyz]{y{xyz))){[xy]y)XY 
= X{{[xy]y)XY) 
= ^Y; 

1 

and so on. D 

For introducing other arithmetic objects the pairing combinator 
is needed 

V = [xyz\{z{Ky)x) 

with the following properties: 

1) VXYZo = X\ 

2) ^^^(CTt/) = y for objects X,y U. 

To construe more representative arithmetic, some other arith- 
metic objects are to be added. 

Predecessor 

Operation of obtaining a predecessor '—1' is denoted by vr and is de- 
fined by 

Ti = [x\{xa{KZo)Zi), 

where CT = [x]{V{a{xZQ)){xZo)). 'Predecessor' combinator vr can be 
viewed as the reversed operation of obtaining 'successor' a. 

Some of the properties of combinator vr are listed below. These 
properties can be proved by induction on n, where n > 0: 



84 Chapter 5: Numerals 



1) vrZo = Zo\ 




2) Z^a{KZQ)Zo -- 


= z^- 


3) vrZ„+i = Zn- 





Modified subtraction 

Operation of modified, or cut subtraction in usual arithmetic is de- 
noted by '— ' and defined by: 

{ a — b, a > b: 
""^=|o, a<b. 

For representing cut subtraction in combinatory arithmetic the com- 
binator L is used, and is defined by 

L = [xy]{yT:x), 

and has the following properties: 

1 ) hZnZo = Zn\ 

2) LZ^Z^+i = T^i^ZnZra). 

Operation of minimum 



Using the combinator L of cut subtraction, the combinator min, 
which represents in a combinatory arithmetic the function of mini- 
mum min(a, 6), can be established. Combinator min is defined by 



min = [a;y](L2;(L2;j/)), 

where 

Z„, n < m: 



minZnZm = ' 



Zjn, n > m. 



Combinator of minimum, in turn, can be used for constructing other 
arithmetic objects. 



Chapter 5; Numerals 85 

Example 5.1. Assume, that 



a = minZi. 
It is obvious, that: 

1) aZo = Zq; 

2) aZm = Zx form > 0. 

Addition 

Combinator A, which represents an operation of addition, is defined 
by 

A = \x\{££x), 

where 

£ = [xy]{Uy[z]{xxz)), U = [x]{C{MxZi)x), 
C = [x]{xCZoTV), V = [xy]{xyl), 

T = [xyz]{d{y{TTx)z)). 

Exercise 5.1 . Verify, that combinator A has all the properties of op- 
eration of addition '+', i.e., forn, m > 0: 

^Z^Zyn = Zyn] AZn+lZm = a{KZnZm)- 

Symmetric difference 

Symmetric, or positive difference in usual arithmetic is the oper- 
ation \x — y) + {y — xy. Combinator M, representing a symmetric 
difference, is defined by 

M = [xy]{A{Lxy){Lyx)). 



86 Chapter 5: Numerals 

Multiplication 

Comh'maiov of multiplication Mis defined similar to the combinator 
of addition A with the exception, that combinator V is replaced by 
combinator V': 

V' = [xy]{xy{KZo)), 

and combinator T is replaced by combinator T': 

T' = [xyz]{k{y{'Kx)z)z). 

Exercise 5.2. Prove, that combinator M has the properties of multi- 
plication operator for arithmetic objects: 

MZoZ^ = Zo; mZr^+iZm = A{mZ^Zm)Zm. 

Combinatory definable functions 

Addition and multiplication are the instances of the class of combi- 
natory definable functions. Necessary constructions see, e.g., in 
(A.S. Kuzichev, [ ]; H. Barendregt, [2]). The notions that are most 
significant for combinatory definable functions are listed below. 

Definition 5.1 (combinatory definability). The function ^ of n 
arguments is called combinatory definable, if there is an object X 
such, that for any set of n natural numbers ri, . . ., r„, for which 

(^(ri,...,r„) = r, 

where r is a natural number, the equality 

Xr\ . . .Vn = r 

is valid for n > 0. Here: forn = we have X = r; arithmetic objects 
(numerals), representing the natural numbers n are overlined — n. 

Thus, an overline is observed as mapping: 
: o h^ o, (o) = o, 
which, for object o, builds corresponding arithmetic object o. 



Chapter 5; Numerals 87 



Primitive recursion 

The way of constructing the combinators, which represent addition 
and multiplication, can be generalized to arbitrary functions, definable 
by the scheme of primitive recursion: 

(f){0,ri,...,rn) = ^(ri,...,r„); 
(/)(r+ l,ri,...,r„) = ^(r,(?;>(r,ri, . . . ,rn),ri, . . . ,r„), 

where and i/j are predefined functions of corresponding number of 
arguments. 

Indeed, it can be assumed that cj) and ip are combinatory definable 
by the objects g and H respectively. As an object, which combinatory 
defines the function cj), that is defined by the recursion scheme, we can 
select 

£ = [x]{S*£*x), 

where: 



6* = [xy]{Uy[z]{xxz)), U = [x]{C*{mm x l)x), 
C* = [x]ixCOTV), V = [xy]ixyg), 

T = [xyZl . . . Zn\H{'Kx){y{-Kx)zi . . . Zn)zi ...Zn- 

For this choice, it can be shown that: 



gOn...rn, = ■ip{ri,...,rn), 



gr + lri...rn = ■ip{r,(l){r,ri, . . . ,rn),ri, . . . ,rn). 

5.3 Tasks 

Tasii 5.1. Define the objects with the properties of natural numbers 
(numerals) and learn of their properties. 

Task formulation. Numerals are the following objects: 

n = Xxy.{x"')y, 



oo Chapter 5: Numerals 

where n is a natural number from the set {1, 2,3,... }. Show, that 
numerals are the objects with characteristics: 

n={SB)''{KI). (n) 

Solution. 

n— 1 . The notion of x""y is defined by induction: 

(i) x°y = y, 
(ii) x"'^^y = x{x"^y), n > 0. 

Thus, x^y = x{x{x{xy))). 

n— 2. A behavior of the objects n = {SB)"'{KI) for n = 0, 1 is 
verified by: 

= {SBf{KI) = KI, 

Oab = Klab = lb = b = {Xxy.y)ab, 

1 = SB{KI), 

lab = SB{KI)ab = Ba{KIa)b = Balb 
= a{Ib) = ab = {Xxy.xy)ab. 

n— 3. A behavior of n = {SB)"'{KI) in a general case is verified 
by: 



nab = {SBY{KI)ab 




= SB{{SBY-\KI))ab 


(byDf.) 


= Ba{{SBy-\KI)a)b 


(by(S)) 


= a{{SBY-^{KI)ab) 


(by(i3)) 


= a{n — lab) 


(byDf.) 


= a{a^-^) 


(byDf.) 


= a^-b = {\xy.x''y)ab. 


(byDf.) 



Answer. Numerals n = {Xxy.x^-y) are the objects as {SB)'^{KI). 



Chapter 5; Numerals ox) 

Task 5.2. Determine an object representing the operation of '+1' on 
a set of numerals and learn of its properties. 

Task formulation. Show, that a = \xyz.xy{yz) determines the 
'successor' function ('adding of one') on a set of numerals: 



an = n + 1. (cr) 

Solution. 

cr— 1. Combinatory characteristic of the numerals is as 
follows: 

nah = a"'b. 

a— 2. The function a can be applied to the numeral n in 
a general case: 

anab = {Xxyz.xy{yz))nab ( by Df.) 

= naiab) (by (/?))_ 

= a'^(a6) (byDf. (n)) 

= a'^+16 (byDf.) 

= n+lab. ( by Df.) 



Thus, anab = n + lab, i.e. an = n + 1. 

Answer. Function a = \xyz.xy{yz) is the successor function for 

numerals n = Xxy.x^y. 

Task 5.3. Determine an object, which returns the length of a finite 
sequence (list). 

Task formulation. Show, that the function 

Length = Xxy.Null x 0{a{Length{Cdr x))y) 
is a function, which returns the length of a list x: 

Length < ai, 02, . . . , a„ >= n (Length) 



90 Chapter 5: Numerals 



Solution. 

Length— \. The auxiliary functions Null and Cdr can be in- 
troduced: 

1, x = NIL = { ) 
Nullx=^ (a; is an empty list), (Null) 

0, otherwise; 



1 = Xxy.xy = Xx.x = I, (1) 

= Xxy.y = KI, (0) 

an = n + 1, 

NIL={), iorx={ai), 
Cdr x = ^ {a2, . . . ,an), for (Cdr) 

x= (ai,a2,...,a„). 



Length— 2. The function Length is applied to the empty list 
Nil: 

Length Nil = 

= Xy.NullNilO{a{Length{CdrNil))y) ( by (/?)) 

= Xy.lO(a(Length(Cdr Nil))y) {by (Null)) 

= Xy.I{KI){a{Length{Cdr Nil))y) (by(0),(T)) 

= Xy.KI{a{Length{Cdr Nil))y) ( by (/)) 

= Ay./ (by(K)) 

= Xy.iXz.z)_ (by(/)) 

= Xyz.z = 0. (by(0)) 

Thus, the function Length is sound relatively application to the 
empty list, i.e. Length Nil = 0. 



Chapter 5; Numerals 91 

Length— 3. The function Length can be applied to the list x, 
consisting of a single element: x = (a): 

Length x = 

= Xy.Null xO{a{Length{Cdr x))y) (/?) 

= Xy. {a {Length Nil)y) (Null), {Cdr) 

= \y.KI{KI){aOy) (0) 

= \y.I{aOy) (K) 

= Ay.aOy (I) 

= Ay.ly _ (o-) 

= >^y-iy = ^y-y = /= i. 

Thus, the function Length is sound relatively application to the 
list, consisting of a single element, i.e. it equals to 1. 

Length— 4. At last, the function Length will be verified in a 
general case, for non empty list x of length n: x ^ Nil, where 
symbol '/' means 'is not convertible to': 

Length x = Xy.Null x 0{a{Length{Cdr x))y) 
= Xy.OO{a{Length{Cdr x))y) 
= Xy.a{Length{Cdr x))y 
= Xy.an — 1 y 
= ^y-ny 
= Xy.{Xxz.x^z)y = Xy.Xz.y^z = Xyz.y"'z = n. 

Answer. The function Length actually returns the length of a list. 

Exercises 

Confirm or neglect the following. 
Exercise 5.3. Addition is defined by the A-expression 

Xninfx.nif{nfx). 



92 Chapter 5: Numerals 

Exercise 5.4. Multiplication is defined by the A-expression 

XmXnXf.m{nf). 
Exercise 5.5. Exponentiation is defined by the A-expression 

XmXn.nm, 
because, for instance, ^3^2/2; = {Z2)^fx = f^x. 



Chapter 6 



Typed combinators 



The notion of a class is one of the most basic in object-oriented rea- 
sonings. In this case the class is understood as a pattern for con- 
structing the instances of the particular objects. Moreover, classes 
themselves could be considered as the objects. The same way, com- 
binators could be classified, or typed. The higher orders of func- 
tional spaces are significant for combinators. Nevertheless, an in- 
tuitive clarity of manipulations with the combinators as with objects 
is not lost. 



6.1 Notion of a type 



The non-formal discussion, what kind of entity is a type, exempli- 
fies rather transparent idea. Each function has a domain and range. 
Hence, not all the arguments are of interest, but those of them that 
belong to the indicated domain. This means, that the arguments as 
objects are type assigned. 

93 



94 Chapter 6: Typed coMBiNATORS 



Pure type systems 

It is assumed, that pure type systems are the families of typed A- 
calculi, every member of which is characterized by a triple {S, A, R), 
where: 

5" is a subset of constants from the system, that are the sorts; 

^4 is a subset of axioms like 

c : s, 

where c is a constant, and s is a sort; 

R IS a set of triples of sorts, each of them determines, what of the 
functional spaces could be constructed in the system and on 
what sorts each of functional spaces is constructed. 

Each of the pure type systems is a formal system with sentences, that 
are constructed as the derivable statements like this: 

context h type assignment. 

Using these statements, the type in this context is assigned to a term 
of A-calculus. 

Constructing a class of the types 

A class of the types is generated as follows. At a starting point, there 
is a finite or infinite set of the basic types: 

^1, h, h, ■■■ ^n, •••, 

and every of them has an intuitive interpretation as the associated set. 
Next, the inductive class of types is generated: 

i) a basic type is a Ji/pe; 



Chapter 6; Typed coMBiNATORS 95 

ii ) if a and b are the types, then (a ^ 5) is a type: 

a — type, 5 — type 

(a ^ 6) — type 

An intuitive interpretation for '(a -^ 6)' is a 'set of all the mappings 
from a to b\ By agreement, the notations '(a -^ 6)', '(a 6)', '(a, 6)' 
are assumed as having the same meaning. The parentheses, omitted 
from the notation of a type, can be restored by association to the 
right. This agreement is exemplified as follows: 

Example 6T. 

(a (6 c) d) = (a ((6 c) d)) = (a ^ {{b -^ c) ^ d)), 
(ab cd) = (ab (c d)) = {a{b{c d))), 

i.e. '(a (6 c) d)' means '(a ^ ((6 ^ c) ^ d))', and '(a 6 c d)' means 
'(a ^ (6 ^ (c ^ ^)))'> and they are distinct types. 

A central notions in applicative computational systems are not 
the domains of the functions, but the functions themselves as the 
general correspondences. In fact, namely these correspondences are 
the entities in the calculus, they are concepts of the functions, i.e., 
the objects in their own meaning. In this case, more augmented rea- 
sonings are needed to capture a sense of types. Indeed, combinators 
represent the functions, functions of functions, functions of functions 
of functions, . . . , i.e. they are higher order functions, or functionals. 
The task of establishing a type of the object becomes non-trivial, and 
the types are generated in accordance with the definite rules. The 
resulting domains become strongly interrelated. The contradictions 
could be observed in corresponding logical constructions. 

All of this needs more rigorous background. At first, a ground 
notation of a type 



96 Chapter 6: Typed coMBiNATORS 

has a diversity of equal notational variants: 

ab, b", Fab 
and some others. 

6.1.1 Combinatory terms 

For a combinatory term X, i.e. for such a term, that is derived by the 
postulates of combinatory logic, we say that 

'a type a is assigned to combinator X\ 

or, 

h #(X) = a 

if and only if this statement is derived from the following axioms and 
the rule: 

Axiom schemes: 

h#(/) = {a,a), (FI) 

h#(K) = (a,(6,a)) = (a,6,a), (FK) 

h#(5) = ((a,(5,c)),((a,6),(a,c))). (FS) 



Rule: 

h#(X) = (ffl,6), h#(t/) = a 

h #iXU) = b 



(F) 



Note, that according to the rule (F), type scheme is assigned to the 
application (XU) of object X to object U, when the type schemes 
of these component objects are known. An object X is viewed as a 
function from a to 6, and [/ — as an argument of this function, which 
is taken from the domain (of) a. Then the values of a result {X U) of 
applying X ioU are taken from the range (of) b. 



Chapter 6; Typed coMBiNATORS 97 



6.1.2 A-terms 

Note, that in case of A-terms a type assigning for objects can be 
suitably done, using the following to rules: 



h #(x) = ffl, h #(X) = b 

\- #Xx.X = {a,b) 
h#(X) = (ffl,6), h#(t/) 

h #(XC/) = 6 



(A) 



where X, U are A-terms, and a; is a variable. 

Note, that according the rule (F), an assignment of type scheme 
of application {X U) of object X to object U can be obtained, when 
the type schemes of these last objects are known. An object X is 
viewed as a function from a to b, and [/ — as an argument of this 
function, which is taken from the domain (of) a. Then the values of a 
result {X U) of applying X ioU are taken from the range (of) b. 

In accordance with the rule (A), for known type scheme a, as- 
signed to variable x, and known type scheme 6, assigned to term X, 
the type scheme (a, b) is introduced, and this type scheme is assigned 
to the term Xx.X, and this term is interpreted as a function from a to 
b. 

6.2 Tasks 

Using the axioms and rule (F), find the type assignments for the 
main combinators, that are listed in Table 6.1. During the process 
of solving these tasks, get more knowing in that, what are the math- 
ematical functions, how to obtain their composition, and how to con- 
struct the simplest programs, using the method of composing. Each 
combinator gives an idealization of a program as a "black box". This 
means, that the knowing of intrinsic structure of a program is not 
so important to be determined, but it is more important to establish 



98 Chapter 6: Typed coMBiNATORS 



Table 6. 1 : The list of main combinators. 



(1) 


#(S), 


where 


B = 


: S{KS)K, 


(2) 


MSB), 








(3) 


#(^o), 


where 


Zo-- 


= KI, 


(4) 


#(^i), 


where 


Zi-- 


= SB{KI), 


(5) 


#{Zn), 


where 


Zn- 


= {SBYiKI), 


(6) 


MW), 


where 


w ^ 


= CSI, 


(7) 


#{B'), 


where 


B^ - 


= BBB, 


(8) 


*iB'), 


where 


B'- 


= BBB^, 


(9) 


#(CP1), 


where 


(7(2] 


= BCiBC), 


(10) 


#(CP1), 


where 


(7(3] 


= BC{BC^^^), 


(11) 


#(q2]), 


where 


<^[2] 


= B^CC, 


(12) 


#(^3]), 


where 


<^[3] 


= B^C^2]C, 


(13) 


#(^), 


where 


$ = 


B^SB, 


(14) 


#(n, 


where 


Y = 


WS{BWB), 


(15) 


#{D), 


where 


D = 


^ C'[2]/, 


(16) 


4{C), 


where 


C = 


S{BBS){KK) 



Chapter 6; Typed coMBiNATORS 99 



the behavior of a program, knowing, what are its input and output 
values. Combinations (compositions), constructed from the combi- 
nators, give an ability to observe the arbitrary programs as applicative 
forms. Applicative forms have a simple structure: its counterparts 
drop down to the left part and the right part, so that a binary tree is 
the representation of applicative form. Note, that particular branches 
of this tree can be evaluated independently of others, giving rise to 
ability of parallel computations. 

Task 6.1. Assign a type to the object: #(5). 

Hint. The construction of S{KS)K can be represented by a tree, 
which is as follows: 

Expl= (ai,(6i,ai)) 

Exp 2 = ai 

Exp 3= ((6i, ai), ((a2, 62), (a2, C2))) 

Exp A = (61, ai) 

Exp 5= {{a2,b2),{a2,C2)) 

Exp 6 = (02,62) 

Exp7 = (02,02) 





^ HK) = 


Exp I 


^#(5) = 


= Expi 


2 


^#(5) 


= Exp 3 


^4{KS) = Expi 




{^ ) 


h 


*{S{KS)) 


= Exp 5 


^ # w = 


Exp 6 


(F) 



(F) 
I = Fxp 6 

^ #{S{KS)K) = Exp7 

Solution. 

^{B)—\. Let a, 6, c be the known types. As, by scheme {FK), 
the type assignment is h # {K) = (ai, (61, ai)), and, by 
scheme (FS) : h # (5*) = ai, then by rule (F) : h # (KS) = 
(61, ai), where ai = ((a, (6, c)), ((a, 6), (a,c))). 

#(i?)— 2. Next, the type is assigned by scheme (FS): 

h #(S) = ((6i,ai),((a2,62),(a2,C2))), 



100 Chapter 6: Typed coMBiNATORS 

where 61 = a2, ai = (62,02), i.e. 62 = (a, (6, c)), C2 = 
((a,6),(a,c)). 

#(B)-3. From h # (XS") = (5i, ai) and rule (F) it follows, 
that: 

h #(5(XS)) = ((a2,52),(a2,C2)). 

By scheme (FK) the type is: h # (X) = (03, (63, a3)), where 
as = ^2, (63, as) = h, i-e. 63 = a, 03 = (6, c). 

#(5)-4. Thus, a2 = a3 = (6,c). From h # (S(KS)) = 
((a2, 62)5 (a2, C2)) and rule (F) we obtain: 

h # (5(XS)X) = (a2, C2) = ((6, c), ((a, 6), (a, c))). 

/Insta^er. i? has a type: # (B) = ((6, c), ((a, 6), (a, c))). 

The other types that should be assigned to the rest of the combi- 
nators will be defined similarly. 

Task 6.2. Assign a type to the object: #(SB). 

Solution. 

#{SB)-l. Building of the tree: 

Exp 1 = ((ai, (61, ci)), ((ai, 61), (ai, ci))) 
Exp2= (ai,(6i,ci)) 
Exp3= ((ai,6i),(ai,ci)) 

h#{S) = Expl h#{B) = Exp2 

^#{SB) = Exp3 ^ ' 

#(S'B)-2. A type scheme for B is as follows: h # (B) = 
((6, c), ((a, 6), (a, c))), but h 4 {B) = (ai, (61, ci)), i.e. ai = 
(6, c), 61 = (a, 6), ci = (a, c). 

Thus, h # (55) = (((6, c), (a, 6)), ((5, c), (a, c))). 



Chapter 6; Typed coMBiNATORS 101 

Answer. (SB) has a type (((6, c), (a, 6)), ((6, c), (a, c))). 
Task 6.3. Assign a type to the object: #(Zo). 

#(Zo)-l. Zo = KI. 



h#iK) = ia^,ih,a^)) h#(/) = a 



- (i^) 



h#(X/) = (6i,ai) 

#(Zo)— 3. By scheme (F/) :l- #(/) = ai, where ai = {a, a); 
the type of 6i is distinct from ai, i.e. bi = b (here: a, b are the 
known types). 

Thus, h #{KI) = (6, (a, a)). 

Answer. Zq = KI has the type (6, (a, a)). 

Task 6.4. Assign a type to the object: #(Zi). 

#(Zi)-l. Zr = SB{KI). 

#(Zi)-2. (F(X/)) : h #(K/) = (5, (a, a)); 
(F(5i?)) : h #(Si?) = (((6, c), (a, 6)), ((6, c), (a, c))). 

#(Zi)-3. i?a;pl = (((5i,ci),(ai,6i)),((6i,ci),(ai,ci))) 
£;a;p2 = ((6i,ci),(ai,6i)) 
£;a;p3 = ((6i, ci), (ai, ci)) 

h#{SB) = Expl h#{KI) = Exp2 

^4{SB{KI)) = Exp3 ^^^ 

#(Zi)-4. By (F(X/)) : h #(X/) = ((6i, ci), (ai, 6i)), where 
(6i,ci)) = b,ai = a,bi = a. Type ci differs from a and b, 
Ci = c. 



102 Chapter 6: Typed coMBiNATORS 

Thus, the type is as follows: h #(2'i) = ((a, c), (a, c)). Note, that the 
statement h # (Zi) = ((a, 6), (a, 5)) is valid as well (the dii^erence is 
just notational). 

Answer. Zi = SB{KI) has the type ((a, 6), (a, 6)). 
Task 6.5. Assign a type to the object: #(Z„). 
Solution. At first, a type #(^2) is to be established. 

#(Z2)-1. Z2 = 5B(SB(X/)). 

#(Z2)-2. (FZ) : h #(Zi) = ((a, b), (a, 5)). 

#(Z2)-3. i?a;pl = (((6i,ci),(ai,6i)),((6i,ci),(ai,ci))) 
£;a;p2 = ((61, ci), (ai, 61)) 
Exp?> = ((6i,ci),(ai,ci)) 

h#(5i3) = i?xpl h#(Zi) = i^xp2 

h#(Z2) = ^a;p3 ^ ^ 

#(Z2)-4. By scheme {FZ) : h #(Zi) = ((&i, ci), (ai, 61)), 
where a pair of equalities should be valid simultaneously: 
(61, ci) = (a, 6), (ai, 5i) = (a, 6), i.e.: 

61 = a, ci = 5, I 
ai = a, 61 = 5. J 

These equalities (*) are valid if and only if (iff) ai = 61 = ci = 
a = b. Thus, h # (Z2) = ((a, a), (a, a)). 

Now type #(Z„) should be determined. 

#(Z„)-1. Z„ = (5i?r(ir/) = SB{{SBr-\KI)), 
where n > 2. 

#(Z„)-2. (FZ2) : h #(Z2) = ((a, a), (a, a)). 



Chapter 6; Typed coMBiNATORS 103 

#(Z„)-3. Expl = (((6i,ci),(ai,6i)),((6i,ci),(ai,ci))) 
Exp2 = ((6i,ci),(ai,6i)) 
Exp3 = ((6i,ci),(ai,ci)) 

h#{SB) = Expl h#{Z2) = Exp2 

^#iZs) = Exp3 ^ ' 

#{Zn)-4. By scheme (F) :h #(^2) = ((61, ci), (ai, 61)), 
61 = a, ci = a, ai = a, i.e. h #(^3) = ((a, a), (a, a)). The 
following equality is obtained: #(^2) = #(-Z^i)- 
By induction, adding the step for n, it can be derived that h 
#(Z„) = ((a, a), (a, a)), where n > 1. 

/Insta^er. The objects Z^ = {SB)^{KI), where n > 1, have been 
assigned the same type: ((a, a), (a, a)). 

Task 6.6. Assign a type to the object: #(M^). 

#(H^)-1. H^ = CS/. 

#(H^)-2. (FC) :h #(C) = ((6,(a,c)),(a,(6,c))). This 
statement will be proved below (see Task 6. 1 6). 

#(H^)-3. Expl = ((5i,(ai,ci)),(ai,(6i,ci))) 

Exp2 = (6i,(ai,ci)) 

Exp2> = (ai,(6i,ci)) 

Exp A = (ai) 

Exp 5 = (61, ci) 

h #(C) = iJ;:Epl h#(^) = i^a:p2 

^ #{SCI) = Exp5 ^ ' 



104 Chapter 6: Typed coMBiNATORS 

4{W)-A. By scheme {FS) : h #(5") = (6i, (ai, ci)), however 
h #(S) = ((a,(6,c)),((a,6),(a,c))). 

Thus, 6i = (a, (6,c)), ai = {a,b), c\ = {a,c). Similarly, the 
following is valid: (FI) :h # (/) = a^. But h #(/) = {a, a), 
i.e. ai = (a, a) a = b. The following equalities are valid: a = 
b, ai = (a, a), bi = (a, (a, c)), ci = (a, c). 

Thus, h # (14^) = ((a, (a, c)), (a, c)), and this is equal to: 
h #(iy) = ((a,(a,6)),(a,6)). 

Answer. W = CSI has the type ((a, (a, 6)), (a, 6)). 
Task 6.7. Assign a type to the object: #(5^). 

#(B2)-1. B^ = BBB. 

#(i?2)-2. (B) : ((6c)((a5)(ac))). 
Here and thereafter it is assumed that a notion of: 

'h#(X) = (a,(6,c))' 

is similar to: 

'(X): (a(6c))'. 
In the following commas "," will be omitted, i.e. 

\X): (a,(6,c))' 
is the same as 

'(X): {a{bc)y. 



Chapter 6; Typed coMBiNATORS 105 

#(B2)-3. Find, at first #(BB): 

(B): ((6ici)((ai5i)(aici))) (B) : (5i cQ 

(BB) : ((ai 6i)(ai ci)) ^ ^ 

where bi = (62 C2), ci = ((a2 52)(a2 C2)), 

(BB) : ((ai(62 C2))(ai((a2 62)(a2 C2)))). 

Assume: ai = a, 62 = ^5 C2 = c, a2 = d. Then (SB) : 

((a(6c))(a((d6)(dc)))). 

Find now #(BBB). 

(gg): ((ai(6ici))(ai((di6i)(dici)))) jB) : ja^jb^ c^)) 
(BBB): (ai((di6i)(dici))) 

where (ai(6i ci)) = ((5 c)((a 6)(a c))), i.e.: ai = (6 c), 61 

(a 5), ci = (a c). Let di = d. 

Thus, (5BB) : ((5 c){{d{a b)){d{a c)))). 

/Insta^er. B^ = BBB has the type ((6 c)((d(a 6))(d(a c)))). 
Task 6.8. Assign a type to the object: #(i3^). 

#(B3)-;. B^ = BBB^. 
As 
(BB) : ((ai(6i ci))(ai((di 6i)(di ci)))) (B^) : (ai(6i ci)) 



(i^) 



(BBB2) : (ai((di 6i)(di ci))) 



(i^) 



where (ai(6i ci)) = ((6 c)((d(a b)){d{a c)))), then ai = (6 c), 5i = 

(d(a 6)), ci = (d(a c)). 

Let di = e. Then (BBB^) : ((6 c)((e(d(a 6)))(e(d(a c))))). 

/Insta^er. B^ = BBB^ has the type ((5 c)((e(d(a b))){e{d{a c))))). 
Task 6.9. Assign a type to the object: #(C[^1). 



106 Chapter 6: Typed coMBiNATORS 

Solution. 

#(CP])-2- Find the type #(BC). 

{B): ((6ici)((ai6i)(aici))) (C) : (61 ci) 



{BC): ((ai6i)(aici)) 



, (i^) 



where (61 ci) = ((a(6 c)){b{a c))), i.e. 61 = (6(c d)), c\ 
ic{bd)). ai = a. Thus, (BC) : ((a(6(c d)))(a(c(6 d)))). 

#(CP])-3. i^xpl = ((ai(6i(cidi)))(ai(ci(6idi)))) 
Exp2 = (ai(6i(ci di))) 
E'ajpS = (ai(ci(6i di))) 

(BC) : £'a;pl (BC) : Exp 2 

{BC{BC)) : Ba;p3 ' "^^^ 

where (ai(6i(ci di))) = {{a{h{c d))){a{c{b d)))), i.e. ai 
{a{b{c d))), 61 = a, ci = c, di = (6 d). 

Thus, (BC(BC)) : {{a{b{cd))){c{a{b d)))). 

Answer. C^l = BC{BC) has the type ((a(6(c d)))(c(a(6 d)))). 

Task 6.10. Assign a type to the object: ^(C^^^). 

Solution. 

#(CP])-1. CPl = BC(BC[21). 

#(CP])-2. Expl = ((61 ci)((ai 6i)(ai ci))) 

B2;p2 = (61 ci) 

Ba;p3 = ((ai 6i)(ai ci)) 

£;a;p4 = ((62 C2)((a2 62)(a2 C2))) 

Exp 5 = (62 C2) 

Exp6 = ((a2 62)(a2 C2)) 



Chapter 6; Typed coMBiNATORS 107 

As 

(B) : Exp I (C) : Exp2 . ^. (B) : Exp 4 (Cl^l) : Exp 5 .^. 

(i* ) (I' ) 

{BC): Expi {BCi^]) : Exp6 ,^, 

(^ )i 

{BC{BCm)) : (ai ci) 

where (6i ci) = ((03(63 C3))(63(a3 C3))), 

(62 C2) = ((a(6(c d)))(c(a(6 d)))), (ai 61) = ((02 62)(a2 C2)), then 

as = ^2 = e, C2 = (63 C3), 63 = c, C3 = (a(6 c)). 

Thus, ai = (02 62) = (e(a(6(c d)))), ci = (63(a3 C3)) = 
{c{e{a{b d)))), i.e. (BC(5(7[21)) : (ai ci). 

/Insta^er. #(CP]) = #(BC(BCP1)) = ((e(a(5(cd))))(c(e(a(5d))))). 

Task 6.1 1. Assign a type to the object: #(C[2])- 

Solution. 

#(q2])-2. ^a;pl = ((61 ci)((di(ai 6i))(di(ai ci)))) 

^a;p2 = (61 ci) 

^a;p3 = ((di(ai 5i))(di(ai ci))) 

Exp4 = (di(ai 61)) 

Exp5 = (di(ai ci)) 

As 

(B^) : Expl (C) : £;a;p2 

(S^C) : Exp 3 (C) : £;a;p4 
(B'^CC) : Exp 5 

where 

(di(ai bi)) = ((02(62 C2))(62(a2 C2))), 
(6ici) = ((a(6c))(6(ac))), 



(i^) 



108 Chapter 6: Typed coMBiNATORS 

then 

61 = ia{bc)), 

ci = ib{ac)), 
«i = h, 

di = (02(62 C2)), 
61 = (02 C2). 

The following is valid: di = (0(62(60))), ai = 62, ci = (6(ac)).Let 
62 = d. Then (B'^CC) : (di(ai ci)) = ((a(d(6 c)))(d(6(a c)))). 

/Ins&yer. Cja] = S^CC has the type ((a(d(6 c)))(d(6(a c)))). 
Task 6.12. Assign a type to the object: #(C[3]). 
Solution. 

#(C'[3])~1- C'p] = -S C[2]C. 

#(q3])-2. ^a;pl = ((6ici)((di(ai6i))(di(aici)))) 

Exp2 = (61 ci) 

£'a;p3 = ((di(ai 6i))(di (ai ci))) 

Exp4 = (di(ai 61)) 

Expb = (di(ai ci)) 

{B^) ■■ Exp 1 (Cpi) : i?a;p2 

(iJ^Cp]) : Exp3 jC) : i?xp4 

(S^CpjC) : Exp 5 ^ ^ 

where (61 ci) = ((a(6(c d)))(6(c(a d)))), (di (ai 61)) = 

((02 (62 C2))(62 ((12 C2))). 

The following is valid: di = (02(62 C2)) = (0(62(6(0 d)))), ai = 
62, ci = (6(c(a d))). Let 62 = e. Substitute e in place of 62, and in 
place of di, ai, ci the corresponding expressions are to be substi- 
tuted, resulting in type: {B^C[2]C) : (di(ai ci)). 

Answer. Cpj = B^qajC has the type ((a(e(6(c d))))(e(6(c(a d))))). 



Chapter 6; Typed coMBiNATORS 109 

Task 6.13. Assign a type to the object: #($). 

Solution. 

#$-1. ^ = B'^SB. 

#$-2. Expl = iibici)iidiiaibi))idiiaicim 

Exp 2 = (6i ci) 

Exp3 = ((di(ai 6i))(di(ai ci)))) 

ExpA = ((ii(ai 5i)) 

Exp5 = (di(ai ci)) 



As 



(B2) : Expl (S) : Exp2 

(B'^S) : Exp 3 (B) : ExpA ' 



(F) 



(B'^SB) : Exp 5 

where 

(6ici) = ((a(5c))((a5)(ac))), 

(di(ai 6i)) = ((62 C2)((a2 62)(a2 C2))), 

then di = (62 C2) = (62(& c)), ai = (02 62) = (a 62), ci = 
((a 5)(a c)). Let 62 = d; then 

(B^S'^) : (di(ai ci)) = ((d(6 c))((a d)((a b){a c)))). 

/Insta^er. $ = B'^SB has the type ((d(6 c)){{a d){{a b){a c)))). 

Task 6.14. Assign a type to the object: #{Y). 

Solution. 

#r-l. Use the equality r = W^S'(BVFB). 

#F— 2. The type schemes are restricted by the following cor- 
respondences: 

jW) : ((ai(ai 6i))(ai 61)) (g) : (ai(ai 61)) 



110 Chapter 6: Typed coMBiNATORS 

As #(5) = (a(6 c)){{a b){a c)), then ai = {a{b c)), ai = (a 6), 
6i = (a c). It follows, that b = (b c), but it is impossible in a 
finite form. Hence, the assumption of existing a type ^{WS) is 
invalid. In addition, 

jB): iib2C2)i{a2b2){a2C2))) (14^) : (62 C2) 

(BVF): ((a2 62)(a2C2)) " ^ ^ 

As #(VF) = (ai(ai 6i))(ai 61), then 62 = (ai(ai 61)), C2 = 
(ai 61). Next, 

jBW): iia2b2)ia2C2)) jB) : (0262) .^. 
(BH^B) : (a2 C2) ' ^ ^ 

But #(B) = (as bs){{c3 a3)(c3 63)), Hence, 02 = (03 63), 62 = 
(c3 a3)(c3 63), 62 = ai(ai &i), C2 = (ai 61). It follows from 
these equalities, that, in particular, a^ = (03 03) and at the same 
time ai = C3, i.e. C3 = (03 03), but this is impossible in a finite 
form. Therefore, the assumption of existing a type ^{BWB) is 
invalid as well. 

It follows, that it is impossible to assign type to the expression 
WS{BWB). Hence, as F = WS{BWB), then it is impossible 
to assign type for a combinatory representation of Y . 

#F— 3. Nevertheless, consider the following reasonings. It is 
known, that Yx = x(Yx), i.e. ^(Yx) = ^{x(Yx)). 
Let #(2;) = a, ^(Yx) = b, then, according to the rule (F) : 
#(y) = (a, 5), because 

(y) : (ffl, 5) jx) : a 

(Yx) : b ^ ^ 

Next, taking into account, that ^{x(Yx)) = ^(Yx) = b, we 
obtain #(a;): 

{x) : (6, b) {Yx) : b 

{x{Yx)) : b ^ ^ 



Chapter 6; Typed coMBiNATORS 111 

Therefore, a = (5, 6), (F) : (a, 5) = ((6, b),b). 

Answer. Y has the type ((6, 6), 6), but VF5'(i?VFi?) has no type. 

Task 6.15. Assign a type to the object: #(I3). 

Solution. 

#D-\. D = C[2]I. 

#D-2. 

(Cpi): ((a(rf(6c)))(d(6(fflc)))) (/) : (ffl(d(5 c))) 

(Cp]/): {d{b{ac))) ' ^ ^ 

where (/) : (ai, ai), i.e. a = {d{b c)). 

Thus,#(q2]/) = (d(K(rf(^c))c))). 

Answer. D = Cpj/ has the type: (a, (6, ((a, (6, c)), c))). 
Task 6.16. Assign a type to the object: #(C). 

#(7-1. C = S{BBS){KK). 

#(7-2. (5) : (a5c)((a6)(ac)), (B) : (6c)((a 6)(a c)), (K) : 
(a(5 a)). 

#C-3. 

(B): (62C2)((a2 52)(a2C2)) (B) : (6202) 



(BB): (a2 62)(a2C2) 

(BB): (a2&2)(ffl2C2) {S) : (a2 62) 
(BBS) : (a2 c^) 

{S) : (a3(63 C3))((a3 bs){a^ C3)) (BBS) : (a2 C2) 
5(BB5): (a3 63)(a3C3) 



112 Chapter 6: Typed coMBiNATORS 

(K) : (04(64 04)) (K) : 04 
(/C/C) : (64 04) 

S{BBS): (0363) (as C3) (/C/C): (64 a4) 



5(BBS)(XX): (0303) 
where: 

(03 h) = ihai), 

{h C2) = ((^6 ce),{{ae be),{ae ce))), scheme for B is taken 

04 = (05(65 05)), scheme for K is 

taken 
(02 C2) = (03(63 C3)), 
(02 62) = {ab c){a b){a c). scheme for S is taken 

The following is derived: 

03 = 02 = (a 6 c) =64, 

C2 = (^3 C3) = (ae 66)(a6 ce), 
62 = (a6)(ac) = (66 ce), 



63 = 04 = (as 65 05) 



Next, 



C6 = (a c) , 
66 = (a 6), 
^3 = (^6 66) = (ae a 6) = (6 a 6), because 

^3 = (as ^5 as)- 

Thus, C3 = (a6 C6) = (6 C6) = (6 a c). The only thing is left to write 
the type (03, C3). 

Answer. C = 5'(BB5')(KK) has the type: ((a, (6, c)),(6, (a, c))). 



Chapter 7 

Basis /, K, S 



In constructing a combinatory logic, one of the generic tasks was to 
declare a minimum amount of primitive objects, which are atomic 
in their origin, and to declare the modes of their combining, which 
give the sufficiently rich mathematical means. These primitive ob- 
jects should have the same behavior as the constant functions, and, 
from a point of view of computer science give the primitive core sys- 
tem for programming, which should grow by "self-evolving". This 
means, that more comprehensive objects are constructed using the 
more primitive ones, and then they are joined to the system and, in 
turn, can be used as the elements in other constructions. 

Let fix an attention at the most primitive programming system, 
which consists of just three instructions: /, K, S. A new object can 
be generated by purely routine applying of algorithm of disassembling 
into a basis, that is quite similar to compiling. 

7.1 Theoretical background 

It will be shown, that an object, which is denoted by A-term (source 
representation), can be represented by the combinatory term (target 
representation). A procedure of transforming the object from source 

113 



114 Chapter 7: Basis/, iC, 5 



to target representation can be significantly simplified in case a pre- 
defined set of combinators is in use. To achieve this goal the set /, 
K, S, will be fixed, which, as known, conforms the property of being 
a basis. 



7.2 Tasks 

Task 7.1. Express the termAx.P via combinators /, K, S. 

Task formulation. Let the definition of term Xx.P be given by in- 
duction on constructing P: 

(1) Xx.x = I, 

(2) Xx.P = KP, if a; does not belong to Fy(P), 

(3) Xx.PQ = S{Xx.P){Xx.Q) otherwise. 

Exclude all the variables from the following A-expressions: 

1. Xxy.yx; 2. Xfx.xx; 3. / = Xx.B{f{Ax)). 
Solution. 



def 

P—l. Xxy.yx = Xx.{Xy.yx)) 

= Xx.{S{Xy.y)Xy.x)) 

^'^=^'^ Xx.SI{Kx) 

= S{Xx.SI){Xx.Kx) 

= S{K{SI)){S{Xx.K){Xx.x)) 

^^^=^^^ S{K{SI)){S{KK)I) 



Chapter 7; Basis/, iC.S 115 



P— 2. Xfx.fxx = Xf.{Xx.fxx) 



(J 

(iy3) 

{1M2) 

(J 
(2y3) 
(2y3) 

(2y3) 

(2M3) 
(1), (2) 



Xf.iSiXx.fx){Xx.x)) 

Xf.S{S{Xx.f){Xx.x))I 

Xf.S{S{Kf)I)I 

S{Xf.S{S{Kf)I)){Xf.I) 

S{S{Xf.S){Xf.S{Kf)I)){KI) 

S{S{KS){S{Xf.S{Kf)){Xf.I))) 

(KI) 

S{S{KS){S{S{Xf.S) 

{Xf.Kf))){KI))){KI) 

S{S{KS){S{S{KS){S{Xf.K) 

{Xf.f)){KI))){KI) 

S{S{KS){S{S{KS){S{KK)I) 
{KI))){KI) 



P-3. f 


def 


Xx.b{f{ax)) 




(3) 


S{Xx.b){Xx.f{ax)) 




(2)^3) 


S{Kb){S{Xx.f){Xx.ax)) 




(2)^3) 


SiKb){S{Kf){SiXx.a){Xx.x))) 




(2)^1) 


S{Kb){S{Kf){S{Ka)I)) 


;rcises 







Exercise 7.1. Express the combinator W mult of second power of 
function in terms of combinators /, K, S. 

Exercise 7.2. For the combinator ^ with a characteristic 

^fabx = f{ax){bx) 



116 Chapter 7: Basis/, iC, 5 

do the following: 

1° write the predicate 

1 < a; < 5 

without a variable. 

Hint. To get this, introduce a construction, which conforms 
$ and {greater 1) {less 5); 

2° express the combinator 

<l> and {greater 1) {less 5) 
in terms of combinators /, K, S. 

Exercise 7.3. Express a combinator, representing the function of 
sum of sines of two numbers, in terms of combinators /, K, S. 

Hint. It is possible, for instance, to use the combinator <|) and write 

<l> plus sin sin. 

Try to transform this expression, using the combinators for elimina- 
tion of duplicate occurrence of 'sin . E.g., 

<l> plus sin sin = W{^ plus) sin = . . . 

etc. 



Chapters 

Basis /, B, C, S 



As was established, the basis /, K, S is not a unique, and a set of 
combinators /, B, C, S has a property of being a basis as well. Com- 
piling (disassembling) of an object using this basis gives a solution 
of a task to generate the object with given properties. Obviously, a 
selection of basis is of free choice depending of some criteria. 

8.1 Theoretical background 

As could be assured, representing terms by compiling them into basis 
/, K, S, there is a regular or even mechanical way to transit from one 
object representation to another. Increasing the number of distinct 
combinators leads to reducing a number of steps in applyingthe com- 
piling algorithm. Of course, as was awaited, not all the sets of combi- 
nators consist of a pairwise independent combinators. In particular, 
combinator / can be expressed in terms of K and S, hence, strictly 
speaking, this combinator is excessive and not necessary. Neverthe- 
less, its usage gives some technical advantages. 

There are other sets of combinators, using which one can get a 
representation of any well formed term. Such sets of combinators are 
considered as basic, or, as accepted to speak, conform a basis. As 

117 



118 Chapter 8: Basis /, B, C, S 



previously, combinator is an object which if constructed from basic 
combinators using application. Hence, the combinatory basis is not 
to be obviously unique, and the multiple representations of the same 
object are awaited. Depending on the aims, one or another represen- 
tation can be selected' . 

8.2 A property of being basic 

A huge variety of disparate combinators can be generated, but, as it 
appears, these combinators are not independent. Part of them can be 
determined via the set of combinators called basic. Combinator can 
be thought as an object being constructed from the basic combinators 
by its applications. 

Consider two basic systems of combinators C, W, B, K and S, 
K: 



Cxyz = xyz, 
Wxy = xyy, 

Bxyz = x{yz), 
Kxy = x; 



Sxyz = xz{yz), 
Kxy = X. 



For any syntactic object V, constructed from distinct variables a;i,. . ., 
Xn by its applications, one can determine a combinator X, composed 
from basic combinators, such that: 

X Xi,...,Xn= V. 

For instance, \i V = xz{yz), then there is the combinator X con- 
structed of the instances from basic system S, K, such that X xyz = 
xz{yz). It is not difficult to conclude, that this is the combinator S, 
i.e. X = S. 



'For example, besides the bases /, K, S and /, B, C, S, used here, the other 
bases can be introduced. In particular, the set C, W, B, K has a property of being 
basic as well. 



Chapter 8; Basis/, B,CS 119 

In general, a generation of combinator X is given by the following 
actions: 

1 ) using B to eliminate the parentheses in V; 

2) using C to re-order the variables; 

3) using W to eliminate multiple occurrences of the variables; 

4) using K to bring in the variables which are not present in V . 

Example 8.1. Let to construe, in the first of the basic systems, a 
combinator X with the property 

ac{bc) = X abc : 



(ac)( b c ) = B ( a c )bc 

^lJ/ '^~^-^ ^-^^ ^^v^^-v'-' '^-v'-' 

^ y z X y z 

= (BBa) c b c 



^ z y 

= {C{BBa)b) c c 
X y y 

= W {C{BBa) b ),c 

X y 

= {BW){ C {BBa))bc 



= (B(BW)C)((BB) a )bc 
v ' ^ — ^^"•^^ 

X y ^ 

= B{B{BW)C){BB)abc. 



In this example, under the objects, to which the known scheme 
can be applied, the variables have been written — in the same order as 
in the corresponding combinatory characteristic. Thus, 

X = B{B{BW)C){BB). 



120 



Chapter 8: Basis /, B, C, S 



8.3 Elementary examples 

Consider examples of disassembling the object into basis. Let the 
source terms be the same as in the occasion of disassembling into ba- 
sis /, K, S. The resulting expressions can be compared to conclude, 
what of the bases could be preferred^. 

Task 8. 1 . Represent the term M = Xx.PQ, using the only combina- 
tors /, B, C, S. 

Task formulation. Let the definition of such a term M that the vari- 
able X occurs in a set of free in {PQ) variables, i.e. x G FV{PQ), 
be given by induction on constructing M (here: 'G' means 'belongs', 
and '^' means 'does not belong'): 



(1) Xx.x = /, 

' (a) BP{Xx.Q), 



(2) Xx.PQ = < 



(6) CiXx.P)Q, 



\{ X (^ FV{P) and 
X G FV{Q), 

if a; G FV{P) and 

x<^FV{Q), 

(c) S{Xx.P){Xx.Q), if a; G FV{P) and 

X G FV{Q). 



Exclude all the variables from the following A-expressions: 
I. Xxy.yx;2. Xfx.fxx. 



Solution. 



' The solving of the task of disassembling an object into the basis can be viewed 
differently. As any combinator is a notion and even a concept in a mathematical 
sense, then a source object is 'under investigation', or 'under knowing', basis is a 
'system of known concepts', and a procedure of disassembling into basis is 'knowl- 
edge representation' of the source object in terms of already known concepts. Similar 
reasons in its essence are used in applications of object-oriented approach. 



Chapter 8; Basis/, B,CS 121 



M-l. 


Xxy.yx = 

(1) 

{2)(a) 


Xx.{Xy.yx) 
Xx.{C{Xy.y)x 
Xx.CIx 
B{CI){Xx.x) 




(1) 


B{CI)I. 



Checking. B{CI)Ixy = CI{Ix)y = Iy{Ix) = lyx = yx. 

M—2. Xfx.fxx = Xf.{Xx.fxx) 

^='^ Xf.S{Xx.fx){Xx.x) 
Xf.S{Bf{Xx.x))I 
\f-S{BfI)) 
C{Xf.S{BfI))I 
C{BS{Xf.BfI))I 
C{BS{C{Xf.Bf)I))I 
C{BS{C{BB{Xf.f))I))I 
C{BS{C{BBI)I))I. 



(I),i2){a) 
(£) 

{2){a) 

{2){a) 
(1) 



Exercises 

Exercise 8.1. Prove, that a set of combinators C, W, B, K has a 
property of being basic, i.e. is the basis. 

Hint. Use a definition of basis in a general form (see. ["], p. 172): 

Definition 8.1 (basis), (i) Let ^ be a subset of all the A-terms A, 
^ C A. Denote by X^ a set of terms, generated by X . Set 
X^ is the least set 3^, such that: 

2) if terms M,N ^y, then their application (M N) £ Y. 



122 Chapter 8: Basis /, B, C, S 

(ii) Consider a subset of A-terms ^ C A. A set of terms A' C A is 
called basis of A, if 

(VM G ^)(3A^ G A:+).Ar = M. 

(iii) Set ^ is called basis, if ^ is a basis of the set of closed terms. 

Exercise 8.2. Represent the combinator W mult of the second power 
of a function in terms of combinators /, B, C, S. 

Exercise 8.3. For the combinator <|) with the a characteristic 

^fabx = f{ax){bx), 

do the following: 

1° write the predicate 1 < a; < 5 without a variable. 

Hint. To achieve this goal, bring in a suitable construction 
<l> and (greater 1) (less 5); 

2° represent combinator ^ and (greater 1) (less 5) in terms of com- 
binators /, B, C, S. 

Exercise 8.4. Express a combinator, representing the function of 
sum of sines of two numbers, in terms of combinators /, B, C S. 

Hint. It is possible, for instance, to use combinator <|) and write 

<l> plus sin sin. 

Try to transform this expression, using the combinators for elimina- 
tion of twofold occurrence of 'sin . E.g., 

<l> plus sin sin = W{^ plus) sin = . . . 

etc. 



Chapter 9 

Applications of fixed point 
combinatory 



The recursive definitions of the objects are considered in this chapter. 
Using a fundamental for functional programming fixed point theo- 
rem, the recursive definitions are succeeded in reducing to the usual 
equational form. 

9.1 Fixed point theorem 

The tasks, considered in this chapter, are composed as a small self- 
contained study. Aim is to establish the relationships of the pro- 
gramming language constructions with the notions of calculus of A- 
conversion. 

A characteristic equality for the function Y is as follows: 

Yf = f{Yf). 

Theorem 9.1 (fixed point). Self referencing definition of the func- 
tion /: 

f = Ef 

123 



124 Chapter 9; Applications of fixed point combinator Y 

where / has no free occurrence m E, f ^ E, can be found as: 

f = YE. 
Proof. Evidently, if in the definition: 

=Y E =Y E 

replace / by (F E), then obtain Y E = E{Y E). D 

9.2 Elements of recursive computations 

A function is assumed as recursive, if its defining expression contains, 
at least, one reference to the definable function itself. 

Consider a recursive definition of the factorial function: 

FAC = {Xn.IF{= nO)l{xnFAC{-nl))) 

When this definition is applied directly, then the following transfor- 
mations occur: 

FAC = {Xn.IF{= nO)l 

{xnFAC{-nl))) = 
FAC = {\n.IF{= nO)l 

{xn{XnJF{= nO)l 

(xn FAC{- n !)))(- n 1))) = 
FAC = {Xn.IF{= nO)l 

{xn{Xn.IF{= nO)l 
{xn{XnJF{= nO)l 

(xn FAC{- n !)))(- n !)))(- n 1))) = 

It is not difficult to view, the a chain of these transformations never 
completes. In the notations above the name FAC is assigned to the 



Chapter 9; Applications of fixed point combinator Y 125 

A-term. This notion is natural and suitable, but does not conform to a 
syntax of calculus, because there is no function referencing in the A- 
calculus. In a connection with this, an expression is to be translated 
in the language of A-calculus, i.e. to express a recursion in its pure 
form (without self referencing). As it happened, this translation is 
possible, and without violation a framework of the combinatory logic. 

9.3 Using the combinator y 

As a main sample, whose evaluation exemplifies the principal effects 
of computations with a fixed point, use the factorial function FAC. 
The notion of this function FAC in an abbreviated form is as follows: 

FAC= Xn.{...FAC...). (9.1) 

Using A-abstraction, obtain: 

Xfac.FAC fac = {Xfac.{\n.{. ..fac. .)))FAC. (9.2) 

By rule (ry), conclude that: 

Xfac.FAC fac = FAC, 

and the definition (9.2) can be written as follows: 

FAC = {Xfac.{Xn.{. ..fac. .)))FAC. (9.3) 

Assuming H = Xfac.{Xn.{. . . fac . . .)), obtain: 

FAC = H FAC. (9.4) 

The definition of i7 is a usual A-abstraction, which does not use a 
recursion. A recursion is expressed only in a form of equality (9.4). 
The definition (9.4) is similar to a mathematical equation. E.g., to 
solve the equation (x^ — 2) = x means to find out the values of x, 



126 Chapter 9; Applications of fixed point combinator Y 

which satisfy this equation: (x = —l,x = 2). Similarly, to solve 
(9.4), means to find out the A-abstraction for FAC, which satisfies 
(9.4). The equation FAC = H FAC expresses the fact, that when 
the function H is applied to the argument FAC, its results in FAC 
again. That is why FAC is called a fixed point of the function H. 

Example 9. 1 . The numbers and 1 are the fixed points of the function 
/ = Xx. XXX, i.e. / = and / 1 = 1. Actually, 

/O = {\x.y.xx){]= (/?) 

= X 00 = 0, 

/I = {\x.xxx)l= (/?) 

= X 1 1 = 1. 

Thus, it is needed to find out a fixed point of the function H. Evi- 
dently, this point depends only of H . Introduce the function Y , which 
conforms the following scheme: 

getting input function as its argument, the function Y 
generates as an output the fixed point of this function. 

It means, that we obtain YH = H(YH), where y is a fixed point 
combinator. If we find out such Y, then we obtain a solution of the 
equation (9.4): 

FAC = YH. 

During a performance of this solution a rather general method is used. 
It is based on the principal in a theory of recursive computations fixed 
point theorem (see Theorem 9.1). In fact, it was given its particular 
"proof" for the function FAC. The obtained solution gives the non- 
recursive definition of FAC. An essence of the fixed point theorem is 
namely in a assuring the transition from recursive in its notations def- 
initions to non-recursive in its notations definitions. In the last case 
an effect of cycling in the definition (and corresponding computation) 
is hidden by the combinator Y. 



Chapter 9; Applications of fixed point combinator Y 127 

Example 9.2. To get assured, that thus defined function FAC prop- 
erly works, let's apply it to some argument, e.g., to 1: 



FAC l = Y Hl = H(Y H)l {FAC),{Y) 

= {Xfac.Xn.IF{= n 0)l(xn(/ac(- n 1)))){Y H)l (H) 

= {Xn.IF{= n 0)l{xn{{Y H){-n 1))))1 (/?) 

= IF{= 10)l{xl{{YH){-ll))) {(3) 

= xi((y_ff)o) = xi{ H{Y H) {)) (y) 

= xl((A/ac.An./F(= n 0)l(xn(/ac(- n 1))))(F H){)) (H) 

= xl{{Xn.IF{= n 0)l(xn((Y H){-n 1))))0) (p) 

= xlllF{= 0)l{xO{Y H{-0 1)))) 1(3) 
= xl 1 
= 1. 



9.4 Evaluation of a function 



Consider the examples of definitions for most often used in practice 
of programming functions. Note, that for simplicity, the functions, 
which use lists as their arguments, are selected out. As usually, the 
list is understood as a finite sequence. 



Task 9. 1 . Using the fixed point function Y, express the definitions of 



128 



Chapter 9; Applications of fixed point combinator Y 



the following functions: 



2) 



sum 



3) product 



4) append = 



5) concat = 



6) map 



Xx.if null X 
then 

else (car x) + sum{cdr x), 
Xx.if null X 
then 1 

else {car x) x product{cdr x), 
Xx.Xy.if null x 
then y 

else {list{{car x){append{cdr x)y)), 
Xx.if null X 
then 

else append{car x){concat{cdr x)), 
Xf Xx.if null X 
then 
else list{{f{car x)){map f{cdr x))). 



Iength(ai,a2,as) = 3; 
sum(l,2,3,4) = 10; 
product{l,2,3,4:) = 24; 
append{l,2){5,4,5) = (1,2,3,4,5); 
concai((l,2),(3,4),()) = (1,2,3,4); 
map square (1, 2, 3,4) = (1,4, 9, 16). 

For examples of "calls" of each of the functions perform its checking. 

Starting up to work with lists, it is possible to estimate the abil- 
ities of the programming system Lisp'. This system makes no dis- 
tinction between "programs" and "data": both of them are the objects 



In its ground Lisp lias, practically, all the abilities of untyped lambda-calculus. 
Depending on a dialect in use, the outer notation of the objects can be varied. Pay 
attention one more, that this language has no operators. The only kind of its objects 
in use are the functions. The implemented mechanism of recursion from a mathe- 
matical point of view illustrates an effect of the fixed point computations. Usually, 
a language is supplied with the additional non-recursive means of organizing the 
cycled, or iterative computations. 



Chapter 9; Applications of fixed point combinator Y 129 

on equal rights. A great interest to the programming system Lisp is 
completely justified. Having clear and short mathematical founda- 
tions, this programming system overcomes a barrier between a prac- 
tical program encoding of a task and its mathematical understanding. 

Solution. As an example, give the corresponding computations for 
the function length (getting the length of a list) and map (the func- 
tional, "distributing" an action of function-argument along the list). 
During the evaluation of these functions, the main features of recur- 
sive computations over lists reveal. 

length— 1 . For the function length its initial definition 

length = Xx.if null x 
then 
else 1 + length{cdr x), 

is to be re-written as: 

length = (Xf .Xx.if null x 
then 
else 1 + f{cdr x))length. 

length— 2. It follows from this, that 

length = Y{Xf .Xx.if null x 
then 
else 1 + f{cdr x)). 

Thus, an awaited combinatory characteristic is derived. 

length— 3. Make a checking of the definition for list of length 



130 Chapter 9; Applications of fixed point combinator Y 



2, i.e. let x = (ai, 02): 

length{ai, 02) = Y{XfXx.if null x 

then 

else 1 + f{cdr x)){ai, 02) 
= {XfXx.if null X 
then 

else 1 + f{cdr x)){Y{. . .))(ai, 02) 
= i/ null (ai, 02) t/ien else 1 + (F(. . .)){cdr (ai, 02)) 
= l + (y(...))(cdr(ai,a2)) 
= 1 + {XfXx.if null X then 

else 1 + f{cdr x)){Y{. . .)){a2) 
= 1 + if null (02) t/ien else 1 + (y(. . .)) nil 
= 1 + {! + {¥{...)) nil) 
= ! + (! + (XfXx.if null x then 

else 1 + f{cdr x))(Y{. . .)) nil) 
= l + (l + (0)) = 2. 

map— 1 . For the function map its initial definition 

map = Xf.Xx. if null x 
then 
else {f(car x)) : (map f{cdr x)) 

is to be re-written as: 

map = (Xm.Xf.Xx.if null x 
then 
else {f {car x)) : {mf{cdrx))) map. 

It follows from this, that 

map = Y{Xm. Xf.Xx. if null x 

then 
else (f{car x)) : (m f{cdr x))). 



Chapter 9; Applications of fixed point combinator Y 131 

Checking. Checking for/ = square, x = (2,3) (outline): 

map square (2, 3) = 

= {XmXfXx.if null x 
then 
else {/{car x)) : {m f{cdr x))){Y{. . .))square (2, 3) 



= {square 2) 

= {square 2) 

= {square 2) 

= {square 2) 

= (4,9). 



{{¥{...)) square {3)) 
{{Xm.Xf.Xx. . . .){¥{. . .)) square (3)) 
{{square 3) : {{¥{■ ■ .)) square ()) 
{{square 3) : ()) 



In this case the symbol ':' is used to denote an infix form of the 
function list, therefore, as a notational agreement, is accepted, that 
x:{y:{z: ())) = {x,y,z) = {x,y,z). 



Exercises 

Exercise 9.1. Write a function, implementing the algorithm of dis- 
assembling into basis /, K and S. 

Hint. As known, all the A-terms can be avoided by replacing with the 
constructions, formed of combinators /, K and S, and combinator / 
can be replaced by the construction SKK. 

The function, forming a combination, can be denoted, e.g., by 
combine. Now, for instance, the function, which eliminates the iden- 
tifier x from an expression E, can be determined in a form of self ref- 
erencing definition. Next, using a fixed point theorem, this definition 
can be transformed to a standard form by eliminating an occurrence 
of extract from the right part of the definition: 



132 Chapter 9; Applications of fixed point combinator Y 

def rec extract x E 

if identifier E 
then if E = X 
then 'I' 

else combine 'K' E 
else if lambdaexp E 

then extract x (extract (bv E) (body E) ) 
else let F = extract x (rator E) 
let A = extract x (rand E) 

combine 'S' (combine F A) 

Exercise 9.2. Write the program, which transforms a A-term into 
combinatory form, checking the occurrence of a variable in the oper- 
ator or operand: 

1 ) if the operator does not depend on x, then combinator B is 
introduced: 

Bfgx= {f){gx); 

2) if the operand does not depend on x, then combinator C is in- 
troduced: 

Cfgx = {fx)g; 

3) if neither operator, nor operand does not depend on x, then the 
combinator is not introduced: 

fg = if)igy, 

4) \fg = /, then 

Sfix = (fx)(Ix) = fxx = Wfx, 
Bfix = {f){Ix) = fx; 

5) if/ = X, then 

SKgx = {Kx){gx) = Ix, 
CKgx = {Kx){g) = Ix. 

Hint. See, for instance, [T)], p. 45-46. 



Chapter 10 

Function listl 



This chapter describes the abilities of constructing a parameterized 
function-object. Assigning the particular values to the arguments — 
and, as this particular value, can be the functions, — a whole family of 
definitions of particular functions can be derived. 



10.1 Theoretical background 

The function listl is defined as follows: 

listl a g f X = if (null x) 
then a 
else g{f{car x)){listl a g f{cdr x)). 

This is a sample of a function of rather general kind, from which, 
given a particular value of parameters, the whole sequence of "sim- 
pler" functions can be generated. It could be noted, that many of 
functions, acting over the lists, have some "shared part". A question 
is, if is it possible for the class of functions over lists, to determine 
such a generalized function, from which, by different choice of pa- 
rameters, the particular representatives of the class of functions can 

133 



134 



Chapter 10: Function Zjstl 



be generated. As one of such generalized functions, the function listl 
is presented below. 

The main construction in use is a list, which can be either empty 
or non-empty. In the last case it has a "head" and "tail", which, in 
turn, can be the lists. The following operations can be performed over 
lists: 



null 
car 
cdr 
list 



list -^ boolean, 

non-empty list -^ (list + atom), 
non-empty list -^ list, 
(atom + list) -> (list -> list). 



These operation are interrelated as follows: 

null = true, 

null {list X y) = false, 

car {list X y) = x, 

cdr {list X y) = y, 

list {car z) {cdr z) = z. 

In addition, use an abbreviation: 

list X y = X : y, 

and, thus, forn > 2 apply this agreements to the construction below: 

{xi, X2, X3,..., Xn) = XX : {xi : {x-i :{... Xn) :.■.{). . .))• 



10.2 Tasks 

Task 10.1. Study the properties of the function 
listl a g f X 



if {null x) 

then a 

else g{f{car x)){listl a g f{cdr x)). 



Chapter 10; Function Zistl 135 

Using the following definitions: 

Ix = X, Kxy = X, postfix x y = append y (ux), 



where (ux) is a list, which contains a singular element x, express the 
following functions: 



(a) length, sunisquares, reverse, identity; 



(b) sum, product, append, concat, map. 



Task formulation. Use the following definitions of the functions: 

(a) ux = X : {), 

length x = if null x then else 1 + length (cdr x), 

sunisquares x = if null x 
then 
else{square{car x)) + sum squares {cdr x), 

reverse x = if null x then () 

else append{reverse{cdr x)){ux), 

identity x = x, 

square x = if null x then else x x x; 



136 Chapter 10: Function Zjstl 

(b) sum X = if null x 
then 
else {car x) + sum{cdr x), 

product X = if null x 
then 1 
else {car x) x product{cdr x), 

append x y = if null x 
then y 
else list {car x){append{cdr x)y), 

concat X = if null x 
then 
else append{car x){concat{cdr x)), 

map f x = if null x 
then 
else {f{car x)) : {map f{cdr x)). 

Perform steps of the algorithms for the following samples: 

sum (1, 2, 3, 4) = 10, 

product (1, 2, 3, 4) = 24, 

append {1,2) {5, 4, 5) = (1,2,3,4,5), 

concat {{1, 2), (3,4), ()) = (1, 2, 3,4), 

map square {1, 2, 3, 4) = (1, 4, 9, 16). 

Solution. Assume, that 

postfix X y = append y{ux). 

listl—l. Consider case (a): 

length = listl plus {K 1) , 

sumsquares = listl plus square, 

reverse = listl { ) postfix I, 

identity = listl { ) list I. 



Chapter 10; Function Zistl 137 

listl—2. Consider case (b): 



sum = 


= listl plus I, 


product = 


= listl 1 multiply I. 


append x y = 


= listl y list I X, 


concat = 


= listl ( ) append I, 


map f = 


= listl ( ) list f. 



To complete this solution, we need to substitute the parameters 
and perform the detailed computations. In addition, it is assumed that 
the steps of checking the samples should be performed. 



10.3 Functor-as-object 

Concluding, pay your attention to some features of the method of 
solving the task. First of all, the function listl is a functional (and 
even a functor). Having defined this function, actually, a significantly 
more volume of job, than needed, was performed. More precisely, 
listl reveals a significant dependency on parameters: varying the pa- 
rameters, we result in a whole family of particular functions, every of 
which has a rather general presentation. By these means, a definition 
of listl establishes a notion, or concept. As a concept is given by 
the description, then the intensional is determined. Selecting out 
different values of parameters, or referencing the assignments, ac- 
tually, we obtain a whole family of individual functions. Counting the 
elementsof this family, we obtain an ex/e«s/o«a/ of the concept listl. 

The functions, similar to listl, represent in programming an im- 
portant idea, which has a distinctive name 'functor-as-object'. As 
could be seen, a program, composed of such objects, has a high de- 
gree of generality. 



138 Chapter 10: Function Zjstl 

Exercises 

Exercise 1 0. 1 . Determine the types of arguments of listl. 

Hint. Consider a definition of listl and will carry it into effect step by 
step. 

1 ) Apply the function (listl a g f) to a list. Assume, that it has 
the following structure: 

list either is an empty element (null), or has a first 
element (head) and the rest of elements (tail), which, 
in turn, is a list . 

Assume, that this list has a type A. Thus, 

(listl a g f) € (A^ B); 

2) conclude, that arguments a should be taken from B; 

3) the function / is applied to elements of A, and its values range 
C: 

f€{A^ C); 

4) thus, the function g should be applied to elements of C, and an 
effect of applying (listl a g f) to elements of A ranges B; from 
this it follows, that 

geiC^iB^ B)). 
More details of analysis see in [ ], p. 1 1 0- 1 1 1 . 



Chapter 1 1 

Isomorphism of c.c.c. and 
ACS 



In this chapter we start to move deeper in the mathematical abstrac- 
tions and will conform the operator thinking to combinatory thinking. 
Note, that there is the only operator in combinatory logic — operator 
of application, or the operator of acting of one object on another. 
The induced system of computations is called the applicative com- 
putational system, or ACS. This system conforms to a traditional 
operator computational system, which is represented by a special ob- 
ject — the cartesian closed category, or c.c.c. 



11.1 Theoretical background 

An idea of constructing a functional language, which contains no 
variables, is based on using of combinatory logic. Refusing of vari- 
ables, a developer of programming language begins to use in opera- 
tions arbitrary objects, which, in constructing a program, are allowed 
to be applied to each other. Evidently, this is the most purified form of 
using the objects. 

139 



140 Chapter 1 1 ; Isomorphism of c.c.c. and ACS 

As known, for proper using the objects, it is needed to stay within 
some variant of combinatory logic, which plays a role of shell theory. 
A set of combinators from this shell forms the "set of instructions" 
of an abstract computational system. It seems, that this set is not 
restricted by anything. In this case its mathematical properties stay 
unrevealed and potentially contain some form of contradiction. 

Select as a shell theory the category theory. Fix in it a set of com- 
binators, which have completely safe mathematical behavior: produce 
a cartesian closed category. Note, that in a cartesian closed cate- 
gory (c.c.c.) the functions are understood as operators, acting on 
its operands, which are written by positions. On the other hand, in 
applicative computational system there is the only operation — oper- 
ation of application, which is interpreted as an acting of one object to 
another. The question is, are there any losses as a result of transition 
from a system of notions and definitions of c.c.c. to the system of 
notions and definitions of ACS and visa versa. 

Use the following notational agreement: 

[x,y] = Xr.rxy, 
<f,g> = Xt.[fit),git)] = Xt.\z.z{f{t)){g{t)). 

The fact, that / is a mapping from Aio B (in an intensional sense) is 
denoted hy f : A ^ B. Take into use the following mappings: 

h:A X B -> C x: A,y : B, 
AABch:A^{B^C), 
Aabc :{A X B^C)^{A^{B^ C)), 
k:A^{B^C), 
£Bc:{B^C) X B^ C, 
so < k op,q > : A X B —> C, 

p : A X B ^ A, q : A X B —^ B. 

In the following these mappings will often be used without explicit 
indication of their types, only if there is no ambiguity in reasoning. 



Chapter 1 1 ; Isomorphism of c.c.c. and ACS 141 

11.2 Tasks 

Task 11.1. As in the Karoubi's shell it is derivable, that: 

h = £o < (Aft.) op, g >, 

and is derivable: 

k = A(eo < fc op, g >), 

then, first of all, from the previously given definitions it is needed to 
derive both of the equalities by yourself. 

Solution. 

A— 1 . At first, show, how to construct a translation of expres- 
sions from operator form to applicative one, i.e. find such a 
function h' , that h[x,y\ = h'xy. This can be obtained in the 
following way: 

h = eo < (Ah) op, q >; 

Hx,y] = {£bco < {^h)op, q>)[x,y] 

= eBc{< {^h)op, q> [x,y]) 

= £Bc[{{^h)op)[x,y], q[x,y]] 

= £Bc[{^h){p[x,y]), q[x,y]] 

= eBc[iiAh)x),y] 

= {{{Ah)x)y) = khxy 

= h' X y. 

The computations above need in proper type assignment for the 
objects' . Hence, h' x y = {kh)x y. 

A— 2. At second, show, how to construct a translation from 
applicative form to operator form, i.e. find the function k' such. 



'The expression {{Kh)x) has the type B ^> C . The expression y has been 
assigned type B. The expression {{{h.h)x)y) obtains the type C . 



142 Chapter 1 1 ; Isomorphism of c.c.c. and ACS 

thai k X y = k'[x, y]. This can be obtained in the following way: 

k = A{eo < k o p,q >)■ 

kxy = A{eo < k op,q >)xy 

= {Xu.Xv.{eo < k o p,q >)[u, v])xy 

= so < k op, q > [x,y] 

= k'[x,y]. 

Thus, k' = so < k o p, q > and AA;' = k. It is left to note, 
that by '=' is denoted the relation of ^^(^-convertibility: it is reflective, 
symmetric and transitive. Hence, it is a relation of equivalency. The 
last circumstance allows to make a conclusion, that 

(A X B ^C) ^ {A^{B ^ C)), 

where symbol '=' is to be read as 'isomorphic'. 



Chapter 12 

Currying 



The n-ary functions-operators, used in an operator programming, in 
the combinatory logic have the images as the objects, which inherit 
all their essential properties. 



12.1 Theoretical background 

12.1.1 Operators and functions 

In a programming, it is often needed to establish a distinction be- 
tween the notion of 'operator' and the notion of 'function'. In the 
first case the algebraic ideas are followed, when any operator is in 
advance assumed to have arity (the known number of arguments, 
called operands). This number of operands is known beforehand, 
and it is connected with a kind of particular operator. The arity also 
reveals itself in a manipulation with the functions, which though have 
an arbitrary character, but for every of them its number of arguments 
is known in advance. This is an old traditional way to consider the 
computations and creation of calculi. A relative opposing the symbol 
of function or operator, on one hand, to the symbols of arguments on 
other hand, is put in its basis. It is assumed silently, that the objects 

143 



144 Chapter 12: Currying 



do exist, but they are not on equal rights: the objects-operators are 
used by separate rules, and objects-operands — by other. The most 
often assumption in use deals with a replacement of one objects by 
others. In a framework of first order formalizations, the operands can 
be replaced by other objects, while operators can not. All of this has a 
sense of restriction, laid on the substitution in this systems. The first 
order systems are called the systems with a restricted principle of 
comprehension, because a particular accepted definition of substitu- 
tion operation implements and idea of comprehension. 



12.1.2 Comprehension 

During the manipulation with arbitrary in reality functions, the rea- 
soning concerning the computations should be carry out in terms of 
applying a symbol of function to the corresponding symbol of argu- 
ment. Even more homogeneity in treating the functions and argu- 
ments can be achieved, if consider them as objects — without any 
additional reserve, — and reduce the study of a computation process 
to reasonings of acting (applying) of one object to another. In this 
case it is possible do not superimpose the burdensome restrictions on 
executing of a substitution, that gives rise to higher order formalisms. 
In case the order of such a theory is not restricted, then this is a theory 
with unrestricted principle of comprehension. 



12.1.3 Connection between operators and functions 

The disparate connections between both of the kinds of systems can 
be established, revealing the potential possibilities of both the ap- 
proaches. In particular, consider a question, how by means of ACS 
(using operators of application and abstraction), to express an inten- 
sional representation of 2-ary, 3-ary, . . ., n-ary functions, considered 



Chapter 12; Currying 145 

as operators. Use the following notational agreement: 

[x,y] = Xr.rxy, 

h : A X B ^ C, 
Curry ABC : {A x B ^ C) ^ {A ^ {B ^ C)). 

Hence, h is assumed to be the usual two placed operator, while 
Curry is a transformation from operator to applicative notation' : 

Curry ABch = \xy.h[x,y\, 
\xy.h[x,y] : A^{B^C). 

12.2 Tasks 

Task 12.1. Consider a family of functions h: 

h2:AxB^C, 

hs-.AxBxC^D, 

hiiAxBxCxD^E, 



Find the family of mappings: 

CurryABC, Curry(^AxB)CD, Curry(^AxBxc)DE, ■■■, 

which make currying of these functions, i.e. transform them into an 
applicative form. 

Solution. As an example, consider the currying of h^ and h^ . 

Curry— I. Indeed, let hs : {A x B) x C ^ D. Then 
A{Axb)cd/i3 = Xxy.h3[x,y] : A x B -> {C -> D). Now 
it can be assumed that A(^ xB)CDh3 = h'2, and therefore the 



In theoretical studies, instead notation of 'Curry is often used the notation 'A'; 
thereafter this last notation will be used. 



146 Chapter 12: Currying 

next idea is to replace the first variable by the ordered pair of 
variables, i.e. 

= Aui;.(A(^x B)CDh?,)[u,v] 

= \uv.{\xy.hs[x,y\)[u,v\ 

= \uv.{\y.h3[[u,v],y]) 

= \uvy.{h^[[u,v]M)-A^ {B^ {C^ D)) 

= i^AB(C^D) ° ^{AxB)Cd) ^3- 

Curry— 2. Let now h^ : AxBxCxD—>E, where it is 
assumed, that 

yl X B X C X D = (^ X B X C) X D = ((^ X 5) X C) X 13. 

Then consider the transformation of currying step by step. 
Step 1 : 

\{AxB)xc)DEhi = Xxy.hi[x, y] : {{A xB) xC) ^ {D ^ E). 
Step 2: 

^{{AxB)C{D^E){^{{AxB)xC)DEh'4) = 

= Xuv.{A(^^axb)xc)deIT'4)[u,v] 

= Xuvy.h4[[u,v],y] : A x B -> {C -> {D -> E)). 

Step 3: 

^AB{c^ [D^ E){Xuvy.h4[[u,v],y]) = 

= \xy.{\uvy.hi[[u,v],y])[x,y] 
= \xyvy.h[[[x,y],v],y]. 

In discussingthe solution, obtained in (Curry- 1) and (Cnrrj/-2), 
it could be noted, that the currying functions are as follows: 

^(AxBxC)DE = ^AB{C^(D^E)) ° ^{AxB)C{D^E) ° ^{AxB)xC)DE- 



Chapter 12; Currying 147 



For a purpose of finding out the solution in a general case, rewrite this 
equality as follows: 

A(AixA2X/l3)A4B = 

= Aai/12(A3^{A4^-B)) oA{AixA2)/l3{A4^-B) °^i{AixA2)xA3)A^B- 



Exercises 

Exercise 1 2. 1 . It is left to the reader to derive corresponding equality 
for n-ary functions. 

Hint. This can be done by induction on the number of argument 
places. 

Exercise 12.2. Establish a connection between carried and uncur- 
ried functions. 

Solution. For any function 

f:[DiXD2X---xDr^]^D 
there is a curried function, which is equivalent to this function 

Curry f : D^ ^ [D2 ^ [. . .[D^ ^ D] . . .]] 
Using the A-notations, it is not difficult to conclude, that 

Curry f = XxiX2 . . .Xn.f{xi,X2, . . . ,Xn) 

Next, Curry, in turn, is a higher order function: 
Curry : [[Di x D2 x ■ ■ ■ x D^] -> D] 

Curry = \f.\x1X2 . . . Xn.f{xi,X2, • . • , a;„) 

= XfxiX2...Xn.f{xi,X2,...,Xn) 



148 Chapter 12: Currying 

Example 12.1. 

plusc = Aa;ia;2. + a;i a;2 

= XxiX2.plus{xi,X2) 

= {Xf.XxiX2.f{xi,X2))pluS 
= {XfxiX2.f{xi,X2))pluS 

= Curry plus 

For the function Curry it can be possible to find the unCurry 
with a reversed effect: 

unCurry : [Di -^ D2 -^ ■ ■ ■ ^ D^ -^ D] 

-^ [[Di xD2X---xDn]^ D] 
unCurry = Xf.X{xi,X2,...,Xn).fxiX2...Xn 

Example 12.2. 

plus = A(a;i,a;2). + [a;i,a;2] 

= X{xi, X2). plusc Xl X2 

= {Xf.X{xi,X2).fxiX2)pluSC 

= unCurry plusc. 

This example is generalized without any difficulty and results in 
the following. 

Statement 12.1. U Curry h = fc, then: 

unCurry{Curry h) = h 
Curry{unCurry k) = k 



Chapter 13 

Karoubi's shell 



A special category, called Karoubi's shell, allows laconic expression 
of all the available knowledge store, concerning operators, in terms 
of combinatory logic. In addition, the types are also encoded by the 
objects. By this way an embedding of typed application into type free 
programming environment is performed. 

13.1 Theoretical background 

A research work in programming often starts with a choice of the host 
theory, i.e. the shell theory, within which it is suitable to represent 
and study newly constructed mechanisms. By need of establishing 
and support of type system, a necessity of using such a shell theory 
arises, that allows to establish and consider various ideas, concerning 
the types. Possibly, within a shell it is better to avoid any a priori idea 
of types. In other words, a type free theory arises to deal with, and a 
good sample of this kind is the untyped A-calculus. 

In this chapter the establishing of connection of category theoretic 
notions with the notions of untyped A-calculus is studied. Let £ be 
a set of the terms of some calculus of A-conversion. Karoubi's shell 
for £, denoted by C(£), will be assumed to be a category, defined as 

149 



150 Chapter 13; Karoubi's shell 

follows. Let 

ao b = Xx.a{bx) 

for a, b belonging to £, where 'o' is a sign of composition of the 
functions. 

In addition, use the following notations: 

{a £ £\ao a = a} — set of objects in a category, 
{/ G £|6 o / o a = /} — set of morphisms, Hom{a, b), 
id — identity morphism, id a = a 
fog — composition of morphisms. 



13.2 Tasks 

Task 13.1. Show, that C(£) is a category. This is left to verify by 
the reader, making a concordance with any form of definition of a 
category. 

Task formulation. Assume the following definitions, needed for 
studying the objects. Remind, that in this case the necessity of 
carrying out the following equalities is presupposed: 

A=Xx.A{A{x)) =AoA, (A) 

F=\x.B{f{A{x))) = BofoA. (/) 

1. Cartesian product: 

A -K B = XuXz.z{A{u{XxXy.x))){B{u{Xxy.y))). 

2. Projections onto the first and second element respectively: 

Pab = Xu.{A X B){u){XxXy.x), pab : A x B ^ A; 
QAB = Xu.{A X B){u){XxXy.y), qab :AxB^B. 



Chapter 13; Karoubi's shell 151 

3. Couple of functions: 

<f,g>= \t\z.z{f{t)){g{t)) = \t\f{t),g{t)], 
f:C^A, g:C^B, < f,g >: C ^ (A x B). 

4. A set of mappings (a functional space): 

(A^ B) = Xf.BofoA. 

5. Application (acting by a function on an argument): 

ebc = Xu.C{u{Xxy.x){B{u{Xxy.y)))), 
£BC : {B ^ C) X B ^ C. 

6. The function of currying, i.e. the translation of the "usual" 
functions into applicative form, is called in honor of H.Curry 
(Remind one more: this function is often denoted by 'Curry ; 
in the current context it is assumed, that Curry = A, i.e. the 
currying function is denoted by 'A'): 

^ABch = XxXy .h{Xz .z{x){y)) , 
h:{AxB)^C, AABch : A ^ {B ^ C). 

It is needed to prove the following: 

• Properties of the projections: 

Pabo < f,g >= f, qabo < f,g >= g, 

< PAB o h, qAB oh>= h. 

• Lei h: {Ax B)->C, k : A -^ {B -> C). Then 

eo < (Ah) o p,q >= h, 
A(eo < k o p,q >) = k, 



152 Chapter 13; Karoubi's shell 



where A = Kabc, P = Pab , e = £bc, q = Qab- 

Solution. A proof is reducible to the verifying the properties of the 
introduced objects. 

C(£)— 1 . Note, that the mapping h : (AxB) ^ C has a trans- 
lation into the term of A-calculus, with the following equality: 

h = Xx.C{h{{A X B){x))), 

where x = [xi,X2]. This is an immediate corollary of the equal- 

ity(/). 

C(£)— 2. Determine a combinatory characteristic h: 

h[xuX2] =CihiiAxB)[Xi,X2])) 

= C{h{Xz.z{A{[xi,X2]K)){B{[xi,X2]iKI))))) 
= C{h{Xz.z{A xi){B X2))) = C{h[A xi,B X2]). 

Thus, h[xi,X2] = C{h[A xi, B X2]). 

C(£)— 3. Again, pay attention to a necessity of taking into ac- 
count the following equalities: 

X = Xz.a{x{l z)) = Ao X, 
f = Xz.BifiAz)) = BofoA, 

where 1 = Xy.y = I. 

C(£)— 4. It is not difficult to see (prove yourself!), that 

{AxB) = Xu.[A{u K),B{u{K /))], 

where K = Xxy.x, I = Xx.x. Then a straightforward compu- 
tation gives the following combinatory characteristic of a carte- 
sian product: 

{A X B)[u,v] = Xz.z{A{[u,v]K)){B{[u,v]{K I))) 
= Xz.z{Au){B v) 
= [Au,Bv]. 



Chapter 13; Karoubi's shell 153 



C(£)— 5. Verification of properties of the projections leads to 
the following characteristics: 

Pab{[u,v]) = {Ax B)[u,v]K = [Au,Bv]K = Au, 
qabHu, v]) = {Ax B)[u, v]{K I) = [Au,B v]{K I) = B v. 

C(£)— 6. Considering the ordered pair [f,x], show how using 
the mapping sbc result in an application of / to x: 

eBc{[C o f o B,B o x]) = eBc{[f,x]) 

= C{[C ofoB,Bo x]K{B{[C ofoB,Box]{K /)))) 
= C{{CofoB){B{Box))) 
= C{f{Bx)) 
= {CofoB){x) 
= /(^)- 

Note a necessity of taking into account properties of a compo- 
sition.' Essentially, a simple equality: 

Kabc hxy = h{[x,y]) 

will be proved below (see chapter 12, where a currying function 
is defined). 

C(£)— 7. Let t be represented by an ordered pair, i.e. t = [^1,^2]- 
Then 

{so <{Ah)op,q>)t = e[{Ah){pt),qt] 
= e[{Xxy.h[x,y]){pt),qt] 
= e[{Xxy.h[x,y])ti,t2] 
= £[Xy.h[ti,y],t2] 
= (Ay./i[ti,y])t2 

= h[ti,t2]. 

This is a derivation of a characteristic equality: 
£o < {A h) o p,q >= h. 



' Remind, that Co f = f,Box = x. 



154 Chapter 13; Karoubi's shell 

C(£)— 8. Now derive the second characteristic equality, where 
#(ti) = A, #(t2) = B, #(t) = A-K B,anAt= [ti, t2], i.e. t is 
represented by an ordered pair; by '#' the function of 'evaluating 
the type' is denoted: 

A(eo < kop,q >)ti t2 = (eo < k op,q >)([ti,t2]) 
= e[k{pt),qt] = e[kti,t2] 
= {Xu.C{uK{B{u{K I)))))[kti,t2] 
= C{kti{B{t2))) 

= C{ktit2) 

= kti t2. 
By this^ the characteristic equality 

A(eo < k o p,q >) = k. 
is proved. 

All the introduced equalities actually take place, and this com- 
pletes a proof. 

Exercises 

Exercise 13.1. Give the representation of a metadata object, using 
combinators. 

Solution. Assume, that a reader is familiar with the technique of 
variable objects (see, e.g., chapter 23 of the current volume). The 
constructing of metadata object will be done step by step, using a 
comprehension principle. 

( 1 ) Using a comprehension. For given the data objects, a compre- 
hension generates the metadata object. Next, a superscript is used 
for indicating a relative level of generality. Thus, metaobject of level 



"Take in mind, that B(t2) = ^2- 



Chapter 13; Karoubi's shell 155 

J + 1 is generated by the objects of level j. Note, that comprehension 
involves the description, so that metaobject z^^^ is identified by 3;-'+-^. 

j'+l times j times 

(2) Encoding a comprehension. Let be the following: 

• truth values [ ] represent a variable domain; 

• the function <? is a predicate function g : U ^ [] = [U], hence, a 
predicate concept is the object 

c = XA.Xg.x"^ ogo A G [W]; 

• j-th concept is determined by the following: 

x^ =lz^ : [...[D]...]\/x^-^ : [. . . [ D] . . .]{z\x^-^) '^ ^^-^) 

j times j—1 times 

= {x^-^ I $^'-1} 

C {x^-^ I 2;^-i : A -> x^} 

= H,,{A)^[UU 

• variable domain ^A]a is encoded by the expression 

Xg.x-'^ o g o A] 

• augmenting by the 'instances of a time' results in: 

c = XA.{{\h.[ ]ohoA)oco {Xx^-\x^ o x^-^ o A)); 

[]a l^A 

(3) The final steps of encoding. To complete the encoding of com- 
prehension, assume the following: 

• fixing A and varying the parameters /, B results in a predicate 
concept 

c £ [U]a, Cf c Kb; 



156 Chapter 13; Karoubi's shell 

• data object Cf is defined as a variable predicate 

Cf^{t€UB\ [t/x^-']{\\^' \\f (B))} 

for the evolvent f : B ^ A; 

• metaobject cj is encoded by 

Cf G Xc.[U]bo{co f)oB. 

Note. The usage of Karoubi' shell attracts the same ideas as the considered 
in chapter 10 in analysis of function list!. Actually, A-calculus gives a wide 
range of various terms. Among them, only those are selected, a syntax 
form of which is specially restricted. A set of these restrictions, listed in the 
beginning of the current chapter, determines an assignment. A type free 
A-calculus is taken as a concept theory (general shell), which is observed 
as a computation theory. As a result of its applying to the assignment, 
an individual theory is generated, which in turn has the properties of a 
shell. In particular, a special class of computations — categorical compu- 
tations, — are representable within it. In this case a question of comparing 
the expressive power of the concept theory and the individual theory has a 
mathematical nature. 



Chapter 14 

Products and projections 



A finalization of the started process of embedding can be achieved by 
introducing the ordered tuples of objects. As turns out, the applicative 
computations permit to get their representation. 

14.1 Theoretical background 

A problem of embedding the objects of one theory into other theory 
arises in considering the intensionally determined mappings, when it 
is needed to perform their translation in applicative (functional) lan- 
guage. 

To fulfil this task, a small store of given definitions is needed: 

K = Xxy.x, I = Xx.x, [x,y] = Xr.rxy 

(ordered pair). 

14.2 Task 

Task formulation. Obtain the term of A-calculus, corresponding to 
a cartesian product of n objects. In addition, determine such n terms, 

157 



158 Chapter 14: Products and projections 

that are the projections. 
Hint. In case of n = 2 obtain 

AqxAi = \u.[Aq{uK),Ai{u{K I))], 

ttq = \u.{Ao X Ai){u)K, 

Til = \u.{Ao X Ai){u){K I). 

Solution. First of all we will try to find out a regularity in constructing 
the term. 

xvr— 1. Consider the case of n = 3. 

AqX Aix A2 = {Aq X Ai) X A2 

= \u.[{Ao X Ai){u K),A2{uiK /))] 

= \u.[{Xv.[Ao{v K),Ai{v{Kim{uK),A2{u{K /))] 

= \u.[[Aoiiu K)K),A,iiu K){K I))],A2{u{K /))]. 

Indeed, by a straightforward computations it can be derived, 
that 

{{Aq X Ai) X A2)[[xo,xi],X2] = [[^o(a;o),^i(a;i)],^2(a;2)]. 

To establish corresponding projections, let the following rather 
simple statement be formulated, and perform its verification. 

Statement 14.1. 

Til = \u.{Ao X ^1 X A2){u){K){K), 
^l = Xu.{Ao xAiX A2){u){K){K I), 

T\\ = \u.{Aq X ^1 X A2){u){Kl). 



Proof. 



Txl[[xo,Xi],X2] = [[XQ,Xi],X2]K K 

= K[xo,xi]x2K 
= [xo,xi]K 
= xo; 
nl[[xo,xi],X2] = [[xo,xi],X2]K{K I) 
= K[xo,xi]x2iK I) = xi; 

■kI[[xo,Xi],X2] = [[xo,Xi],X2]iK I) 

= {KI)[xo,Xi]x2 = I X2 = X2. 



Chapter 14; Products and projections 159 



Indeed, for a kind of projection, defined above, the family of 



objects vr^, j = 0, 1,2 has a behavior of projections. D 



X vr— 2. Consider the case of n = 4. 

Aqx Aix A2X A3 = {Ao X Ai X A2) x A3 

= Xu.[{Ao xAiX A2)iu K),A3{uiK I))] 
= \u.[[[Ao{{{uK)K)K),AiiiiuK)K)iK I))], 
A2{{uK){KI))],As{u{KI))]. 

Statement 14.2. 

4 = Xu.iAo xAixA2X A3){u){K){K){K), 
t:\ = Xu.{Ao xAixA2X A3){u){K){K){K I), 
7r| = \u.{Aq X ^1 X yl2 X A3){u){K){K I), 
7r| = Xu.{Ao X ^1 X yl2 X A3){u){K I). 

Proof. 

7r^[[[a;o,a;i],a;2],a;3] = [[[xo,xi],X2],X3]K K K = xq, 
7ri[[[a;o,a;i],a;2],a;3] = [[[xo,xi],X2],X3]K K{K I) = xi, 
7r|[[[a;o,a;i],a;2],a;3] = [[[xo,xi],X2],X3]K{K I) = X2, 

n^[[[xo,Xi],X2],X3] = [[[xo,Xi],X2],X3]{K I) = X3. 



Now a generalization of the product will be done. 



D 



Statement 14.3 (generalization) . By induction it can be 
proved, that: 

vTo = /, TTo = \y.y K, m = \y.y{K I); 

<+i = Xy.y{K /), i < 1; vr^+i = ttJ o tto,0 < j < n - 1. 

Proof. Left to a reader. D 



160 Chapter 14: Products and projections 

Hint. List some considerations, concerning the proof of gener- 
alization. The particular cases: 

n = 1 (ordered 2-tuples). 

TT^ = TTl, TTq = TTq O TTq = / O VTo = TTq. 

n = 2 (ordered 3-tuples). 

A = ^y-y{Ki) = vri, 

7rf = 7rf OTTO = TTl OTTO, 

^0 = ^0 ° 'I'O = TTq O Vro O TTQ. 

n = 3 (ordered 4-tuples). 

7^3 = TTl, 

7r| = 7r| O TTo = TTl O TTq , 

^1 = TT^ O TTo = Tr;^ O TTo O TTo = TTl O TTq O TTo, 

TI'O = ^0 ° 7^0 = TTq O vro O TTo = TTq O TTQ O TTQ O TTQ 

= vro o TTQ o vro . 

Particular cases of projections of cartesian product in a trans- 
formed form are as follows: 

n = 2. 

T,l = \y.y{KI), 
TTq = Ay.y K. 

n = 3. 

Trf = Xy.yiKI), 
71"? = Ay. TTl (vro y) 

= Xy-T^iiyK) 

= Xy.{y K){K I), 
TTq = Ay.7ro(7ro y) 

= Xy.TTo{y K) 
= Xy.{yK)K. 



Chapter 14; Products and projections 161 

n = 4. 

7r| = \y.y{KI), 

A = Ay.7ri(7ro y) = Xy.ni{y K) = \y.{y K){K I), 

TT]^ = Ay.7ri(7ro(7ro y)) = \y.TTi{7ro{y K)) 

= XyMiy K)K) = \y.y{{y K)K){K I), 
ttq = Ay.7ro(7ro(7ro y)) = Xy.iroiT^oiy K)) 

= Xy.MiyK)K) = \y.y{{yK)K)K. 

Non-formal consideration of the solved problem is reduced to the 
following reasons. Ordered n-tuples are well known, in particular, 
they are used to constitute the relations of a relational data base. 
Remind, that a data manipulation language of relational data base 
management systems deals with the sets of n-tuple as particular ob- 
jects, called relations. An often used query to data base is to cut the 
available relations, and can be reduced to projection operations. To 
execute these operations, the implemented query language is needed. 

In this case the ACS is used as a programming system. More 
exact reasoning assumes the assumptions, that, as a shell system, 
the Karoubi's shell is used (see chapter 13). Both the objects-as- 
products and objects-as-projections are built in this shell. In turn, 
they consist of the objects-as-combinators. The programming is per- 
formed completely in terms of objects. 

14.3 Product and cartesian closed category 

In this section restrict the consideration by giving the definition a 
cartesian closed category, or c.c.c. This definition is important for 
better understanding the matters, covered in chapter 1 1, to reading of 
which it is recommended to go back one more time. 

Let C be a category. The identity morphism of the object A will be 
denoted by idA- 

C is called a cartesian closed category, if the following condi- 
tions are valid: 



162 Chapter 14: Products and projections 

1 ) in C there is a terminal object T such, that for any object A £ C 
there is the unique morphism Ia '■ A ^ T; 

2) for any objects Ax^A^ G C there is the object A\ x A^, their 
Cartesian product, equipped with morphisms pi : yli x yl2 x 
Ai, the projections, such, that for any /^ : C ^ A^ for i = 1 , 2 
there is the only morphism (/i, /2) : C ^ A\ ^ Ai such, that 
Vi° (/i,/2) = !i\ 

3) for A,B £C there is the object B'^ G C, pota^er, B"^ = A ^ B 
with the morphism 

e = EAB : B''^ X A^ B, 

such, that for any f : C x A ^ B there is the only 

Af:C^ B^, 

satisfying the equality / = e o (A/ x id^i) . 

A discussion of fruitfulness of this definition needs to be familiar with 
the chapters 11-12, as well as with the chapters 19-22, in which 
one of the most promising applications of c.c.c. to constructing the 
abstract machine is given. 



Chapter 15 

Embedding Lisp into ACS 



Non-trivial application — significant and, essentially, complete frag- 
ment of the known programming system Lisp {List processing), — is 
embedded into an applicative computational system. 

15.1 Theoretical background 

One of the most difficult problems in developing the user (language) 
interface is in proper and suitable embedding of the application into 
programming environment. The application of an object approach, 
and, naturally, an object-oriented programming, as known, promote 
the success in its solving. In practice, a special set of the classes, 
which exports the methods for applied programs, is defined. 

In mathematic, this mode is known as an embedding, when in a 
host theory, named a metatheory, the objects, a set of which consti- 
tutes the embedded theory, are constructed. Metatheory is assumed 
as a shell, and the objects of embedded theory can be accommodated 
by need, without violating a framework of the metatheory. Consider 
a using of this method by example. As a metatheory, the type free 
combinatory logic will be used. It will be assumed as a shell of the 
objects. The system of objects with their characteristic equalities, 

163 



164 Chapter 1 5: Embedding Lisp into ACS 

which implement the interface of Lisp, i.e. constitute a functionally 
complete universe of discourse around the lists and atoms, will be 
used as an embedded system. By a list of objects, as usually, we mean 
a finite sequence of objects, among which the other lists can be. 

Language Lisp is, essentially, the type free language. Its main 
constructions are the same as the constructions of type free A-cal- 
culus. It is well known, that these constructions are expressible by 
means of combinatory logic. The aim of this study is to establish 
the combinatory characteristics of some functions of programming 
language. 

For this purpose, the ry^-calculus of A-conversions will be used. 
The postulates of a relation of conversion 'conv (denoted by the sym- 
bol '=') are listed below: 

(a) \x.a = Xz.[z/x\a^ (P) {Xx.a)b = [b/x]a, 

a=b - -^ 



ac = he ca = cb^ 

a = b; b = c a = b 

(r) (cr) (p) a = a 

a = c = a 



{f]) Xx.bx = b, X ^ b. (^) 



a = b 



Xx.a = Xx.b 



15.2 A main task 

Task 15.1. Using the combinators, represent the following set of 
functions of the Lisp-system: 

{Append, Nil, Null, List, Car, Cdr}. (Lisp) 

Task formulation. Consider the properties of these functions of Lisp 
language. 



Chapter 1 5; Embedding Lisp into ACS 165 



• A concatenation of two lists is constructed by the function 
Append. This function has a property of associativity: 

A ^ B ^ C = {A ^ B) ^ C, (Append) 

where A, B, C are arbitrary lists, symbol '-^' is an infix form of 
notation of the function Append. 

• Empty list is denoted by < > and is equal to the object Nil. 
Evidently, 



A^<>=<>^ A = A. {Nil),{<>) 



• The function Null recognizes an empty list: 



Null A= { h '[^ - ^'^' (Null) 

' 0, otherwise. 



• The function List constructs from atom a list of length 1: 

List X =< X >, (List) 

where x is an atom, and < xi, X2, ... , a;„ > is a list of length 
n. 

• The function Car selects the first element from a list: 

Car < xi, X2, ... , Xn >= x\. {Car) 

• The function Cdr deletes the first element from a list: 

Cdr < xi, X2, . . . , Xn >=< X2, ... ,Xn > ■ (Cdr) 



166 Chapter 1 5: Embedding Lisp into ACS 

Using these properties, the following axiom schemes are formulated: 

Append a (Append be) = Append{Append ab)c, ( 1 5. 1 ) 

Append Nil a = Append a Nil, (15.2) 

Null Nil = T, (15.3) 

Null{Append{Lista)b) = 0, (15.4) 

Car{Append{List a)b) = a, (15.5) 

Cdr{Append{List a)b) = b, (15.6) 

where a, 6, c are any objects. Prove, that the axioms (15.1 )—( 15.6) 
are derivable in ry^-calculus of A-conversion. 

Solution. Perform a successive translation of the intensional equal- 
ities (15.1)— (15.6) into the terms and formulae of combinatory logic. 

Lisp— I. It will be shown, that the function Append corre- 
sponds to the object B with a combinatory characteristic (B) : 
Babe = a{bc) (axiom scheme ( 1 5. 1 ) ): 

Ba{Bbe)x = a{Bbcx) (by (B)) 

= <Kcx)) (by(i?)) 

= Bab{cx) (by {B)) 

= B{Bab)ex. (by (B)) 

Using the rule of transitivity (r), it can be derived: 

Ba{Bbe)x= B{Bab)ex. 

In r/i^-calculus it is derivable, that for a variable x: 

ZlX = Z2X 
Zl = Z2 

or, in a linear notation, z^x = Z2X => zi = z^, i.e., assuming 



Chapter 1 5; Embedding Lisp into ACS 167 



zi = Ba{Bbc) Z2 = B{Bab)c, obtain the following: 

(1) zix = Z2X ^ Xx.zix = Xx.Z2X, (by(^)) 

(2) Xx.zix = zi, (by(??)) 

(3) zi = Xx.zix, (by (a), (2)) 

(4) Xx.Z2X = zu (by(T),(l),(3)) 

(5) Z2 = Xx.Z2X, (by(??)) 

(6) z, = Z2. (by(T),(4),(5)) 

Thus, the axiom scheme ( 1 5. 1 ) is verified. 

Lisp— 2. The axiom scheme ( 1 5.2) will be proved, taking, that 
Nil ^^ / is valid' , while (/) : la = a. 

Blax = I{ax) ( by (S)) 

= ax (by (/)) 

= <lx) (by(/)) 

= Balx. (by(B)) 

As Blax = Balx, then Bla = Bal. This conclusion is 
established by the method, similar to those, used in deriving 
the previous axiom. Since it will be involved rather often, the 
corresponding rule is to be especially formulated: 

_-, ux = vx 
[u ) : . 

U = V 

This rule turns out working in the case, when a; is a variable. If 
this rule matches with one of the monotonicity rules (u), then 
it can be observed, that its premise and conclusion have been 
changed their positions. From this reason (in case, when x is 
a variable) this rule {i^~^) can be named as a rule of reversed 
monotonicity. 



The symbol '^^' denotes a one-to-one correspondence. 



168 Chapter 1 5: Embedding Lisp into ACS 

Lisp— 3. The axiom scheme (15.3) will be re-written as the 
equality 1 = Null Nil (by the rule (cr)), where Nil = /, 1 is 
a numeral with a combinatory characteristic lab = ab, or, in 
terms of A-calculus, 1 = Xxy.xy. Note, that 

{D) : Dabc = cab, 

(0) : Oab = b, orO ^^ Xxy.y. 

It is needed to be taken into consideration, that KI ^^ 0, i.e. 
KI = 0. Now, an object, corresponding to the function Null 
will be found: 

1 = Xxy.xy (byDf. 1) 

= Xx.x ( provable Xxy.xy = Xx.x) 

= I (by Df. /) 

= KI{K{KO)) (by scheme (K)) 

= I{KI){K{KO)) (by scheme (/)) 

= D{KI){K{KO))I (by scheme (L>)) 

= DO{K{KO))I. (by scheme (0)) 

Comparing the obtained expression DO{K{KO))I = 1 and the 
scheme Null Nil = I (or, more rigorously, scheme Null Nil = 
T ), conclude, that DO{K{KO))I ^ Null Nil. 

Lisp— 4. The following transformations are to be performed: 

= KO{bO) (by scheme (K)) 

= K{KO)a{bO) ( by scheme (K)) 

= Da{bO){K{KO)) ( by scheme (D)) 

= B{Da)bO{K{KO)) ( by scheme (5)) 

= DO{K{KO)){B{Da)b). ( by scheme (D)) 

Compare the derived expression DO{K{KO)){B{Da)b) = 
with the axiom scheme (15.4): Null{Append(List a)b) = 0. 
If take into consideration, that DO{K{KO)) ^ Null, B ^ 
Append, then D ^^ List. 



Chapter 1 5; Embedding Lisp into ACS 169 

Lisp— 5. The same way as above, find an object, corresponding 
to the function Car: 

a = Ka{bc) ( by scheme (iT)) 

= Da{hc)K (by scheme (i:>)) 

= B{Da)hcK ( by scheme (B)) 

= DcK{B{Da)b). ( by scheme (£»)). 

Evidently, that DcK ^^ Car. 

Lisp— 6. Using the same way, construct an object, correspon- 
ding to the function Cdr: 

bz = I{bz) ( by scheme (/)) 

= KIa{bz) ( by scheme (K)) 

= Da{bz){KI) (by scheme (D)) 

= B{Da)bz{KI) ( by scheme (B)) 

= {Xxy.xy{KI)){B{Da)b)z. ( (/3),(a)) 

Since 

bz= {\xy.xy{K I)){B{Da)b) z, 

then 

{Xxy.xy{K I)){B{Da)b) = b 

for a variable z (the reversed monotonicity rule is applied), i.e. 
Xxy.xyO ^^ Cdr. 



Answer. The results of representing the main functions of the pro- 
gramming system Lisp are arranged in a table below: 



170 



Chapter 1 5: Embedding Lisp into ACS 



N° 


Function of Lisp 


Object of combinatory logic 


by order 




or A-calculus 


1 


Append 


B 


2 


Nil 


I 


3 


Null 


DO{K{KO)) 


4 


List 


D 


5 


Car 


DcK 


6 


Cdr 


Xxy.xyO 



15.3 Concluding remarks 



A solution of the formulated problem, undoubtedly, is done by the 
method of embedding. In can be re-formulated in terms of objects. 

The system of equalities (15.1 )—( 15.6), as a set, is considered as 
an assignment, for which a shell theory is individualized. This shell 
theory is a concept, while a result of individualizing will be dependent 
on a choice of the concept. For instance, select as a shell the r]S,- 
calculus of A-conversions. Then every of the concept objects 



Append, Nil, 



Null, 



List, 



Car, 



Cdr 



will result in, under performing the assignment, a corresponding in- 
dividual object 



B, 



DO{K{KO)), D, DcK, 



Xxy.xyO. 



The individual objects constitute an individual theory, that is similar 
to Lisp language (and is a shell). The ry^-calculus of A-conversions 
reveals one remarkable feature: both the concept objects and individ- 
ual objects relatively the assignment (15.1 )— ( 15.6) remain within the 
same universe. 



Chapter 16 

Supercombinators 



Supercombinators constitute a purely object programming system, 
embedded into combinatory logic. This immediately satisfies the 
needs in denotational computation of instruction of programming 
language, when a functional meaning of the program is expressed 
by the objects. It is essentially, that a computation begins with some 
beforehand known set of instructions. During an evaluation of the 
program, the instructions, which are needed in a computation, but 
are beforehand unknown, arise in dynamics, and they are fixed in the 
programming system in addition. 



16.1 Theoretical background 

There are two approaches to use the supercombinators for implemen- 
tation of applicative programming languages. In the first of them a 
program is compiled by the fixed set of supercombinators (in a non- 
optimal variant they are S, K, I) with beforehand known definitions. 
But the second approach, in which the definitions of supercombina- 
tors are generated by a program itself in a process of compiling, is 
primarily considered. 

171 



172 Chapter 16; Supercombinators 

16.1.1 Notion of supercombinator 

Definition 16.1. Supercombinator $5* of arity n is the lambda-exp- 
ression 

$S = Xxi.Xx2. . . . XXn-E, 

or, equally, the abstraction of a kind: 

$S=[X,].[X2]....[X^].E, 

where E is not an abstraction. Thus, all the "leading" symbols of 
abstraction [•]. are related only to xi, X2, ..., Xn, and at the same 
time the following conditions are valid: 

( 1 ) %S does not contain any free variables; 

(2) every abstraction in i? is a supercombinator; 

(3) n > 0, i.e. the availability of symbols '[•].' is not necessary. 

Supercombinator redex is the application of a supercombinator to 
n arguments, where n is its arity. A substitution of the arguments 
in the body of supercombinator instead of free occurrences of corre- 
sponding formal parameters is called a reduction of the supercombi- 
nator. 

This definition could be compared with a definition of combinator. 
In other words, we can say, that the combinator is such a lambda- 
abstraction, which does not contain any free occurrences of the vari- 
ables. Some of the lambda-expressions are the combinators, and 
some of the combinators are the supercombinators. 

Example \b.\. The expressions 

3, +2 5, [x] .X, [x] .+ X X, [x] . [y] .xy 

are the super combinators. 

Example 16.2. The following terms are not the supercombinators: 



Chapter 16; Supercombinators 173 

[x] .y — (the variable y has a free occurrence), 
[y] .- y X — (the variable X has a free occurrence). 

Example 16.3. The term [f] .f ([x] .f x 2) is a combinator, be- 
cause all the variables (f and x) are bound, but is not a supercom- 
binator, because the variable / is free in the inner abstraction and 
condition (2) of the definition 16.1 is violated. In accordance with this 
definition, the combinators S, K, I, B, C are the supercombinators. 
Hence, SK-machine, represented in a theory of categorical compu- 
tations, implements one of the methods of using the supercombina- 
tors. 

Supercombinators of arity are the constant applicative forms 
(CAF). 

Example 16A. The expressions: 

a)3, b)+ 4 6, c)+ 2 

are the CAFs. 

The point c) shows, that CAF can be the function, though it does 
not contain the abstractions. Since CAF has no symbol of the ab- 
straction, the code is not compiled for them. 

Exercise 16.1. Show, that the following expressions are the super- 
combinators: 

1 0, [x] .+ x 1, [f] .([x] .+ X x). 

Exercise 16.2. Explain, why the following expressions are not the 
supercombinators: 

[x] .X y z, [x] . [y] .+ (+ x y) z. 

Exercise 16.3. Give an example of the combinator, which is not a 
supercombinator. 



174 Chapter 16; Supercombinators 

16.1.2 Process of compiling 

The actual programs contain a significant number of the abstractions. 
The program is to be transformed so that to contain the only super- 
combinators. Accept, that the names of the supercombinators start 
with the symbol '$', e.g.: 

$XY = [x] . [y] . - y x. 

To stress the features of supercombinatros, this definition is rewritten 
as: 

$XY X y = - y X. 

The selected strategy is in a transforming the abstraction, which 
should be compiled into: 

( i ) the set of supercombinator definitions, 

(11) the evaluated expression. 

This will be written by: 

Definitions of supercombinators 



Evaluating expression 

Example 16.5. The expression ([a;]. [?/]. — ?/ a;)3 4 can be represented 
by: 

$XY X y = - y X 
$XY 3 4 



Chapter 16; Supercombinators 175 

Example 16.6. The expression {%XY 3) is not a redex and cannot be 
evaluated. Thus, the definitions of supercombinators are determined 
as a set of rewriting rules. The reduction is in rewriting the expression, 
which matches a left part of the rule, replacing it by the expression, 
which is the right part. These systems are known as term rewriting 
systems. 

Exercise 1 6.4. Is it possible to evaluate the expressions: 

$XY 5, $XY 5 7, $XY 3 4 7? 

16.1.3 Transformation to supercombinators 

Supercombinators are easy to compile. Give a description of the al- 
gorithm of transforming the abstraction into combinators. Consider 
a program, which does not contain any supercombinator: 

([x] .([y] .+ y x) x) 4. 

Select the most inner abstraction, i.e. such an abstraction that has 
no other abstractions: 

([y] .+ y x). 

It has a free occurrence of the variable x, therefore this abstraction is 
not a supercombinator. 

( 1 ) The following supercombinator is obtained by a simple transfor- 

mation — usual /3-reduction: 

([x] . [y] .+ y x)x. 

(2) Substitute it in the source program: 

([x] . ([w] . [y] .+ y w) X x)4. 

(3) Assign to this supercombinator the name $Y. 



176 Chapter 16; Supercombinators 



(4) Now it can be seen, that [x] .-abstraction is also a supercombi- 
nator. It is assigned the name $X (the abstraction is compiled) 
and put into compiled code: 

$Y w y = + y w 
$X X = $Y X X 



$X 4 

The resulting program can be executed, using a reduction of super- 
combinators: 

$X 4 — > $Y 4 4 = + 4 4 = 8. 

Thus, an algorithm, transforming the abstractions into supercombi- 
nators, is as follows: 

Loop-while: is an abstraction? 

( 1 ) select any abstraction, which has no other abstractions, 

(2) shift all the free in this abstraction variables as extraparameters, 

(3) assign to this abstraction a name (e.g., $X34), 

(4) replace an occurence of the abstraction in the program by the 

name of supercombinator, which should be applied to free vari- 
ables, 

(5) compile the abstraction and assign a name to this compiled 

code. 

END-while 



During these transformations a volume of this program increased. 
This is a payment for the simplicity of reduction rules. Note that this 
transformation procedure reduces the source program to the follow- 
ing layout: 



Chapter 16; Supercombinators 177 

. . . Definitions of supercombinators . . . 



Since the expression E is the evaluated expression of the highest level, 
then it contains no free variables. It can be considered the a super- 
combinator of arity 0, i.e. CAF: 

. . . Definitions of supercombinators . . . 
$Prog = E 

$Prog 

The procedure of transforming the abstractions into supercombina- 
tors is called lambda lifting, because all the abstractions are lifted to 
the higher level. 

Exercise 1 6.5. Transform and execute the following programs: 

l)([x].([y].- y x) x) 5, 

2)([z].+ z(([x].([y].xy x) x) 4)) 2. 

16.1.4 Eliminating redundant parameters 

Consider a simple optimization of lambda-lifting algorithm. Let: 

[x] . [y] .- y X. 

be written. Although it is a supercombinator, apply to it the lambda- 
lifting algorithm. 

(1) Select the innermost abstraction [y] .- y x. The variable x has 
a free occurrence. Shift it as an extraparameter: 
( [x] . [y] .- y x) X. 

Let: 

$Y = [x] . [y] . - y X. 
Thus: 



178 Chapter 16; Supercombinators 

$Y X y = - y X 

[x] . $Y X 

(2) Let$X = [x] .$Y X. Then: 

$Y X y = - y X 
$X X = $Y X 



$X 

(3) In this case the definiton of $X is simplified to $X = $Y (by rj- 
reduction). 

Thus, the supercombinator $X is redundant and can be replaced by 
$Y: 

$Y X y = - y X 



$Y 
This results in the availability of two optimizations: 

1 ) eliminating the redundant parameters from the definitions by 
r/-reduction, 

2) eliminating the redundant definitions. 

16.1.5 Ordering of the parameters 

In all the programs considered above the order of lifting the variables 
as extraparameters was arbitrary. For instance, consider the program: 



([x] . [z] .+ y (XX z)) 



Chapter 16; Supercombinators 179 

where '...' denotes the outer for the [x] . -abstraction context. Let us 
start with the lambda-lifting algorithm. 

( 1 ) Select out the innermost abstraction 

[z] .+ y(x X z). 

This abstraction is not a supercombinator, because it contains 
two free variables x and y. At the next step of algorithm the free 
variables are to be shifted as extraparameters. 

A question is, in what order should the variables be arranged: it is 
possible at first put the x, and then y, or at first put y, and then x. 
Both the variant are performed. 

Variant 1 . 

(2) Lift the variables, arranging them in the order X, y: 

([x] . [y] . [z] .+ y(x X z))x y. 

(3) Assign to obtained supercombinator the name: 

$S = ([x] . [y] .[z] .+ y(xx z)). 

(4) Substitute $S into the source program: 

$S X y z = + y(x x z) 



( [x] . $S X y) 

The expression [x] . $S x y is not a supercombinator, therefore, in 
turn, the lambda-lifting algorithm should be applied to it. 



180 Chapter 16; Supercombinators 

(2) Lift the free variable y: 

([y] . [x] .$S X y)y. 

(3) Assign to a supercombinator the name $T y x = $S x y. 

(4) Substitute the combinator into the program: 

$T y x = $S X y 

$T y. 

Turn to the main algorithm, in which now obtain: 

$S X y z = + y(x x z) 
$T y X = $S X y 
(... $T y ...). 

Variant 2. 

(2) Lift the variables, arranging them in the order y, x: 

([y] . [x] . [z] .+ y(x X z)) y x. 

(3) Assign to the obtained supercombinator a name: 

$S = ([y] . [x] .[z] .+ y(x x z)). 

(4) Substitute $S into the source program: 

$S y X z = + y(x x z) 



(... 
([x] .$S y x) 



Chapter 16; Supercombinators 181 

The expression [x] .$S y x is not a supercombinator, because it 
contains an occurrence of free variable y. Apply the lifting algorithm 
to [x] .$S y X. 

( 1 ) The innermost abstraction matches the whole program. 

(2) Lift the variable y: ( [y] . [x] .$S y x)y. 

(3) Now the supercombinator above is to be named: 
$T = [y] . [x] . $S y X. 

(4) Substitute the combinator into the program: 

$T y X = $S y X 
$T y 

Turn now to the main algorithm. Derive, that: 

$Sxyz = + y (xxz) 
$T y X = $S y X 

(... $T y ...) 

In accordance with the rule of elimination the redundant parameters 
(see subsection 1 6. 1 .4) we obtain: $T = $S, therefore $T can be elim- 
inated. Then the compiled code is as follows: 

$S y X z = + y(x X z) 

$S y 

In the first variant such an otimization is impossible. In the initial 
program 

(... ([x].[z].+ y(xx z)) ...) 



182 Chapter 16; Supercombinators 

there are two bound variables: x and z. In the second variant an 
ordering of the free variables is done at the step (2) so, that in the 
obtained supercombinator the bound in a program variables x and 
z are at the last place: $S y x z. Only in this case the code can 
be optimized. Thus, the free variables should be arranges such a 
way, that the bound variables were put in the tail places in a list of 
supercombinator parameters. 

Any abstraction is assigned by a lexical number of its level, which 
is determined by the number of outer symbols of the abstraction. 
Example 16.7. In the expression 

([x] . [y] .+ x(x y y)) 

the operator of [x] .-abstraction is at the level 1, and of [y] .-abst- 
raction is at the level 2. 

Give the formulation of the rules, allowing to introduce a lexical 
number of the level: 

1 ) a lexical number of the abstraction is greater by one of the number 

of its outer abstractions; if there are no such abstractions, the 
the number is equal to 1 ; 

2) the lexical number of a variable is the number of the abstraction, 

bounding this variable; if the number of x is less than the num- 
ber of y, then is said, that x is more free than y; 

3) a lexical number of a constant is equal to 0. 

To improve the abilities for optimizing, the extraparameters should be 
arranged by increasing of their lexical numbers. 

16.1.6 The lambda-lifting with a recursion 

Note, that the lambda-abstractions, as a rule, have no names. To 
the contrast, the supercombinators are named. Besides this, a su- 
percombinator can refer to itself. This means, that recursive super- 
combinators are implemented directly, without using the fixed point 



Chapter 16; Supercombinators 183 



combinator Y. Certainly, the recursive definitions can be transformed 
into the non-recursive ones, using y, by to do this the additional rules 
are to be introduced. 

Example 16.8. To make $F non-recursive, the following definitions 
sould be intriduced: 

$F = Y $F1 1 

$F1 E X = $G (F(- X D) 0. J ^*^ 

An additional definition is marked by the symbol '*'. Since Y 
should be reduced, then such a definition of $F involves more of the 
reductions, than a recursive version does. 

Notation: 

$S1 X y = Bl 
S2 f = B2 



is equl to the expression: 

letrec 

$S1 = [x] . [y] .Bl 
$S2 = [f] .B2 

in 

E. 

It means, that E contains $S1, $S2, . . ., the recursive definitions 
of which are given in letrec. The lambda-lifting algorithm proceeds 
the same way, as previously: the expressions, containing in letrec, 
are treated the same way as any other expressions. Nevertheless, a 
question is, what a lexical level number should be assigned to the vari- 
ables, bound in letrec. Since these variables are evaluated, when 
nearest outer abstraction is applied to its argument, then their lexical 
number is the same as the number of this abstraction. In case of 



184 Chapter 16; Supercombinators 

absence of outer abstractions the lexical number equals 0. Such a 
number is assigned to the constants and supercombinators. Within 
letrec, which contains no abstractions, it cannot be any free vari- 
ables, besides those variables, which already have been defined in 
letrec. 

Such a letrec is the combinator. To transform it to supercom- 
binator, it is necessary to make a lambda-lifting, eliminating all the 
inner abstractions. The variables, bound in letrec of level 0, will not 
be shifted as extraparameters, because the constants (remind, that 
they are of level 0) are not lifted. 

Example 16.9. Consider the program, resulting in an infinite list of 
ones: 



letrec x = cons 1 x 
in X 



In this program the letrec is at the level 0, and there are no abstrac- 
tions, hence, x is already a supercombinator: 

$x = cons 1 X 



X 

Example 1 6. 1 0. Consider a recursive function of factorial: 

letrec fac = [n] .IF (= n 0) 1 

(x n (fac(- n 1))) 
in fac 4 

In this case letrec has the number 0, and there are no abstrac- 
tions within [n] . -abstraction. Hence, fac is a supercombinator: 

$fac n = IF (= n 0) 1 (xn(fac(- n 1))) 
$Prog = $fac 4 

$Prog 



Chapter 16; Supercombinators 185 

Exercise 16.6. Compile the program: 

let 

inf = [v] . (letrec vs = cons v vs in vs) 
in 

inf 4 

Hint: let means, that in the expression inf 4 the function inf con- 
tains the definition, which have been written within let. The function 
inf V returns an infinite list of symbols v. 

16.1.7 Execution of tine lambda-lifting aigoritiim 

Consider the program, adding the first 100 natural numbers: 

Sumlnts m = sum (count 1) 
where 
count n = [] , n > m 

= n: count (n + 1) 
sum [] = 
sum (n:ns) = n + sum ns 



Sumlnts 100 

Sumlnts is a composition of the functions sum and count: at first, the 
function count is applied to 1, and next its result is used as an input 
of the function sum. The function count works as follows: 

count 1 = 1: count 2 (because both n = 1, m = 100, 

and condition n > m do not hold) 
= 1:2: (count 3) (executed count 2) 

=1:2: ... : 100: (count 101) 

= 1:2: ... :100: [] (since 

n = 101, m = 100, 

thenn > m, (count 101 = [] ) ) 



186 Chapter 16; Supercombinators 



Now the list 1:2:3: ... :100: [] is transmitted to the function 
sum. In the second defining equality for sum the argument (n:ns) 
denotes a list, in which the first element is the number n, and its "tail" 
is a list of the numbers ns: 

sum 1:2:3: ... :100:[] = 1 + sum 2:3: ... :100:[] 

= 1 + 2 + 3+... + 100 + sum[] 

= 1 + 2 + 3+... + 100 + (because sum [] = 0) 

Write this function in terms of abstractions, using letrec: 

letrec 

Sumlnts 

[m] .letrec 

count = [n] .IF (> n m) NIL 

(cons n (count (+ n 1) )) 
in sum (count 1) 
sum = [ns] .IF (= ns NIL) 

(+ (head ns) (sum (tail ns)) ) 
in Sumlnts 100 

In the above: NIL is an empty list [] , head is the function, returning 
the first element of a list, tail is the function, returning the tail of 
a list (a list without the first element). The variables Sumlnts and 
sum have the number 0, however, Sumlnts contains an inner [n] . - 
abstraction with free variables m and count. It is necessary to execute 
the lambda-lifting algorithm and to "lift" these variables. 

( 1 ) The inner abstraction is the following: 

[n].IF (> n m) NIL (cons n (count (+ n 1) )) 

(2) Lift the variables count and m in this order (because bound in 
a source program variable m should be at the last place): 

( [count] . [m] . [n] .IF (> n m) NIL 

(cons n (count (+ n 1)))) count m 



Chapter 16; Supercombinators 187 

(3) Assign to the derived combinator the name $count: 
$count count m n = IF (> n m) NIL 

(cons n (count (+ n 1))) 

(4) Replace an occurrence of the [n] .-abstraction in the program 
by the construction $count count m n: 

$count count m n = IF (> n m) NIL 

(cons n (count (+ n 1))) 

letrec 

Sumlnts 

= [m] .letrec 

count = $ count count m 
in sum (count 1) 
sum = [ns] .IF (= ns NIL) 

(+ (head ns) (sum (tail ns))) 
in Sumlnts 100 

(5) In the expressions Sumlnts and sum there are no inner ab- 
stractions, their level is equal to 0, hence, they are supercombinators. 
By immediate applying the lifting to these expressions, and adding 
the supercombinator $Prog, obtain the final result: 

$count count m n = IF (> n m) NIL 

(cons n(count (+ n 1))) 
$sum ns = IF (= ns NIL) (+ (head ns) 

($sum (tail ns))) 
$SumInts m = letrec count = $count count m 

in $sum (count 1) 
$Prog = $SumInts 100 

$Prog 

Exercise 1 6.7. Compile the program, which applies the function 
f = SQUARE to each of the elements of a list of the natural numbers 
from 1 to 5: 



188 Chapter 16; Supercombinators 



apply m = fold SQUARE (constr 1) 

where constr n = [] , n > m 

= n:constr(ii + 1) 
fold f [] = [] 
fold f(n:ns) = fn:fold f ns 

16.1.8 Other ways of lambda-lifting 

An approach, used in the previous subsections, is not the only way 
of a lambda-lifting of the recursive functions. There is an algorithm, 
which generates the supercombinators for the data structures rather 
than the functions. Assume, that there is a program, containing a 
recursive function f with the free variable v: 



( ... 

letrec f = [x] .(... f...v...) 

in ( ... f ... ) 
... ) 

The recursive combinator $f is generated by f , however, with this, an 
abstraction is generated for the variable v, rather than for the function 
f : all the occurrences of v are replaced by $f v. The replacement 
results in: 



$f V X = ... ($f v) ... V ... 
( ... 

( ... ($f v) ... ) 
... ) 

Consider an execution of this algorithm, using the example from sub- 
section 16.1.6. A source program is as follows: 



Chapter 16; Supercombinators 



letrec 

Sumlnts 

[m] .letrec 

count = [n] .IF (> n m) NIL 

(cons n (count (+ n 1)) ) 
in sum (count 1) 
sum 

= [ns] .IF (= ns NIL) 

(+(head ns) (sum(tail ns)) ) 
in Sumlnts 100 



Lift the [n] . -abstraction, abstracting the free variable m, but not 
the count, and replacing all the occurrences of count by the expres- 
sion ($count m): 



$count m n = IF (> n m) NIL 

(cons n ($count m (+ n 1))) 
letrec 

Sumlnts = [m] .sum($count m 1) 
sum = [ns].IF (= ns NIL) 

(+(head ns) (sum(tail ns))) 
in 

Sumlnts 100 



There are two calls of count in the initial program: in the [n] . - 
abstraction and in the definition of Sumlnts; both of these calls are 
replaced by ($count m) . Now it is clear, that both Sumlnts, and sum 
are the supercombinators, hence, they could be lambda-lifted: 



190 Chapter 16; Supercombinators 

$count m n = IF (> n m) NIL 

(cons n ($couiit m (+ n 1))) 
$suin ns = IF (= ns NIL) 

(+(head. ns) ($suin(tail ns))) 
$SumInts m = sum ($count m 1) 
$Prog = $SuinInts 100 

$Prog 

A main advantage of this method relatively the previous one is as fol- 
lows. In the example from subsection 1 6. 1 .6 a recursive call of $count 
in the supercombinator $count was performed via its parameter, de- 
noted by count. In the new method a call of the supercombinator 
$count is done immediately. The compiler, built on this method, 
works more efficiently. 

Exercise 16.8. Try to make a compiling of the program of exer- 
cise 1 6.7 by the method given above. 



16.1.9 Full lazyness 

Consider the function f = [y] .+ y (sqrt 4), where sqrt is the 
function of square root. Every time, when this function is applied to 
its argument, the subexpression (sqrt 4) is to be newly evaluated 
one more time. However, independently on a value of the argument y, 
the expression (sqrt 4) is reduced to 2. Hence, it would be desirable 
not to perform repeatedly an evaluation of these constant expressions, 
but, evaluating it once, use the saved result. 

Example 1 6. 1 1. Consider the program: 



f = g 4 

g X y = y + (sqrt x) 

(f 1) + (f 2) 



Chapter 16; Supercombinators 



191 



Its notation in terms of the lambda-expressions gives: 



letrec f = g 4 

g = [x] . [y] .+ y (sqrt x) 
in + (f 1) (f 2) 

In evaluating this expression the following result is obtained: 

+ (f 1) (f 2) — > 
— > + (. 1) (. 2) 

. .— > (([x].[y].+ y (sqrt x)) 4) 

— > + (. 1)(. 2) 

. .— > ([y].+ y (sqrt 4)) 

— > + (. 1)(+ 2 (sqrt 4)) 

. > ([y].+ y (sqrt 4)) 

— > + (. 1)4 

. > ([y].+ y (sqrt 4)) 

— > + (+ 1 (sqrt 4)) 4 
— > + (+ 1 2)4 
— > +34 
— > 7 



In this example the subexpression (sqrt 4) is evaluated twice, 
on every application the expression [y] . (sqrt 4) is treated as gen- 
erated, in dynamics, constant subexpression of the [y] . -abstraction. 
The same effect is observed when the supercombinators are used. The 
considered expression is compiled as follows: 

$g X y = + y (sqrt x) 

$f = $g 4 

$Prog = + ($f l)($f 2) 



$Prog 
The reduction of this is the following: 



192 Chapter 16; Supercombinators 

$Prog — > + (. 1)(. 2) 

. .— > ($g 4) 

— > + (. 1)(+ 2 (sqrt 4)) 

.— > ($g 4) 
— > + (. 1) 4 

.— > ($g 4) 
— > + (+ 1 (sqrt 4))4 
— > + (+ 1 2)4 
— > +34 
7 

And in this case the subexpression (sqrt 4) is evaluated twice as 
well. After writing these examples, having an introductory nature, 
give a formulation of the main problem, to overcome which the efforts 
are needed: 

after binding all its variables, every expression should be 
evaluated, at most, once. 

This property of evaluation the expressions is called as full lazyness. 

Exercise 16.9. Consider the following program: 

f = g 2 

g X y = y * (SQUARE x) 

(f 3) * (f 1) 

a) Write this program in terms of abstractions and evaluate. 

b) Compile this program and evaluate. 

16.1.10 Maximal free expressions 

To get the full lazyness there is no necessity to make the evaluation of 
those expressions, which contain no (free) occurrences of the formal 
parameter. 



Chapter 16; Supercombinators 193 

Definition 16.2. An expression £" is called the proper subexpression 
of F, if and only if £■ is a subexpression of F and E is not the same as 
F. 

Definition 16.3. Subexpression £" of the abstraction is assumed /ree 
in the lambda-abstraction L, if all the variables of E are free in L. 

Definition 16.4. . A maximal free expression, or lAFE,m Llssuch 
a free expression, that is not a proper subexpression of the other free 
expression in L. 

Example 16.12. In the abstractions below the MFEs are underlined: 

(1) {[x\.sqrt x), 

(2) {[x].'x{sqrt4:)) 

(3) {[y].[x]. +i*yy) x). 

To obtain a full lazyness, the maximal free abstractions are not to 
be evaluated in performing the /3-reductions. 

Example 16.13. Turn back to a function from the example 16.11: 



letrec f = g 4 

g = [x] . [y] .+ y (sqrt x) 
in + (f 1) (f 2) 

A sequence of reductions begins, as in this example: 

+ (f l)(f 2) — > 
--> + (. 1)(. 2) 

. .— > (([x].[y].+ y (sqrt x)) 4) 

-> + (. 1)(. 2) 

. .— > ([y].+ y (sqrt 4)) 

(here: the expression (sqrt 4) is MFE in [y] .-abstraction, hence, 
in applying the [y] . -abstraction to its argument (sqrt 4) it should 
not evaluate: 



194 Chapter 16; Supercombinators 

— > + (. 1)(+ 2 .) 

. .— > ([y].+ y (sqrt 4)) ) 

Evaluation has a pointer to (sqrt 4) in the body of abstraction: 

+ (. 1)(+ 2 .) 

• .— >([y].+ y 2) 

— > + (. 1)4 

. — > ([y].+ y 2) 
— > + (+ 1 2)4 
— > + 3 4 
7 

In this case (sqrt 4) is evaluated only once. 

Exercise 16.10. Evaluate the expression from exercise 16.9, using 
MFE. 

16.1.11 Lambda-lifting with MFE 

An algorithm, using MFE, is distinct from the lambda-lifting algo- 
rithm above in that, it does not make the abstractions of variables, but 
of MFE. Turn back to an example under consideration. A function g 
contains the abstraction: 

[x] . [y] .+ y (sqrt x) 

Give an exemplifying of the algorithm in this situation. 

( 1 ) The most inner abstraction is 

[y] .+ y (sqrt x) . 

(2) The expression (sqrt x) is MFE. Shift MFE as an extrapa- 

rameter: 

( [sqrtx] . [y] .+ y (sqrtx) ) (sqrt x). 



Chapter 16; Supercombinators 195 

where sqrtx is a name of extraparameter. Substitute the ob- 
tained expression into source abstraction: 

[x] . ( [sqrtx] . [y] .+ y sqrtx) (sqrt x) . 

(3) Assign a name to obtained supercombinator: 

$gl = [sqrtx] . [y] .+ y sqrtx 
[x] .$gl (sqrt x) 

(4) An available [x] . -abstraction is also a supercombinator, that is 

named and that is corresponded to a compiled code: 

$gl sqrtx y = + y sqrtx 
$g X = $gl (sqrt x) 
$f = $g 4 
$Prog = + ($f 1) ($f 2) 



$Prog 

The additional supercombinator is obtained, because a possibilty to 
use ry-reductions is lost due to abstracting on (sqrtx) instead ab- 
stracting on X. 

However, this effect is compensated by full lazyness. Hence, 

to obtain full lazyness it is needed to abstract MFE, but 
not the free variables, using the generated abstractions as 
extraparameters. 

The algorithm above is a fully lazy lambda-lifting. 

Exercise 16.11. Make a fully lazy lambda-lifting of a program, con- 
sidered in exercise 16.9. 



196 Chapter 16; Supercombinators 

16.1.12 Fully lazy lambda-lifting with letrec 
Consider the program: 



let f = [x] .letrec f ac = [n] . ( ... ) 

in + X (fac 100) 
in 

+ (f 3)(f 4) 

The algorithm from subsection 16.1.6 compiles it in: 

$f ac fac n = ( . . . ) 

$f X = letrec fac = $fac fac 

in + X (fac 100) 
+ ($f 3)($f 4) 

The function fac is locally defined in the body of function f and, 
hence, the expression (fac 100) cannot be lifted as MFE from a 
body of f . This means, that (fac 100) will be evaluated every time, 
when $f is executed. Thus, a property of full lazyness is lost. 

The overcoming of this is rather easy: it is enough to note, that 
the definition of fac does not depend on x, hence, letrec for fac can 
be lifted: 



letrec 

f ac = [n] . ( . . . ) 

in let 

f = [x] .+ X (fac 100) 
in 

+ (f 3)(f 4) 



Now nothing prevents the applying of fully lazy lifting, that will gen- 
erate a fully lazy program: 



Chapter 16; Supercombinators 197 

$f ac n = ( . . . ) 
$faclOO = $fac 100 
$f X = + X $faclOO 
$Prog = + ($f 3)($f 4) 



$Prog 

In this case some optimizing is done: an expression, which has no 
free variables, is not abstracted, but is named and became the super- 
combinator — $f aclOO. 

Thus, a strategy is implemented by two stages: 

1 ) shifting letrec- (and let-) definitions as "far" as possible, 

2) using a fully lazy lambda-lifting. 

Exercise 1 6. 1 2. Execute a fully lazy lambda-lifting of the program: 

let 

g = [x] .letrec el = [n] . [s] . (IF (= n 1) (head s) 

(el (- n 1) (tail s)) ) 
in (cons x (el 3 (A,B,C))) 
in 

(cons (g R) (g D) 

(here: R and L are the constants). 

16.1.13 Compound example 

This subsection contains a more detailed example exposing fully lazy 
lambda-lifting' : 

Sumlnts n = foldl + (count 1 n) 
count n m = [] , n > m 



'An advanced study of lazy evaluations with supercombinators see in [Id-'")]. Thiis 
booli includes the abstract machine that supports all the spectrum of possibilities. 



198 Chapter 16; Supercombinators 

count n m = n: count (n + 1) m 

fold op base [] = base 

foldl op base (x:xs) = foldl op (op base x) xs 

This program in terms of abstractions is written as: 

letrec 

Sumlnts = [n] .foldl + (count 1 n) 
count = [n] . [m] .IF (> n m) NIL 

(cons n (count (+ n 1) m) ) 
foldl = [op] . [base] . [xs] .IF (= xs NIL) base 

(foldl op (op base (head xs))(tail xs)) 
in Sumlnts 100 

In this program: 

(1 ) an inner abstraction is ( [xs] . ... ), 

(2) maximal free expressions are the expressions (fold op), 
(op base) base. 

They are shifted as extraparameters p, q and base respectively: 

$R1 p q base xs = IF (= xs NIL) base 

(p (q (head xs)) (tail xs)) 

letrec 

Sumlnts = [n] .foldl + (count 1 0) 

count = [n] . [m] .IF (> n m) NIL 

(cons n (count (+ n 1) m) ) 

foldl = [op] . [base] .$R1 (foldl op) (op base) base 
in 

Sumlnts 100 

In this program an inner abstraction is '[base] .'. Maximal free 
expressions are the expressions ($Rl(foldl op)) and op, that are 
shifted as r and op respectively: 



Chapter 16; Supercombinators 199 

$R1 p q base xs = IF (= xs NIL) base 

(p (q (head xs))(tail xs)) 
$R2 r op base = r (op base) base 

letrec 

Sumlnts = [n] .foldl + (count 1 n) 

count = [n] . [m] .IF (> n m) NIL 

(cons n (count (+ n 1) m) ) 

foldl = [op] .$R2($R1 op) op 
in 

Sumlnts 100 



(3) all the definitions of letrec are supercombinators, because a 
lifting of all the inner abstractions is done. With all of these notions, 
a final result is as follows: 

SSumlnts n = $foldlPlusO ($countl n) 

$foldlPlusO = $foldl + 

$countl = $count 1 

$count n m = IF (> n m) NIL (cons n ($count (+ n 1) m) ) 

$foldl op = $R2 ($R1 ($foldl op)) op 

$Prog = $SumInts 100 

$R1 p q base xs = IF (= xs NIL) base 

(p (q (head xs))(tail xs)) 
$R2 r op base = r (op base) base 

$Prog 



Concluding a consideration, note that in this case the parameter op 
cannot be eliminated in $f oldl, because it is used twice in a right 
part. 



200 Chapter 16; Supercombinators 



16.2 Task 

Task 16.1. Write the following definition in initial language using 
supercombinators: 

el n s = if n = 1 then (hd s) 

else el (n — 1) (tl s). 

The function el selects n-th element form a sequence s. 

Solution. In terms of A-calculus a definition of the function has the 
following form: 

el = Y{Xel.\n.Xs.if (= n 1) (hd s){el (- n 1) (tl s))). (el) 

Remind an algorithm of translation the A-expressions into applicative 
form. Take an arbitrary A-expression XV.E. 

SC—l. A body of the initial expression is transformed into the 
applicative form by a recursive call of the compiler. This results 
in: XV.E'. 

SC—2. The variables, which are free in the A-expression, are 
identified by the letters P, Q, . . . , R, next the A-expression 
receives a prefix 'A', bounding all these variables. The result 
is the following: 

AP.AQ. . . . XR.XV.E'. 

The resulting expression is wittingly a supercombinator, be- 
cause E' is an applicative form, all the free variables P, Q, . . ., 
R in which are bound. 

SC—?>. Denote the generated combinator by alpha and assign 
to it a definition (defining equality): 

alpha P Q . . . RV -> E' . 



Chapter 16; Supercombinators 201 

An initial A-expression is replaced by the form 

{alpha P R ... R). 

In a connection with expression E, the application can be re- 
duced. The expression E is related to V, and every free variable 
has its own value in E'. Hence, the applicative form is actually 
equal to the initial A-expression. Now a step-by-step transla- 
tions will be determined. 

1 ) Consider the most inner A-expression: 

Xs.if (= n 1) (hd s) {el {- n 1) {tl s)). 

Its free variables are n and el, hence the combinator alpha 
is introduced by a definition: 

alpha n el s ^> if {= nl)(hds) / , , n 

) u )\f+i ^^ {alpha) 

[el {— n 1) {tl s)). 

2) Replace all the A-expressions by {alpha n el), therefore, 

el = Y{Xel.Xn. alpha n el). 

3) Repeat the steps 1) and 2) for Xn.alpha n el. Introduce 
the combinator beta by a definition: 

beta el n ^ alpha n el, {beta) 

from which follows, that 

el = Y{Xel.beta el). 

4) Repeat the steps 1 ) and 2) for {Xel.beta el). Introduce the 
combinator gamma by a definition: 

gamma el -^ beta el, {gamma) 

from which we obtain, that 

el = Y gamma. 



202 Chapter 16; Supercombinators 

Answer, el = Y gamma. 
Test. 

1. What are the aims of using the supercombinators in imple- 
menting a reduction? 

2. What are the features of a languages of the constant applicative 
forms (CAF)? 

3. What are the features of the combinators S, K, I, that allow 
their direct using in a GR-machine (a machine of graph reduc- 
tion)? 

Exercise 16.13. Using the supercombinators, write the expression: 
facn = if n = then 1 else n x (/ac(n— 1)). 

16.3 Answers to exercises 

16.1 

1 contains no free variables (see Df. 16.1, p.(l)) and abstraction 
symbols (see Df. 16.1, p.(3)); [x] .+ x 1 contains a variable x, which 
is bound (see Df. 16.1, p.(l)); + x 1 contains no abstractions (see 
Df. 16.1, p.(2)); [f] .f ([x] .+ X x) contains no free variables (see 
Df. 16.1, p.(l )), [x] .+ X xis a supercombinator(see Df. 16.1, p.(2)). 

16.2 

[x] . X y z contains free variables y and z, point ( 1 ) of Definition 1 6. 1 
is violated; [x].[y].+ (+ x y) z contains free variable z. 

16.3 

For instance, [x] . [y] .x y([z] .z x). 



Chapter 16; Supercombinators 203 

16.4 

The expression $XY 5 cannot be evaluated, because it is not a redex; 
$XY 5 7 can be evaluated, $XY 3 4 7 can be evaluated. 

16.5 

l)([x].([y].- y x)x)5: 

(1 ) the innermost abstraction is [y] .- y x; 

(2) lift X as an extraparameter ( [x] . [y] .- y x)x and substitute 
it into initial program ( [x] . ( [v] . [y] .- y v) x x)5; 

(3) assign to this supercombinator the name $Y: 

$Y V y = - y V 

([x] .$Y X x)5 

(4) [x] .-abstraction is also a supercombinator, which can be 
named and assigned to the compiled code: 

$Y V y = - y V 
$X X = $Y X X 



$X 5 

The derived program is executed as follows: 

$X5=$Y55=-55=0. 
2)([z].+ z (([x].([y]. * y x) x) 4)2: 

(1 ) inner abstraction: [y] . * y x; 

(2) lift X as an extraparameter: 

( [x] . [y] . * y x) X 

([z] .+ z(([x] .([w] . [y] . * y w) X x)4))2; 



204 Chapter 16; Supercombinators 

(3) 

$Y w y = * y w 

([z] .+ z([x] .$Y X x) 4) 2 

(4) [x] .-abstraction is a supercombinator: 

$Y w y = * y w 
$X x = $Y x X 

([z] .+ z ($X 4)) 2 

Now it is obvious that [z] . -abstraction is a supercombinator: 

$Y w y = * y w 

$X X = $Y X X 

$Z z = + z ($X 4) 



$Z 2 

An execution of the program: 

$Z 2 = + 2 ($X 4) = + 2 ($Y 4 4) = 
= + 2 (* 4 4) = + 2 16 = 18. 

16.6 

inf is at a level and contains no inner abstractions. Hence, inf is 
already a supercombinator: 

$inf V = letrec vs = cons vs in vs 
$Prog = $inf 4 



$Prog 

16.7 

Write this program in terms of abstractions: 



Chapter 16; Supercombinators 205 



letrec apply = [m] .letrec constr = [n] .(IF > n m) NIL 

(cons n (constr (+ n 1))) 
in fold SQUARE (constr 1) 

fold = [f] . [ns] .IF (= ns NIL) NIL 

(cons (f (head ns)) (fold (f (tail ns))) ) 
in apply 5 

( 1 ) inner abstraction has a form: 

[n] .IF (> n m) NIL (cons n (constr (+ n 1))); 

(2) lift the variables constr and m in this order: 

[constr] . [m] . [n] .IF (> n m) NIL 

(cons n (constr (+ n 1))) constr m; 

(3) assign to this combinator the name $constr: 

$constr constr m n = IF (> n m) NIL 

(cons n(constr(+ n 1))); 

(4) replace an occurrence of [n] .-abstraction in the program by 
the expression ($constr constr m n); 

$constr constr m n = IF (> n m) NIL 

(cons n (constr (+ n 1))) 

letrec 

apply = [m] .letrec 

constr = $constr constr m 
in fold SQUARE (constr 1) 
fold = [f] . [ns] .IF (= ns NIL) NIL 

(cons (f (head ns)) (fold f (tail ns)) ) 
in apply 5 



206 Chapter 16; Supercombinators 



(5) the expressions apply and fold are supercombinators: 

$constr constr m n = IF (> n m) NIL 

(cons m (constr (+ n 1))) 
$fold f ns = IF (= ns NIL) NIL 

(cons (f (head ns)) 

(fold (f (tail ns)))) 
$apply m = letrec constr = $constr constr m 

in $fold SQUARE (constr 1) 
$Prog = $apply 5 

$Prog 



16.8 

Lift [n] .-abstraction, abstracting the variable m, but not the constr, 
and replace all the occurrences of constr by ($constr m) : 

$constr m n = IF (> n m) NIL 

(cons n ($constr m (+ n 1))) 

letrec 

apply = [m] .fold (SQUARE) ($constr m 1) 

fold = [f].[ns].IF (= ns NIL) NIL 

(cons (f (head ns)) (fold (f (tail ns))) ) 
in apply 5 

In this case both apply, and fold are the supercombinators: 

$constr m n = IF (> n m) NIL 

(cons n ($constr m (+ n 1))) 

$fold f ns = IF (= ns NIL) NIL (cons 

(f (head ns)) 

($fold f (tail ns)) ) 



Chapter 16; Supercombinators 



207 



$apply m = $fold SQUARE ($constr m 1) 
$Prog = $apply 5 

$Prog 



16.9 



a) Notation as the abstraction is the following: 



letrec f = g 2 

g = [x] . [y] . * y (SQUARE x) in * (f 3) (f 1) 



Evaluation of expression: 



* (i 


3)(f 1) 


— > 








— > 


(. 3)(. 


1) 










. .- 


— > ( [x] . [y] . * y 


(SQUARE 


0)2 


— > 


* (. 3)( 


. 1) 















.— > ([y] . * y (SQUARE 


2)) 




— > 


* ( 


3)( = 

> 


K 1 (SQUARE 2)) 
( [y] . * y (SQUARE 


2)) 






— > 


* ( 


3) ^ 

> 


1 
( [y] . * y (SQUARE 


2)) 






— > 


* ( * 3 


(SQUARE 2)) 4 








— > 


* 12 4 










— > 


48. 













b) This expression is compiled into: 

$g X y = * y (SQUARE x) 

$f = $g 2 

$Prog = * ($f 3) ($f 1) 



$Prog 



208 



Chapter 16; Supercombinators 



A sequence of reductions: 



$Prog — > (* (. 3)(. D) 

. .— > ($g 2) 

— > * (. 3) (* 1 (SQUARE 2)) 

.— > ($g 2) 
— > * (. 3) 4 

.— > ($g 2) 
— > * (* 3 (SQUARE 2)) 4 
— > * (* 3 4) 4 
— > * 12 4 
— > 48. 



16.10 



* (f 3)(f 1) — > 
— > * (. 3)(. 1) 

. .— > (([x].[y].* y (SQUARE x)) 2) 

— > * (. 3)(* 1 .) 

. .-— > ([y].* y (SQUARE 2)) 

— > * (. 3) 4 (* 1 .) 

. .— > ([y].* y 4) 

— > * (. 3) 4 

.— > ([y] .* y 4) 
— > * (* 3 .) 4 

.— > 4 
— > * 12 4 
— > 48 



The expression — > (SQUARE 2) is evaluated once. 

16.11 

The function g contains an abstraction: 

[x] . [y] . * y (SQUARE x) 



Chapter 16; Supercombinators 209 

Next: 

( 1 ) the innermost abstraction is 

[y] . * y (SQUARE x); 

(2) (SQUARE x) is MFE, which is shifted as an extraparameter: 

( [SQUAREx] . [y] . * y (SQUAREx)) (SQUARE x) 
Substitute this expression into the abstraction: 

[x] . ( [SQUAREx] . [y] . * y (SQUAREx) ) (SQUARE x) 

(3) assign to obtained supercombinatorthe name: 

$gl = [SQUAREx] . [y] . * y SQUAREx 

[x] .$gl (SQUARE x) 

(4) [x] .-abstraction is also a supercombinator, which is named 
by $g and assigned to the compiled code: 

$gl SQUAREx y = * y SQUAREx 

$g X = $gl (SQUARE x) 

$f = $g 2 

$Prog = * ($f 3)($f 1) 



$Prog 

16.12 

This program is compiled into: 

$el el n s = (IF (= n 1) (head s) (el (- n 1) (tail s))) 
$g X = letrec el = $el el 

in (cons x (el 3 (A,B,C)) ) 

(cons ($g R)($g D) 



210 Chapter 16; Supercombinators 



Since a definition of el does not depend on x, the letrec can be 
shifted for el: 



letrec el = [n] . [s] . (IF (= n 1) (head s) 

(el(- n l)(tail s))) 
in let g = [x] .cons x (el 3 (A,B,C)) 
in (cons (g R) (g L)) 

As a result of applying the lambda-lifting obtain: 

$el n s = (IF (= n 1) (head s) (el (- n 1) (tail s))) 
$el3 (A,B,C) = $el 3 (A, B, C) 
$g X = cons X $el3 (A,B,C) 
$Prog = cons ($g R) ($g L) 

$Prog 

New combinators, the parameters of which are the MFEs, are 
generated in a process of compiling a programm. In other words, 
compiler performs the assigning by that way of indicating the objects 
in a program source code, which is implemented, generating the indi- 
vidual objects. Since the generated objects are the combinators, then 
it is safety to add them to shell system as the new instructions. All 
the generated combinators give rather individualized representation 
of the source program: this is a system of objects. 

Possibly, it would be better to explain in terms of assignment of a 
shell system (A-calculus) with the set of MFEs. Then, as a concept, 
A-calculus gives a system of individuals (of compiled programs): 
they form an equivalency class (are converted to each other) relatively 
the criteria of an optimum. 



Chapter 17 

Lazy implementation 



Whenever the objects are generated in dynamics "on fly", then an ef- 
ficiency of the resulting code could be lost for the multiple evaluations 
of the same object. The mechanisms of lazy evaluation allow to avoid 
this inefficiency: if the value of an object is obtained once, then namely 
this value will be used in the future. 

17.1 Tasks 

Task 17.1. For a sample definition 

el n s = if n = 1 then (hd s) else el (n — 1) (tl s) fi, 

where the function el returns n-th element of a list (finite sequence) 
s, find the supercombinators, resulting in a fully lazy implementation, 
and perform the particular case el 2. 

Task formulation. Some definitions are to be introduced. As turns 
out, the expressions which are repeatedly evaluated can be easily 
identified. This is true for any subexpression of A-expression, which 
does not depend on bound variable. Such expressions are called free 
expressions of A-expression (similar to the notion of free variable). 

211 



212 Chapter 1 7; Lazy implementation 

Free expressions that are not a part of any other bigger free expression 
are called maximal free expressions of a A-expression (MFE). 

Consider a scheme of translation. The maximal free expressions 
of every A-expression are transformed into the parameters of the cor- 
responding combinator. Consider a scheme of translating maximal 
free expressions into the parameters of corresponding combinator. 

Note. At first, we establish that this translation scheme is valid, i.e. 
the actual combinators are derived and every A-expression is replaced 
by the applicative form. Consider an applicability of this new scheme 
to the A-expression, which body is an applicative form. Such a com- 
binator that is so generated should conform the definition, because its 
body is to be an applicative form and is to contain no free variables. 
Body of a combinator will wittingly be an applicative form because it 
is, in turn, generated from the applicative form (from a body of source 
A-expression) by substituting new parameter names instead of some 
of the expressions. It cannot contain any free variables, because a 
free variable should be a part of some maximal free expression and, 
therefore, will be eliminated as a part of parameter. All of this con- 
firms that an actual combinator is constructed. The final result which 
replaces a source A-expression, is a new combinator, that is applied 
to maximal free expressions, each of them came already into being as 
an applicative form. 

Solution. Turn back to the initial task. 

lazy— I. Let maximal free expressions for the initial expression 
Xs.el n s = Xs.if (= n l){hd s){el{— n l){tl s)) 

be 

p = {if{= n 1)) and q = {el{— n 1)). 

Therefore, a new combinator alpha is defined by 
alpha p q s ^ p (hd s) (q (tl s)). 



Chapter 1 7; Lazy implementation 213 

Note, that in this case 

Xs. alpha p q s = alpha p q -^ Xs.p (hd s) (q (tl s)). 
Since, now 

Xs.elns = Xs.if {= nl){hd s)(el(— nl){tl s)) 

= Xs.p (hd s) (q (tl s)) = alpha p q = el n, 

then 

el n = alpha (if (= n 1)) (el (— n 1)) . 

p q 

From this the following result is derived: a definition of the 
function el is the expression 

el = Y (Xel.Xn. alpha (if (= n 1)) (el (— n 1))). 

Continuing this process, we obtain the additional combinators 
beta and gamma, defined by: 

beta el n -^ alpha (if (= n 1)) (e/(— n 1)), 

el n 

gam^ma el -^ beta el, 

from where conclude, that the expression el is equal to the 
expression (Y gam,m,a), i.e. el = Y gam^ma, that coincides 
with the previous result' . 

lazy— 2. Consider now a particular case, when {el 2) is applied: 

el 2 -^ {Y gam,m,a) 2 

el 

-^ gamma el 2 

— > beta el 2 

-^ alpha {if {= 2 1)) {el {- 2 1)). 



' Indeed, gamma el = el, from where el = {Xf .{gamma /)) el. By a fixed point 
theorem (see Theorem 9.1 on p. 123) el = Y (\f .{gamma /)) = Y gamma. 



214 Chapter 1 7; Lazy implementation 

Any time, when {el 2) is used, the same copies of free variables 
are involved, hence, they are evaluated only once. In fact, the 
following reduction is obtained: 

el 2^ alpha if -FALSE (alpha if -TRUE (el (- 1 1))). 

In more details: 

el 2^ alpha (if (= 2 1)) (e^ (- 2 1)) 
-^ alpha (if -FALSE) (el 1) 

-^ alpha (if -FALSE) (alpha (if (= 1 1)) (el(- 1 1))) 
-^ alpha (if -FALSE) (alpha (if -TRUE) (el (- 1 1))) 

The scheme considered above leads to the suboptimal combinators. 

Exercises 

Exercise 17.1. For the expression 

fac n = if n = then 1 else n x (fac(n — 1)) 

perform a fully lazy implementation, using the supercombinators, and 
execute fac 3. 



Chapter 18 

Permutation of parameters 



Using of combinators opens the abilities to generate optimized pro- 
gram code, in passing the synthesis of resulting object making an 
analysis of order of possible replacement of the formal parameters by 
the actual ones. 



18.1 Task 

Task 18.1. For the initial definition: 

el = Y (Xel.XnXs.IF (= n 1) (hd s) (el (- n 1) (tl s))) 

derive an expression with optimal (by two criteria) ordering of super- 
combinator parameters. 

Task formulation. Remind, that two main criteria of the optimal 
ordering of supercombinator parameters are the number of MFEs and 
maximal elimination of redundant parameters. The given definition 
should be successfully optimized by both of the criteria. 

Note. For maximizing the length and minimizing the number of 
MFEs of the currently nested A-expression, all the MFEs in A- 
expression being compiled, that in the same time are free expressions 

215 



216 Chapter 18: Permutation of parameters 

in the next nested A-expression, should appear before MFE, having 
no such property. An optimal parameter ordering by this criterion 
can be formulated as follows. All Ei are free expressions of the A- 
expression, which has to be compiled, however it can be free expres- 
sion of one or more number of nested A-expressions. The innermost 
A-expression, in which the expression Ei is not free, will be called 
a generating A-expression. If generating A-expression Ei includes 
the generating A-expression Ej, then in an optimal ordering Ei is 
a predecessor of Ej. From this it does not follow, that an optimal 
ordering is with a necessity unambiguously determined, because 
the expressions with the same generating A-expression can occur 
in any order. Nevertheless, any ordering, conforming this condition, 
is optimal, as any other one. 

Solution. 

opt— I. First of all take into account the result of solving the 
task 17.1 on p. 211. 

opt— 2. Assume the applicative form 

(alpfia {tid s) n (tl s)), 

in which the parameters of alpha can be arranged in any or- 
der. In case the immediately nested A-expression binds n, then 
maximal free expressions (MFEs) of this form is as follows: 

(alpha (hd s)) (tl s). 
In case a reordering of the form 

(alpha (hd s) (tl s) n), 
is performed, then MFE is unique: 

(alpha (hd s) (tl s)). 



Chapter 18; Permutation of parameters 217 

opt— 3. If, on the other hand, an immediately nested A-expres- 
sion binds s, then an optimal parameter ordering is 

(alpha n (hd s) (tl s)), 

from where the only MFE is (alpha n). 

opt— A. Having obtained an optimal ordering by one criterion, 
consider the next of them. As the "only" parameters the follow- 
ing ones 

alpha, beta, el, hd, tl. 

can be accepted. 

A mission of the compiler is to arrange parameters so that to 
achieve a maximal elimination of redundant parameters. The 
only case in which compiler has a choice is when a combinator 
is directly defined as a call of other one. As an example consider 
the reduction: 

beta p q r s ^ alpha ... s ... . 

There are no redundant parameters besides the last one, but 
the last parameter of a combinator should always be a bound 
variable of the A-expression, from which a derivation was done. 
In this case parameter s is a bound variable of the A-expression, 
that immediately includes alpha. If the parameters have already 
been optimally ordered by the rules above, then all the param- 
eters, in which s participates, are shifted to the end of its list 
of parameters. If there is the only such a parameter, and this 
is s, then s becomes a redundant parameter beta and can be 
eliminated. By this reason a call alpha should be determined in 
form of 

(alpha El . . . E^ s), 



218 Chapter 18: Permutation of parameters 

where s has no occurrences in any of the expressions Ei. 

This means, that all Ei are free in beta, that spreads over 
{alpha El ... En s). Hence, in fact, if there are any Ei, then 
beta should be defined by reduction 

betap s ^ p s, 

where p corresponds to {alpha Ei ... En s). 

If alpha has the only parameter s, then beta should be defined 

by 

beta s ^ s. 

In the first case beta equals to the combinator /. The A-expres- 
sion, generating 6eto, is replaced by an application 

{beta {alpha Ei . . . En s)), 

i.e. by (/ {alpha Ei ... En s)). Besides that, beta can be 
entirely omitted, and A-expression is replaced immediately by 
{alpha El . . . En s). 

In the second case beta is equal to alpha. It can be seen that 
optimal ordering, obtained by the second criterion, also con- 
forms to the first one and, besides that, significantly simplifies a 
mission to find the redundant parameters. 

opt— 5. The considered expression el is defined by equality: 

el = Y{Xel.Xn.Xs.IF {= n 1) {hd s) {el{- n 1) {tl s))). 

The innermost A-expression has two MFEs: 

{IF{= nl)) {el{-nl)). 

Assume them as the parameters p and q. Both of these MFEs 
have the same generating A-expression, hence, their ordering 
is immaterial, and alpha can be defined by reduction: 

alpha p q s ^ p {hd s) {q {tl s)), 



Chapter 18; Permutation of parameters 219 

therefore, 

el = Y{\el.\n. alpha {IF (= n 1)) {el{- n 1))). 

It appears now, that the next A-expression has the only MFE 
and this is el. Hence, beta is defined by reduction 

beta el n ^ alpha (IF (= n 1)) (el (— n 1)), 

according which 

el = Y{Xel.beta el). 

Next, the reduction 

gamma el -^ beta el, 

should be applied, and, since combinator gam,m,a is equal to 
combinator beta, then gam,m,a should not be generated. 

Finally, obtain that gam,m,a is equal to (Y beta). 

Exercises 

Exercise 18.1. Derive the expression with optimal ordering of super- 
combinators for the definition: 

fac n = IF n = then 1 else n x {fac{n — 1)). 

Test 

Try to give answers to the following questions. 

1. Define the notion of 'lazy evaluation in A-calculus' and 'full 
lazyness' in the language of CAFs and indicate a connection of 
them. 



220 Chapter 18: Permutation of parameters 

2. Determine a meaning of 'MFE of A-expression'. 

3. What is the final resuh of replacing the initial A-expression in a 
fully lazy implementation of supercombinators? 

4. What are the advantages of using the rules of optimization? 

5. Give a formulation of two main criteria of optimization. 

6. What are the consequences of the ordering of parameters of 
supercombinators? 



Chapter 19 

Immediate computations 



In this chapter a method of evaluating expressions is revised using 
systematic construction of the set of both syntax and semantic equal- 
ities, that implement considered paradigm of object-oriented compu- 
tations. 



19.1 Task 

Task 19.1. For the expression: 

let X = plus in x (4, (x where x = 3)); ; 

construct A-expression and expression of a combinatory logic, and 
evaluate them. 

Solution. 

do— I. Write the expression: 

let X = plus in x (4, (x where x = 3)); ; 

dc—2. Re-write it in a form of A-expression: 
M = {\x.x{A, {\x.x)2,)) + . 

221 



222 Chapter 19: Immediate computations 



dc—3. Make the preparations to translate this expression into a 
language of combinatory logic (CL), i.e. perform the currying: 

N = {Xx.xA ((Aa;.a;)3))ffi, 

where the symbol of addition '©' is distinct from the symbol 
'+'. In the meanwhile put aside a discussion of their differences 
till the topics on the expression evaluation using categorical 
abstract machine will be considered. 

dc—4. Remind that a procedure of translating into CL is de- 
fined by induction: 

(i) Xx.x = I, 
(ii) Xx.c = Kc, c^ X, 
(iii) Xx.PQ = S{Xx.P){Xx.Q). 

Thus, 

N = {Xx.x4:{{Xx.x)3))® 

= S{Xx.x4){Xx.{{Xx.x)3))® 

= S{S{Xx.x){XxA)){S{Xx.{Xx.x)){Xx.5))® 

= slsi{K 4)){S{Xx.I){K3))® 

= S{SI{K4)){S{K I){K5))®. 

dc—b. Application of this procedure results in 

N = S{SI{K A)){S{K I){K 3))ffi, 
where Sxyz = xz{yz), Kxy = x, Ix = x. 

dc—6. Using any of the ways to evaluate it, results in the num- 
ber'?': 

SiSI{K4:)){S{KI){K3))® -^ 

-^ {SI{K 4)®){S{K I){K 3)ffi) 

^ {I®){K A®){S{K I){K 3)ffi) 

-^ ®{K A®){S{K I){K i)®) 

-^ ®A{S{K I){K 3)ffi) ^ ®A{K I®){K3®) 

-^ ®4{I{K 3ffi)) ^©43^7. 



Chapter 19; Immediate computations 223 

It is easy to verify this result by an immediate /3-reduction of the A- 
expression: 

M = {\x.x{A, (Aa;.a;)3))+ -^ +(4, {\x.x)?>) -^ +(4, 3) -^ 7, 

(pay attention one more time to the using of the addition symbol: '+' 
is used instead of 'ffi'). 

Exercises 

Exercise 19.1. Express by the combinators K and S the object / 
with a combinatory characteristic la = a. 

Hint. Use the equality / = Xz.z. Derive the expression Xz.z = 
{\xyz.xz{yz)){Xxy.x){\xy.x) and remind that K = Xxy.x, S = 
Xxyz.xz{yz). 

Answer. I = SKK. 

Exercise 19.2. For the expression: 

let X = tt/2 in let z = sin in sqr{z x);; 
construct the expression of combinatory logic and evaluate it. 
Hint. 

1. A-expression is the following: 

{Xx.{Xz.sqr{z x))sin)TT/2 = 

= {Xx.sqr{sin x))n/2, (/3) 

= sqr{sin 7r/2). (/3) 

2. Use a fact that 

f{9x) = {fog)x = S{KS)Kfgx. 

Answer. S{KS)K sqr sin tt/2 = 1. 



224 Chapter 19: Immediate computations 

Test 

1. Write the combinatory characteristics of the standard combi- 
nators K, I, S, B, W, C. 

2. What are the reasons to use combinatory logic to implement 
/3-reductions? 



Chapter 20 

de Bruijn's encoding 



In this chapter the method of rewriting the bound variables (formal 
parameters) is introduced, which allows to avoid the collisions of 
binding while replacing the formal parameters by the actual ones. 
This way of rewriting is called as de Bruijn's encoding and allows, 
in fact, use A-calculus on the same rights as combinatory logic. 



20.1 Tasks 

Task 20.1. For the expression: 

let X = plus in x (4, (x where x = 3)); ; 

construct the A-expression and expression of de Bruijn's encoding, 
and evaluate the last expression using S EC D-mach'me. 

Task formulation. It is known, that performing the A-conversions 
leads to the collisions of variables. E.g., "direct" execution of (3- 
reduction for {\xy.x)y could give \y.y: 

{\xy.x)y = Xy.y, 

225 



226 Chapter 20: de Bruijn's encoding 

that is completely inappropriate, because: 

{Xxy.x)y = {Xuv.ujy = (Xv.y) 
/ (Ay.y) = /. 

Note, that in a closed term the significantly important knowledge of 
a variable is the depth of its binding, i.e. the number of symbols A 
between the variable and its binding A (excepting the last operator). 
Then the variable is replaced by the number, which, however, should 
be distinguished from the usual natural number. To distinguish the 
numbers, replacing the variables, from the usual natural numbers the 
first of them will be called de Bruijn's numbers. Now, e.g., for 

P = \y.{\xy.x)y 

de Bruijn's encoding is of a form: 

A.(AA.1)0. 

Say, the rule (/3), when applied to this expression, results in AA.l, and 
it is not necessary to transform Xxy.x into Xxv.x, which eliminates 
the collision. Main topic is to describe a meaning of the expressions. 
This depends on the associations between the identifiers and their 
values, i.e. on an environment. Thus, evaluation of M is the function 
||M||, which associates the value with an environment. Consider the 
usual semantic equalities, where the application of a function to its 
argument is represented just by writing the symbol of function fol- 
lowed by the symbol of argument: 

lla^lleni; = env{x), 

\\c\\env = c, 

\\{M N)\\env = ||M||eni; (||iV||enf), 

||A2;.M||enf d = ||M||eni; [2; ^ d], 

where: 



Chapter 20; de Bruijn's encoding 



227 



env{x) - value of x in the environment env; 

c - constant, denoting the value, also be 
called c, what is in accordance with the 
usual practice; 
env[x ^ d] - environment env, where x is replaced by 
the value d, i.e. a substitution of d in 
place of X in env has been done. 

In general, de Bruijn's formalism can be considered by the same way 
as a combinatory logic with a suitable adaptation of the rules. To 
transit from the usual A-expressions to encoding the variables by de 
Bruijn's numbers, consider the needed rules and agreements. 
Let environment env be of form 

(...((), Wn)..., Wq), 

where the value Wi is associated with de Bruijn's number i. This 
assumption uses rather strict restrictions. The environments, where 
the evaluation of expressions is performed, are assumed bound by 
the structures, not by the arrays. This choice is closely linked to 
conforming the demands of efficiency. First of all, this choice leads 
to a simple machine description: 



||0||(eni;, d) 

(n + 1)11(6711;, d) 

\\c\\env 

\\M N\\env 

||A.M||enf d 



= d, 



\n\\env. 



\M\\env{\\N\\env) 
\M\\{env,d). 



The interest is not of the values themselves, but the values from point 
of view the evaluations they support. In a combinatory approach it is 
stressed, that the value of, e.g., M A^ is a combination of the values of 
M and N. 



228 Chapter 20: de Bruijn's encoding 



The following three combinators are introduced: 

S ofarity2, 
A ofarityl, 
' of arity 1 

and infinitely many of combinators n\ in that sense that: 

||n|| = n!, 

||c||ent; = c, 

\\MN\\ = 5(||M||,||iV||), 

||A.M|| = A(||M||). 



From this it is easy to establish a procedure of transition from seman- 
tic equalities to purely syntactic ones: 

0!(a;,2/) = y, 

(n + l)!(a;, y) = n\x, 

{'x)y = X, 

S{x,y)z = xz{yz), 

k{x)yz = x{y,z) 

These rules are near to SK-vu\qs: the first three of them indicate the 
"forgetting" of an argument property (similar to combinator K); the 
fourth rule is the uncurried version of rule S; the fifth rule is exactly 
the currying, i.e. the transformation of a function on two arguments 
into the function on the first argument, which in turn is a function on 
the second argument. 

Introduce also a coupling combinator <•,•>, where 

||(M,iV)||=<||M||,||7V||>, 

and equip it by the pick outers (projections) Fst and Snd. Intro- 
duce in addition the composition operator 'o' and a new command 
£. Consider S (•, •) and n! as the abbreviations for 'eo <•,•>' and 



Chapter 20; de Bruijn's encoding 229 

'Snd o Fst"' respectively, where Fsf^^^ = Fst o Fst"-. List now all 
the combinatory equalities: 



(ass) 


{xoy)z = x{yz), 


ifst) 


Fst{x,y) = X, 


{snd) 


Snd{x,y) = y, 


(dpair) 


<x,y > z = ixz,yz), 


{ac) 


e{A{x)y,z) = x{y,z), 


{quote) 


{'x)y = X, 



where (dpair) is a connection between pairing and coupling, and 
(ace) is a connection between composition and application. It can 
be observed, that S{x,y)z = £{xz,yz). By this a consideration of 
operators Fst, Snd and £ becomes homogeneous. In addition, the 
following equality: 

'M = A{M oSnd), 

is valid, from where it follows that 

{'x)yz = xz. 
Solution. 

DB— 1 . Using the syntax and semantic rules, it can be derived 
for M = {\x.x{A, (Aa;.a;)3))+ : 

M' = WW = ||(A.0(4,(A.0)3)) + II 

= 5(||A.0(4,(A.0)3)||,|| + ||) 

= 5(A(||0(4,(A.0)3)||),|| + ||) 

= 5(A(5(0!,||(4,(A.0)3)||)),|| + ||) 

= 5(A(5(0!, <' 4, 5(A(0!)/ 3) >)), A(+ o Snd)). 



DB-2. Now the evaluation by P. Landin's method for SECD- 
machine will be performed, i.e. M should be evaluated by ap- 
plying M' to the environment. Currently, an environment is 



230 Chapter 20: de Bruijn's encoding 

empty, because the term is closed. In evaluating M' the strat- 
egy of the leftmost and at the same time innermost expression 
will be applied. To abbreviate denote: 

A = 5(0!, <' 4, B>),B = 5(A(0!), 3). 

Consider a complete sequence of reductions: 

(A(^), A(+ o Snd)){) -^ e(A(A)(), A(+ o Snd){)) -^ A env 

here an abbreviation env = ((), A(+ o Snd)0) is used: 

-^ e(0! env, <' 4, B > env) 

-^ e(A(+ o Snd){), ('4 env, B env)) 

-^ e(A(+ o Snd,){), (4, B env)) 

-^ e(A(+ o Snd){), (4, £{A{Ol)env,' 3 env))) 

-^ e(A(+ o Snd)(), (4, e(A(0!)ent;, 3))) 

-^ e(A(+ o Snd)(), (4, Ol{env, 3))) 

^ e(A(+ o Snd){), (4, 3)) ^ (+ o 5nd)((), (4,3)) 

^+(Snd((),(4,3)))^+(4,3)^7. 

Evidently, that this result is the same as the result, obtained in the 
immediate evaluation of the expression. 

Exercises 

Exercise 20.1. Construct de Bruijn's expressions for the A-expres- 
sions below. 

1 ) Xy.yx. Answer. \\Xy.yx\\ = A(iS(0!, l!)). 

2) {\x.(\z.zx)y)((\t.t)z). 

Hint. Denote the initial expression by Q and use the expression R = 
Xzxy.Q. Then, using a tree of representation of R, we can write it in 
the form: R' = (A.(A.01)1)((A.0)2), and by simple replacement of 'A' 
by 'A', 'o' by '5', 'n' by 'n!' can obtain de Bruijn's encoding for Q. 



Chapter 20; de Bruijn's encoding 231 



Answer. Qob(,,,,^) = 5(A(5(A(5(0!, l!))l!)),5(A(0!), 2!)) (theor- 
dering of names in the subscript of Q corresponds to the order of 
their binding in an intermediate expression R and allows to restore 
the initial definition with corresponding free variables). 



232 



Chapter 20: de Bruijn's encoding 



Chapter 21 

Abstract machine: CAM 



In this chapter a special version of computation theory, called cat- 
egorical abstract machine, is constructed. To achieve the goals a 
special version of combinatory logic — the categorical combinatory 
logic is considered. It is represented by a set of combinators, every of 
which has its own meaning as the instruction in a programming sys- 
tem. This embeds in a combinatory logic one more useful application 
— a programming system, based on cartesian closed category. This, 
one more time, allows at a new level revise the connection of operator 
and applicative style of programming. 



21.1 Theoretical background 

Abbreviation 'CAM' is used for 'Categorical Abstract Machine'. As 
can be seen, this name has itself a voluminous sense. 



21.1.1 CAM structure 

At first make a substantiation for the term 'categorical'. Composition 
and identity are used in a category (identity mapping serves for a 
purpose of optimizing), product equipped with coupling <•,•>, and 

233 



234 Chapter 21 : Abstract machine: CAM 

projections Fst and Snd is added in a cartesian category. Curry- 
ing A, applying e and exponentiation, i.e., the means to construe the 
functional spaces, are added in a cartesian closed category (c.c.c). 
The rules listed in the previous chapter allow to evaluate the cat- 
egorical terms of a form M', which are constructed from the combi- 
nators mentioned earlier by applying a term to the environment that 
is constituted from a set of various components: 

1 ) combinators of application and coupling are not used in M'; 

2) application arises when M'() has been written, i.e. whenever a 
categorical term is applied to an (empty) environment; 

3) constructing of a couple is performed any time the rule (dpair) 
is used. 

Machine instructions 

The machine instructions of CAM are constructed as follows: 

static operators are accepted as the basic machine in- 
structions. 

Note at first, that any redex in the rules, used for the reduction of 
M'(), is of form Mw, where w; is a value, i.e. term is in a normal form 
relatively the rules in use. A term M is transformed by de Bruijn, i.e. 
it is de Bruijn's encoding. Next: 

1 . term M is considered as a code, acting on w, where M is con- 
stituted from the elementary components; 

2. projections Fst and Snd are easily added to the set of instruc- 
tions: Fst acts on the value {wi, W2), giving an access to the 
first generated element of the pair, in case it is assumed, that a 
value is represented by a binary tree; 



Chapter 21 ; Abstract machine: CAM 235 

3. for couples an action of < M, A^ > on w; is considered in accor- 
dance with the equality: 

<M,N > w = {Mw,Nw). 

The actions of M and N on w should be performed independently, 
and their results are joined in a tree, the root of which is a couple, and 
leaves are the obtained values wi and W2. In a sequential machine, 
first, the evaluation is executed, e.g., of M. This results in wi. Before 
beginning to execute w, it should be saved in a memory to have an 
ability to restore w in evaluating N, when W2 is obtained. At last, wi 
and W2 are gathered into couple, but it is assumed, that the value wi 
has been saved, and this is executed namely in the same time, when 
w is restored. 

Machine structure 

From the considerations above it follows a notion of machine struc- 
ture: 

T — term as a structured value, e.g., a graph; 

C — code; 

S — stack, or dump (auxiliary memory). 

The machine state is a triple < T, C, S >. 

It follows from the above, that code for < M, A^ > is the following 
sequence of instructions: 

'<' , followed by a sequence of instructions, correspond- 
ing to code M, followed by ',', followed by a sequence of 
instructions, corresponding to code A^, followed by '>'. 

21.1.2 Instructions 

Note, that categorical abstract machine (CAM) makes only the sym- 
bolic transformations, no compiling is performed. This is achieved by 
the following instructions. 



236 Chapter 21 : Abstract machine: CAM 

Instructions < , > 

Consider an action of the instructions '<', ',', '>': 

< : pushes the term onto the top of the stack, 

, : swaps the term and the top of the stack, 
> : makes a couple from the top of the stack and the term, 

replaces the term by the couple just built, and pops the 

stack. 

The particular syntax which is used for making a couple, exactly cor- 
responds to constituting the control instructions. These instructions 
should replace a construction of coupling. Thus, the combining of 
evaluations of M and A^ into the evaluation < M, A^ > is achieved. 

Instructions Fst Snd k{C) 

Respectively machine structure, the projections Fst and Snd can be 
described more exactly: 

Fst : expects a term (s, t) and replaces it by s, 
Snd : expects a term (s, t) and replaces it by t. 

The code for n! is constructed from n and the instruction 'Fst\ fol- 
lowed by the instruction 'Snd\ Any additional efforts are not needed, 
if the following agreement is used: 

take X y, or x\y to denote a composition, which in usual math- 
ematical practice is denoted hy y o x. In currying, the code for 
A(M) is A(C), where C is the code for M. An action of 'A' is 
described as follows: 

A(C) : replaces shy C : s, where C is the code encapsu- 
lated in A; 

notation C : s is the abbreviation of 'A(M)s'. From the rewrit- 
ing rules point of view, the action of 'A' is none, since k{M)w 



Chapter 21 ; Abstract machine: CAM 237 

is a value as soon as tr is a value, hence it can not be rewritten. 
In terms of actions this is reformulated as: 

the action of A(M) on w is A{M)w . 

The description of the command 'A' results in building a closure as 
in the Sii^CD-machine. Indeed, as stressed by the notation C : s, 
the couple is handled as a value, and this couple is built from the 
code, corresponding to a body of A-expression, and the value, that 
represents a declaration environment of the function, described by the 
abstraction. 

Instruction ' 

The additional constants will be used. They are needed as the basic 
constants, when a code for 'C is '(C) with the following action: 

'C : replaces the term by the encapsulated constant C. 

For the constructions like built-in function, e.g., for the symbol of 
addition, the encoding as above is used: 

the code for '(op) is A((op)), where (op) is the instruction 
Snd, followed by 'op'. 

Instruction £ 

Turn back to the application operation from the A-calculus. It can be 
written as eo < M, A^ >. In case a rewriting rule is needed, then the 
following equality is used: 

(eo < M,N >)w = £{Mw, Nw) (= £[Mw, Nw]). 

The last notation includes the brackets and is used in the notations of 
combinatory logic. 



238 



Chapter 21 : Abstract machine: CAM 



Let {Mw, Nw) be evaluated as {wi,W2), that is the action of the 
code, associated to < M,N >. The instruction 'e' is still left which 
gets u)i = A{P)w[ and returns e(A(P)w'^,«;2) = P{w[,W2). 

In terms of CAM, the code corresponding to £o < M, A^ >, is the 
code for < M, N > followed by 'e' with the following effect: 

e gets the term (C : s, t), replaces it by (s, t), and estab- 
lishes prefix C for the rest of a code. 



CAM working cycle 

Before building a complete list of instructions, remind the notational 
agreements for the instruction lists and stack elements: 



an empty list L is denoted by []; denotation [ei; 
the list with n elements ei, . . . , e„; 

a.L writes a in the head of L: 



. ; e„] is used for 



L1@L2 appends L2 to LI. 

The following mnemonic notations are used for convenience and 
listed below depending on their action: 



Fst 


Snd 


< 


5 


> 


£ 


A 


1 


car 


cdr 


push 


swap 


cons 


app 


cur 


quote 



The Table 21.1 is represented to describe the working cycle of CAM. 
Its left side contains the initial states ("old" states), and its right side 
contains the resulting ones ("new" states). In fact, CAM is observed 
as the A-calculus with explicit products. 

In fact, this table describes a programming system with a few 
initial commands (instructions). Note, that among them there is 
no conditional evaluation (conditional branching). This instruction 
should be added using some agreements on the ways of the represen- 
tation, how does categorical abstract machine work. Besides that in 



Chapter 21 ; Abstract machine: CAM 



239 



Table 21.1: CAM working cycle 



Initial 
configuration 


Resulting 
configuration 


Term 


Code 


Stack 


Term 


Code 


Stack 


is,t) 
{s,t) 
s 
s 
s 

t 
t 

{C:s,t) 


car.C 

cdr.C 

{quoteC).C 

{curC).Cl 

push.C 

swap.C 

cons.S 

app.Cl 


S 

S 

S 

S 

S 

s.S 

s.S 

S 


s 

t 

C 

{C:s) 

s 

s 

is,t) 

{s,t) 


C 

C 

C 

CI 

C 

C 

C 

C@C1 


S 

S 

S 

S 

s.S 

t.S 

S 

S 



evaluating recursive definitions, the (implicit) fixed point operator is 
to be used. The additional agreements are to be introduced to achieve 
this goals. 

21.2 Tasks 



Task 21.1. For the expression: 

let X = plus in a;(4, {x where x = 3)); ; 

give its notation in terms of "categorical code" and write the program 
of its evaluation in terms of CAM-instructions. 

Solution. 

CAM— 1 . Use the mathematical notation, which stresses a re- 
lation with the rewriting rules. Let A, B be assumed as the 
notations of codes of A and B respectively, + is an abbreviation 
\ovplus, S{x,y) = S[x,y] = eo < x,y >, ® = {Snd-\-) : (). 



240 Chapter 21 : Abstract machine: CAM 

The resulting evaluations are listed in Table 21.2. Note, that evalu- 
ations start with an empty environment, i.e. in the position of term, 
is written (). The initial term is represented by de Bruijn's encoding. 
In the starting point of computations, the stack, or dump ("auxiliary 
memory") is also assumed as empty []. 

Thus, CAM let us obtain the awaited result by one more way, 
which could be easy implemented. To achieve this goal, take in mind 
that the operation + is not a proper CAM-instruction, but is a built- 
in function of a host programming system. 

Exercises 

Exercise 21.1. Give a representation for the machine instructions of 
CAM to evaluate the expression: 

let X = 3 in {op{7,x) where op = sub). 

Hint. Start with deriving a corresponding A-expression 

{Xx.{Xop.op 7 x)sub)3, 

then, using the postulates of the A-calculus convert it to the form 

{Xop.op{7, {Xx.x)3))sub 

and obtain de Bruijn's encoding: 

5(A(5(0!, <' 7, >S(A(0!)/ 3) >)), A(sn6 o Snd)). 

Now, after rewriting this code by CAM instructions and applying the 
needed transformations, a final answer can be obtained. 

Answer. 4. 



Chapter 21 ; Abstract machine: CAM 



241 



Term 



Table 2 1 .2: CAM computations 
Code 



Stack 






<A{A),A{Snd+) >e 






[] 





A(A),A{Snd+) >e 




[()] 


A:0 


,A{Snd+) > e 




[()] 





A{Snd+) > e 




[A : ()] 


© 


> e 




[A : ()] 


(^ :(),©) 


£ 




[] 


((),©) 


< Snd,<' 4,B » £ 




[] 


((),©) 


Snd,<' 4,B » e 




[((),ffi)] 


ffi 


,<' 4,B » £ 




[((),ffi)] 


((),©) 


<' 4,B »£ 




[ffi] 


((),©) 


'A,B»£ 




KG, ffi) 


ffi] 


4 


,B » £ 




KG, ffi) 


ffi] 


((),©) 


» £ 




[4 


ffi] 


((),©) 


{Snd),'3>£ »£ 




[(G,ffi);4 


ffi] 


5nd :((),©) 


,3> £ » £ 




[(G,ffi);4 


ffi] 


((),©) 


3 > £ >> e 


[Snd 


:(G,ffi);4 


ffi] 


3 


> e >> e 


[Snd 


:(G,ffi);4 


ffi] 


(5nd :((),©), 3) 


e >> e 




[4 


ffi] 


(((),©), 3) 


Snd » £ 




[4 


ffi] 


3 


» £ 




[4 


ffi] 


(4,3) 


> £ 




[ffi] 


(ffi, (4, 3)) 


£ 




[] 


(0,(4,3)) 


Snd+ 




Q 


(4,3) 

7 


+ 

\] 






D 

n 



242 



Chapter 21 : Abstract machine: CAM 



Chapter 22 

Optimizing 
CAM-computations 

A cartesian closed category gives the additional abilities to optimize 
the resulting program code. Besides the properties of combinatory 
logic used as a shell, the special categorical equalities, taken from a 
cartesian closed category as from an application, are applicable. 

22.1 Task 

Task 22.1. For the expression: 

let X = 5 in let z y = y + X in let X = 1 in (zx) x 2; ; 
compile CAM-program and, possibly, optimize it. 
Solution. 

opt— I. Write the initial expression: 

P = let X = 5 in let z y = y + X in let X = 1 in (zx) x 2. 

243 



244 



Chapter 22; Optimizing CAM-computations 



Table 22. 1 : Evaluation of a substitution 



Term 


Code 


Stack 


s 


push. (cur C) .swap.Cl@[cons; e] 


S 


s 


{cur C) .swap.Cl@[cons; e] 


s.S 


C -.s 


swap.Cl@[cons; e] 


s.S 


s 


Cl@[cons;s] 


{C : s).S 


w 


[cons; s] 


(C : s).S 


{C :s,w) 


M 


S 


{s,w) 


C 


S 



Its reduction to the Aexpression results in: 

P = {Xx.{Xz.{Xx.{zx) x2)l){\y.y + x))5. 

Note, that this notation leads to a simple optimizing in a com- 
piling time. This is possible, because the code, corresponding 
to the expression (A.M)iV, is the instruction 'push', followed 
by' cur C" (where C is the code of M), followed by 'swap, fol- 
lowed by the code CI for A^, followed by 'cons' and 'e'. Assum- 
ing, that an evaluation of CI on the term s results in the value 
w, write the main steps of a computation: 

code of ((A. M)iV) = push.cur C.swap.Cl@[cons;s], 
C = code of (M), CI = code of (A^). 

Table 22.1 represents the evaluation. 



Note, that 



||(A.M)iV|| =< A(||M||),||iV|| >s. 



Chapter 22; Optimizing CAM-computations 245 

Consider the means of deriving the optimized code. Besides the 
possible evaluation of expressions relatively the environment, 
as was already considered, it is possible, using the categorical 
combinatory logic, rather naturally simulate the /3-reduction. 
To achieve this goal, a set of rules is used, which are distinct 
from the above, and only the pure "categorical" combinators are 
used, i.e. both coupling and applying are eliminated. A starting 
point is the rule: 

(Beta) eo < A{x),y >= xo < Id,y > . 

A validity of this rule is proved as follows: 

(eo < k{x),y>)t = e(< Aix),y > t) 
= £{k{x)t,yt) 
= x{t, yt) = x{Id t, yt) 
= (xo < Id,y >)t, 

from where the principle of comprehension (Beta) can be de- 
rived. Note, that Id x = x. By the rule {Beta) the expression 

letx = N in M 

is associated with the code 

push. skip. swap@Cl@cons.C, 

where skip replaces Id (with no action). The action of the con- 
struction [push. skip. swap] is the same as of [push], i.e. the 
considered optimization has a sound ground. 

opt— 2. Show, that the optimization of [push. skip. swap] by re- 
placing [push] is valid. Indeed, in terms of A-calculus we ob- 
tain: 

<f,g>=Xt.Xr.r{ft){gt) = Xt.{ft,gt), 



246 Chapter 22; Optimizing CAM-computations 

and also obtain: 

<g>= \t.\r.r{t){gt) = Xt.{t,gt) = Xt.{Idt,gt). 
Replacing / in the first equality by Id, results in: 

< id,g >=< g >, 

that substantiates the introducing of the notation '< • >' for a 
single expression (a special case). Next, 

< Id, g > = [push; skip; swap; g; cons] , 
< g > = [push; g; cons] . 

From that the needed optimization is derived as an equality. 

opt— 3. Let an additional rule be introduced as an optimization 
rule for the code [©]'. The proof for this optimization is not 
difficult. Indeed, the following equalities are valid: 

[©] eo < A(+oS'nd),< M,iV >>= 

= (+ o Snd)o < Id, < M,N » 
= +o < M,N >=< M,N > +. 

In more details: 

(eo < A(+ o Snd), < M, N >)t = 

= e(A(+ o Snd)t, < M,N > t) 
= (A(+ o Snd)t){< M, N >t) 
= {+oSnd){t,< M,N > t) 
= {+{Snd{t,< M,N > t) 
= (+o < M,N >)t, 

from which the needed equality is derived. In addition, a se- 
quence [cons; plus] can be replaced by [plus], if 'plus' is con- 
sidered as a two placed function that takes as its arguments the 



' It turns out, that e.g., the optimization can be done by compiling M -\- N into 
the code {AI, N), followed by 'plus'. 



Chapter 22; Optimizing CAM-computations 247 

term and the top of a stack. It should be noted, that an ability 
of the operation 'plus' to be applied to its arguments is partially 
lost (because the A-term {Xx.Xy. + xy) is replaced by the two 
placed operator x + y, which needs both of the operands at 
once), but this lost of generality for operating is overcame by the 
ability to optimize the particular cases of three- and, generally, 
of n-placed functions. This can be grounded by the following 
rules (the case of three placed functions): 

Xt.{ft,gt,kt) =XtXr'.r'{Xr.r{ft){gt)){kt) = 

= Xt.{< f,g>t,kt) =« f,g>,k>, 

therefore: 

+{M,N,0) = +«M,N >,0> . 

Indeed, 

eo < A(+o5'nd),eo < A(5'nd),<< M,N >,0 >» = 
= +o Sndo < Id, so < A(5'nd),<< M,N >,0 >» 
= + o (eo < A{Snd), « M,N >,0 >>>) 
= + o Sndo < Id,« M, N >,0 ») 
= +o << M,N >,0 > . 

Thus, for initial task the following main steps of computation 
are distinguished: 

s push.Cl@cons.C S 

s Cl@cons.C s.S 

w cons.C s.S 

{s,w) C S 

This optimized computation is based on the identity combina- 
tor, without which the combinatory logic in use is hardly be 
called the categorical one. 



248 Chapter 22; Optimizing CAM-computations 

opt— 4. Turn back to the CAM computations with the term P. 
Use the notation x\y = yoxio save writing of the compiled 
expression. In the following the abbreviations: 

Fst = F, Snd = S, 

will be used. To make all the writings closed, consider the 
derivations in details. A formulation of optimizing principle 
(Beta) will be taken in the form: 

(Beta) < A{X),Y >\ e = xo < Id,y >=< y >\ x. 

A formulation of optimizing principle [©] will be used in the 
form: 

[ffi] < A{+o Snd), < M,N » \s = 

= (+ o Snd)o < Id, < M, N ». 

De Bruijn's encoding gives: 

P = {Xx.{Xz.{Xx.{z x) X 2)l){Xy.y + x))5, 

next 

P' = (A.(A.(A.(10) x2)l)(A.0+l))5 

= (A.(A.(A. x((10),2))l)(A. + (0,l)))5. 

Next the evaluation of P' results in: 

IIP'II = <' 5 >| ||(A.(A(10) X 2)1)(A.0 + 1)11; 

||(A.(A(10)x2)l)(A.0 + l)|| = 

< ||A.(A.(10) X 2)1||,||A.0 + 1|| >e 

< A||A.(10) X 2)1||,||A.0+1|| >e 
(Beta) <||;^g+l||>| ||(A.(10) x2)l||; 



Chapter 22; Optimizing CAM-computations 249 

||(A.(10) x2)l|| = < ||A. (10) X 2)11/1 >e 
= < A||(10) x2||/l >e 
= <' 1 >| 11(10) x2||; 

<||A.0 + 1||> = < All + (0,1)11 > 

= < A <'+,<0!,l! >> e > 

= < A < A(+o5'),< 0!,1! >>£ >; 

=^ <A(+o<0!,l!>) > 
= < A(< 0!,1! >| +) > 

= <A{<S,F\S>\+)>; 

11(10) X 2)11 = < II X II, < 11(1 0)11/2 »e 

= <A(xo5),< 11(10)11/2 >>£ 

=^ xo< 11(10)11/2 > 

= xo << 1!,0! >£/2 > 

= xo << F I 5',S' >£/2 > 

= «F\ S,S>\ s,'2>\ X. 

To save writing use tlie abbreviations. Using the abbreviation 
for D, where D = {< S,F \ S >\ +) and for C, where C = < 
F \ S,S >\ s, obtain: 

IIP'II = <' 5 >|< A{D) >\<' 1 >\< C',2 >\ X. 

To save more writing with CAM-computations use the abbre- 
viations: 

B=<C/2>|x, C =<F\S,S >\e, D=<S,F\S >\+. 

We pay attention, that these re-writings, evidently, have the connec- 
tions with supercombinators. Indeed, every object that is introduced 
as a mathematical notational agreement, is the sequence of CAM- 
instructions. This sequence can be evaluated beforehand (compiled) 
with CAM, and, by need, this result of preliminary evaluation could be 
used in a proper place. It is not difficult to see, that these preliminary 



250 Chapter 22; Optimizing CAM-computations 



computations should be better done not episodically, but using the 
"discipline" of computations^. 



The categorical abstract machine itself is relatively well balanced 
system of "mathematical" computations. These computations with a 
good evidence can be arranged in a table with three columns, which 
represents the current values of term, code and stack. Remind, that 
namely the triple <term, code, stack > is exactly a current state 
(of computation). Thus, a sequence of rows in the table of CAM- 
computations determines the sequence of states of the computation 
process'^ . 



^The methods of optimizing the computations, when it is possible to select 
relatively independent parameters, are developed not only in different versions of "su- 
percombinatory" programming, but are widely used in a functional programming. 
The approaches are distinct in semantics of evaluations; as a rule, a denotational 
semantic with "continuations" is used. It means, that for any well in some sense 
defined computation the "rest of program" is known. 

^From the mathematical point of view a computation can be considered as a 
sequence of states, i.e. as the process in a rigorous sense of this term. This point of 
view is quite in a spirit of the theory of computations by D.S. Scott. 



Chapter 22; Optimizing CAM-computations 



251 



Consider the complete sequence of CAM-computations: 








<'5>< A(D) x' 1 >S 




[] 







'5>< A(D) x' 1 >B 


[0] 


(5) 




>< A{D) x' l> B 


[0] 


(0,5) 




<A{D) x' l> B 




(0,5) 




A(D) x' l> B 


[(0,5)] 


(^:(0,5)) 


X' l> B 


[(0,5)] 


((0,5), i? 


(0,5)) 


<' l> B 




iiO,5),D 


(0,5)) 


'1> B 


[...] 


(1) 




> B 


[...] 


((0,5), i? 


(0,5));i 


B 




((0,5), i? 


(0,5));i 


< C/ 2 > X 




((0,5), i? 


(0,5));i 


C/ 2 > X 


[...; 


1] 


((0,5), i? 


(0,5));i 


<F\S,S>\e,'2> X 


[...; 


1] 


((0,5), i? 


(0,5));i 


F\S,S>\e,'2> X 


[...;...; 


1] 


((^:(0,5 


))) 


,S>\e/2> X 


[...;...; 


1] 


((0,5),i? 


(0,5));l 


S>\e,'2> X 


[^:(0,5));. 




(1) 




>e/2> X 


[^:(0,5));. 




((^:(0,5 


));i) 


£,'2> X 


[• 




((0,5);i) 




D/2> X 


[• 




((0,5);i) 




<S,F\S>+,'2> X 


[• 




((0,5);i) 




S,F\S>+,'2> X 


[((0,5);!);. 




(1) 




,F\S>+,'2> X 


[((0,5);!);. 




((0,5);i) 




F\S>+,'2> X 


[!;• 




(5) 




>+/2> X 


[!;• 




0,5) 




+,'2> X 


[• 




(6) 




/2> X 


[• 




(...) 




'2> X 


[6] 


(2) 




> X 


[6] 


(6,2) 




X 


[] 


(12) 




[] 




[] 



252 Chapter 22; Optimizing CAM-computations 

Exercises 

Exercise 22.1 . Write the optimized program for CAM-computations 
of evaluating the expression: 

let X = 3 in let z = X -\- y in fz where y = 1 where f = sqr. 

Hint. Introduce the A-expression: 

iXx.i\z.iXf.fz)sqr)iiXy. + xy)l))3, 

and obtain its de Bruijn's encoding: 

(A.(A.(A.0 1)sgr)((A.+ 10) 1))3. 

Next, 

5||A.(.. .)(•••), 3||=5(A(||(...)(---)ll)/3); 

||(...)(---)ll = '5(||(...)ll,ll(---)ll); 

||(...)||=A(5(A(5(0!,l!)),||.<?r||)); 
||(...)||=5(A(5(5(|| + ||,1!),0!))/1); 

In the expressions the subscripts will indicate a balance of paired 
parentheses, e.g., 

o(. . .)o, . . . ,6 (. . .)6- 

Write the following: 

5o (A 1 (52 (A3 (54 (As (56(0!, l!)6)5, \\sqr\\)4)3, 

53(A4(55(56(|| + II, 1!)6, 005)4/ 1)3)2)1/3)0 = /?. 

Checking is done by the straightforward computations: 

Rp = 5o(.../3)o/9 

= (Ai(...)ip)('3p) 
= i(---)i(P,3) 



Chapter 22; Optimizing CAM-computations 253 

l(...)l/0' ^ 52(..., ...)2P' 

= s,{..., ..Up'Ai--Mp'A)y, 
4(...)4(/>',i) = s,{... , ...Up', I) 

= Sei... , ...)6ip',l)l 

= A{+oSnd){p',l)p'l 

= (+o5nd)((/9',l),3)l 

= +3 1 = 4; 

s,{...,...Up'a) = a,{...Up'a){M---Hp'A)) 

= 5(...)5((P',4),(A5(---)5(P',4))) 

^ 5(0!, !!)(.. . , ...) 
= A,{...Up',A)A 

= 5(...)5((/>',4),4) 

= {sqroSnd){{p',A),A) 
= sqr{4:) = 16. 

The derived expression R should be optimized by the rules (Beta) and 
[©]. To achieve this goal the following equality: 



S{x,y) = eo <x,y > . 



can be useful. 
Answer. sqr{4) = 16. 

Test 

1 . List the alternative ways to eliminate a collision of variables in 
the A-expressions. 

2. Give the reasons to introducing the composition operator. 

3. Show connection and difference between the notions of 'pair' 
and 'couple'. 



254 Chapter 22; Optimizing CAM-computations 

Hint. It is possible to use the set theoretic definitions of these 
notions, assuming 

f:D^E, g:D^F. 

From this it follows, that 

couple : h =< f,g>:D^ExF; 

pair: [f,g] = (f,g):{D^E)xiD^F). 

4. List three main approaches to implementation of the functional 
programming languages, which the notion of the categorical 
abstract machine is based on. 

5. What are the basic machine instructions of CAM? 

6. Describe the projections Fst and Snd in connection with a 
structure of machine. 

7. Give the formulations of the main rules of optimization. 

8. What are the advantages of using the principles (Beta) and [©] 
in writing a CAM-program? 



Chapter 23 

Variable objects 



In this chapter the general topics of mathematical representation of 
objects are considered. As it shown, the notion of functor-as-object 
allows in a laconic form to revise the main laws of object-oriented 
computations. In particular, an attention is paid to the changeable 
(variable) notions-concepts, that are the usual objects of combinatory 
logic but have the useful in programming properties. For instance, the 
variable concepts, without complications, allow to build not only the 
theory of computations, but a semantic of programming languages, 
and the data object models as well. The notion of data-as-object 
brings in the new extent of the computing derivations. 



23.1 Models 

In such applicative computational system as untyped A-calculus one 
and the same object depending on the context can play both the role of 
an argument and the role of a function which acts on the argument(s). 
If the arguments are taken from the domain D, then the functions are 
to be taken from the domain D ^ D, and, as they can change their 
roles, we need the isomorphism between the domain of arguments D 

255 



256 Chapter 23: Variable objects 

and the domain of mappings D ^ D, i.e.: 

Dc^{D ^ D), 

but, in general, this is impossible. However, in a particular case when 
the domain D ^ D is restricted to the set of functions which are 
continuous in some topology on D, it is possible. As was shown 
by D. Scott ([ ]), to build the semantic of A-calculus which cov- 
ers available in computer science and, in particular, in programming 
computational mechanisms, it is sufficient to take a category of com- 
plete lattices with continuous mappings. In this case it is possible to 
build the object Doo, which is isomorphic to the object Dqo -^ Doo, 
i.e.: 

J-Joc — \J-Joc ^ J-Joo)^ 

that leads to development of the extensional model of A-calculus. 

23.1.1 Applicative structure 

The applicative structure, being simple and conceptually transparent, 
gives a sound ground to formulate, develop and research the variety 
of data models. 

Assume, that all the elements can be gathered into one set, the 
domain D, on which the only operation of application (• •) is defined: 

{■■) : D X D -> D : \fx,y £ D3z £ D.[x,y] ^ zk z= {xy), 

or, in other notations, 

X £ D y ^ D 



{xy)€D 



(••) 



i.e. for any pair of elements x, y from D it can be built the {x y), called 
the 'application of x to y . This pair D and (• •): 



Chapter 23; Variable objects 257 

is called an applicative structure. 

Note that in the literature as a notation for explicit application 
instead of '(• •)' is often used 'e': 

e : D xD -> D : 

\/x,y £ D3z £ D.[x, y] \—> z Sz z = e[xy] = (xy), 

This notation can be equally simplified to: 

e : D X D ^ D , e : [x , y] h^ (x y); 
then the applicative structure will be of form: 

M = iD,e). 

The applicative structure Ai is extensional, if the following condition 

is valid: 

Va, b £ D^x £ D.ax = bx 

a = b 
Note that for the structure M. = {D, e) instead of 'd G D' it is often 
written 'd G A4'. 

Terms 

Consider a class of all the terms in M., denoted by T{M). This class 
is built by induction on complexity of the term is: 

i) class of the terms contains all the variables v\, . . .,Vi, . . .: 

vi,...,Vi,... eT{M); 

ii) class of the terms contains all the constants Ca'. 

ae M 

Ca G r{M) ' 

iii) applicative structure is closed by the application operation, i.e. 

M,N £T{M) 
(MN) £T{M)' 

Here: M, N are arbitrary terms from T(A4). 



258 Chapter 23: Variable objects 

Assignment 

An assignment in the applicative structure M is the mapping p: 

p : variables -^ M., 
i.e. p{vi) G Ad for any variable Vi. 

Evaluation mapping 

Begin with the fixing of applicative structure M and assignment p. 
The evaluation, or interpretation of a term M is the mapping: 

II • ||- : terms x assignments -^ elements from M.. 

An evaluation of the terms from T{M) in JV[ with the assignment 
p is built by induction on complexity of a term: 

i) all the variables x G T{M.) are interpreted as: 

\\x\\p= p{x), 

where p{x) G M; 

ii) all the constants Ca G T{M) are interpreted as: 

\\Ca\\P = a, 

where a G A^; 
iii) the application of a term M to a term N is interpreted as: 

||(MiV)||/.= (||M||p)(||Ar||p), 

i.e., by a principle: 'an evaluation of the application is an appli- 
cation of the evaluations'. 



Chapter 23; Variable objects 259 

The fact, that equality M = A^ of the terms M,N € T{M) is true in 
Ai with the assignment p, is denoted by: 

M,p h M = TV 

and has a meaning of the equality ||M||/9 = || A^||/3. 

As can be seen from a definition of the evaluation ||M||/9, it de- 
pends on the assignment of the values p on the set of free variables 
of M. Thus, in case of closed terms M, when FV{M) = 0, the 
evaluation ||M||/) does not depend on an assignment/), that is denoted 
by||M||. 

Substitution 

One of the most often used constructions in programming languages 
is a substitution. Its sense reveals in performing the assignments. 
Let the assignment p be fixed and take an element a G A4. Then the 
construction 'assignment of a substitution a in place of the variable 
x' is denoted by 'p{[a/x]y and defined as: 

pi[a/x])'^'p'iy)\:^^ "' 'f^""' 



p{y), Ify^x, 
where y is a variable. 

23.1.2 Typed models 

Note, that initially the A-calculus both in a type free and in a typed 
variants have been considered as the means or metatheory to formal- 
ize the notion of a rule or process. To use the types, the syntax of a 
typed language is to be introduced. 

Types 

Type symbols are defined by induction on complexity: 



260 Chapter 23: Variable objects 

i) basic type o ia a type symbol; 
ii) if cr and r are the types, then {a, r) is a type: 
a - type, r - type 



(cr, r) - type 



Variables 



Every variable xi is assigned a type a, and this fact is written by one 
of the ways: 

xf, orxi : a, or ^{xi) = a. 

The objects s, corresponding to the X-terms, which contain a set 
of free variables FV{s) and a set of bound variables BV{s), are 
assigned the types by induction on complexity: 

i) a variable x" is the term of type a, where FV{x1) = {xf}, 
BV{x1) = 0; 

ii) if s is a term of type {a, r), and t is a term of type a, then (s t) is 
the term of type r: 

s-{(^,t) t:a 

{st):r ' ^--> 

a set of free variables in the compound term is the union of the 
sets of free variables in the component terms: 

FV{{s,t)) = FV{s)UFV{t), 

and a set of bound variables in the compound term is the union 
of the sets of bound variables in the component terms: 

BV{{s,t)) = BV{s)UBV{t); 



Chapter 23; Variable objects 261 

iii) if s is a term of type r, and y is a variable of type a, then \y.s is 
the term of type (cr, r) : 

(Xy.s) : (cr,T) 
the variable y is excluded from a set of free in s variables: 

FV{{Xy.s)) = FV{s)-{y}, 
and the variable y is added to a set of bound in s variables: 

BV{{Xy.s)) = BV{s)U{y}. 

Thus, metaoperator of abstraction (A • . •) binds one variable in the 
one term. The set of all the A-terms is denoted by Tm. 

Pre-structure 

A pre-structure is the family 

i{D'^},{e^r}) 

with parameters a, r, where D"^ is a non-empty set, corresponding to 
arbitrary type symbol a, and eo-r is the mapping 

Sar ■■ D'^"'^^ XD" -> D\ Ear ■ [x , z] ^ x{z) 

for a function x G Z)(°"^) and argument z G D'^ , which is valid for all 
the type symbols a, r. 

The pre-structure is extensional, if for the elements x,y G D^"'''^^ 
on arbitrary element z G D'^ from the equality Sarix, z] = Sariy, z] it 
follows, that X = y: 

x,yGD('''^) yz£D''.e„r[x,z] = e„r[y,z] 

X = y 



262 Chapter 23: Variable objects 

Assignment 

An assignment in the system ({_D°"}, {ear}) is the function p with a 
domain constituted of the set of all the variables and such, that 

A set of all the assignments is denoted by Asg. 

If X, y are the variables, then p{-)\^ is determined by: 

^/„ xix ^ f P{x)\l = a, if 2/ = a;, 

Compare with the definition of assignment of a substitution in 23. 1 . 1 
on p. 259. 

Structure 

A structure is the family 

(p-},K4,l|-||-), 

with parameters a, r, where ({D""}, {eo-r}) is a pre-structure, and 
II • ||- is the evaluation mapping 

II • II- : Tm X Asg -> |Jd°", 
which is defined elementwise by induction on term construction: 

i) IKIIp = /'(O; 

ii) ||(st)||/) = eo-T-[||s||/9, \\t\\p\, where term s is assigned the type 
{cT, r), and t is assigned the type a; 

iii ) for any element a G D" the following equality is valid: 

e^^[||(Aa;.s)||/9,a] = \\s\\p\l, 

where term s is assigned the type r, and the variable x is as- 
signed the type a. 



Chapter 23; Variable objects 263 

For arbitrary structure ({D'^}, {so-T-}, II • ||-) write: 
({D-},{e^J)h s = t[p] 

in that case, if 

\\s\\p = \\t\\p. 

Example 23.1. Consider a special case of the structure, denoted by 
Tb: 

that is defined on B. For this structure: 

B" = B, B"^" = B'' ^ B\ e„r[x, y] = x{y). 

This is a sample of the structure of complete type on B. Indeed, for 
the type (ct, t) = (ct ^ r) corresponding domain (a set) of possible 
elements of this type is exactly B'^^'^. Its every element is the map- 
ping of type (T ^ T. On the other hand, B'^ -^ B'^ has as a domain the 
set of all the mappings from B" to B'^ . In the structure of complete 
type it is regarded that these sets are to be likewise. 

Substitution 

If s is a term, a; is a variable, and t is the term of the same type as x, 
the notation 

'[t/x]s 

is read as 

'substitution of term t in place of every free occurrence of x in 

s . 

A substitution is defined by induction on complexity of s as follows: 
for atomic s: 

i) [t/x]x = t; 



264 Chapter 23: Variable objects 

ii) [t/x]y = y for the variables y ^ x; 

for non-atomic s: 

iii) [t/x]{rs) = {[t/x]r){[t/x]{r s)); 

iv) [t/x]{Xx.s) = (Xx.s); 

v) [t/x]{Xy.s) = {Xy.[t/x]s) forthe variables j/ ^ x. 

Substitution is the function Subst from all the variables to terms 
such, that Subst{x) has the same type as x. Similarly, take s{Subst) 
as a notation for the simultaneous substitution of every free occur- 
rence of any variable y in s, i.e. Subst{y). 

Consistency 

Given a structure M = {{D'^}, {eo-t}, \\ • HO prove a theorem of con- 
sistency. 

Lemma 23. 1 . In case the bound variables of the term s and free vari- 
ables of the term t are distinct, i.e. 

BV{s)nFV{t) = 0, 

then the following equality is used to substitute the term t in place of 
the variable x in the term s: 



Proof. For the fixed t by induction on complexity of s. D 

Lemma 23.2. If the variable y is distinct both from free and bound in 
s variables: 

y^FV{s)UBV{s), 

then the following equality takes place: 

^]4p\d= Mp\d- 



Chapter 23; Variable objects 265 

Proof. It follows from Lemma 23. 1 . D 

Lemma 23.3. If the variable y is distinct both from free and bound in 
s variables: 

y^FV{s)\JBV{s), 

then the equality holds: 

M h {\x.s) = {\y.[y/x]s). 
Proof. From Lemma 23.2 it follows that 
e[\\{\x.s)\\p,d] = \\s\\p\- 

= \\[ylAs\\p\l 

= £[\\{Xy.[y/x]s)\\p,d]. 

D 

Lemma 23.4. In case the bound variables of the term s and free vari- 
ables of term t are distinct, i.e. 

BV{s)nFV{t) = 0, 

then the following equality holds to substitute the term t in place of 
the variable x in the term s: 

\\iXx.s)t\\p= \\[t/x]s\\p. 

Proof. From Lemma 23.1 it follows that 

\\iXx.s)t\\p = s[\\iXx.s)\\p,\\t\\p] 

— 5 On' II 

II ii^i||t||p 
/x]s\\p. 

D 



266 Chapter 23: Variable objects 

Lemma 23.5. If the variable x is distinct from any of the free in term 
s variables, i.e. 

x^FV{s), 

then the equality holds: 

II (Ao;. so;) 11/) = \\s\\p. 

Proof. 

e[\\{Xx.sx)\\p,d] = \\{sx)\\p\-^ 

= e[\\s\\p\-^,\\x\\p\-^] 

= s[\\s\\P^d]. 

D 

Lemma 23.6. If M |= s = t, then M \= {\x.s) = {Xx.t). 
Proof. Fix p. Then: 

e[\\{\x.s)\\p,d] = \\s\\p\l 

= wmi 

= s[\\{Xx.t)\\p,d]. 

Theorem 23.1 (soundness). If 

\- s = t, 

then in every structure 

M ^ s = t. 

Proof. By induction on proof of equality s = t, using Lemmas 23. 1 — 
23.6. D 



D 



Chapter 23; Variable objects 267 



23.1.3 Partial objects 

The formal means of logic ought to be used to build data object model. 
But in case of using the standard means they are correct only for 
non-empty domains. A practice of deployment open information 
systems leads to considering the subdomains defined by unsolvable 
predicates. 

Partial elements 

In case of the subdomains defined by unsolvable predicates, which is 
applicable to World Wide Web, the question 

is there the objects x as an element of this subdomain, 

could be unsolvable. As it appears, if we consider more than one sort 
of variables, then logical means should be conformed to operating on 
the domains, relatively which it is impossible to know, neither if are 
they "inhabited", nor if do its elements completely exist. 



A reality arose, when in reasoning with the objects it is not always 
possible to assume their existence. 



In this case a well formed language constructions can mean nothing. 

Predicate of existence 

To the aims of considering the terms which could have no value — the 
meaningless, — a special predicate of existence E is introduced. For 
a term t the construction 

Et 

is read as 't exists'. It is assumed that free variables of the sorts 
of t range the domain of potential, or possible elements, that are 
selected out of the implicit outer domain. 

As known, any domain D of the partial elements can be repre- 
sented as a subdomain of some domain A of total elements, and these 



268 Chapter 23: Variable objects 



last are considered as an objectification of possible elements of the set 
D. Accepting this point of view means the following: 



the predicate of physical existence E enables a selection of actual 
in D elements. 



The usual assumption, used in logic is that the bound variables range 
only over the actual elements. This means that bound variables are 
considered as restricted by the predicate E. 

Similarity between partial elements 

The establishing of any domain assumes that the sentences con- 
cerning the similarity of its objects within this domain can be con- 
structed. As the partial elements are used, then the equality between 
them is considered in the following sense: 

(t = s) D (Et&Es), 

i.e. the established equality of partial elements implies their existence. 

Equality between partial elements 

A deployment of representation of the equality between elements 
begins with that all the elements outside the predicate E are assumed 
as non-existent are considered as equal is their non-existence. More 
formally, the biconditional 

t = s ^ (Et D t = s) & (Es D t = s) 

is accepted. Thus, the equal elements become just the same. 

Extensionality 

A demand of correctness of the predicate definition assumes that they 
are extensional not only relatively identity, but also relatively equality. 



Chapter 23; Variable objects 269 

The other name of this principle is the substitutivity of equal ones: 

[t/x](l)kt= sZ)[s/x](l). (ext) 

Essentially, the relation of equality = and predicate of existence E are 
selected as the initial ones, and equality become derived and is defined 
by the following biconditional 

t= s ^t = skEtkEs. 

Sorts 

The logical means of building data object model are given by a many- 
sorted theory with higher types. It means that higher order structures 
are allowed to build. To achieve this aim any finite sequence of sorts 

iTl,T2, . . . ,Tn) 

is assigned the sort 

[Tl,T2, . . . ,Tn], 

which is assumed as power sort of all the n-ary relations over the 
given sequence of domains. As turns out, the rest of type construc- 
tions can be expressed by the power sorts. 

Descriptions 

In building the logical means, the descriptions — the constructions 
'such ...that ...', — are used among the terms. Such construc- 
tions are suitable, and their usage does not lead to the difficulties, 
because there is a predicate of existence. In this case there is a set 
of terms with the rich expressive power, which can be used in corre- 
spondence with the aims to reach, as was shown in (D. Scott, [ ]) 
and (M. Fourman, [8]). Thus introduced term 

Ix^ 

canonically is read as 

'such X that ^ is valid'. 



270 Chapter 23: Variable objects 



Possible worlds 

The possible worlds are understood as various sets of individuals 
with the additional structure or without it. The terms 'element' and 
'individual' will be used changeably. The distinct sets of individuals 
are identified by the indexed expressions. As known, an arbitrary 
system of structures can be indexed. This is done by a choice as the 
indices the elements of the appropriate set, and this choice can be 
done by the various ways. 

Take some fixed set / of these indices, and also will consider the 
set o[ possible individuals D and virtual individuals V . Next, mark 
by the indices the system of actual individuals Ai, assuming for any 
index i G /, possibly, distinct Ai C D. It is evident, that the following 
inclusion 

Ai<^D<ZV 

is valid, because the virtual individuals are introduced just for increas- 
ing the regularity. Note, that between Ai and i there is no assumed 
one-to-one correspondence, because the elements of the set / can 
have a structure, which is not completely reflected by the distinctions 
of different sets Ai each of other. 

23.1.4 Data object models 

In building the data object models from a formal point of view instead 
of term 'assignment', used on p. 258 and on p. 262, we will use the 
term 'reference', that is relative to a representation of the possible 
world or indexing system. 

Concepts, individuals and states 

Among the objects the concepts, individuals and states will be dis- 
tinguished. These entities are used as the units — the main build- 
ing blocks using which a data object model, or DOM is built. As 
awaited, the additional means to formalize this model are needed, and 



Chapter 23; Variable objects 271 



they are shown in Figure 23.1 . An interpretation of correspondences 
shown in this figure, leads to a formulation of the special approach 
which can be called the conceptualization principle. 

Conceptualization principle 

The interrelation of concepts, individuals and states allows to formu- 
late the main principle of conceptualizationas follows: 



(individual concept)|| = function : references —> individuals. 



i.e. a value of the individual concept can be considered as the function 
from a set of references into a set of individuals. 

It means that to describe concepts the formulae are used which 
identify the functions from references to individuals. In other words, 
a concept is considered as the process in a mathematical sense. Us- 
ing the conceptualization principle above, establish a ground to the 
scheme of investigating the problem domain aimed to choosing and 
fixing of data objects: 



(individual concept) 


G 


individual reference 


individuaireference ^ 


— 


individual 


individual > 


— 


state reference 


state reference ^ 


— 


state 



In the scheme above the following notations are used: 

• symbol '> — ' indicates the transition from invariant to the 
family; 

• notation individual reference Cleans the set of all the map- 
pings from references to individuals, i.e. exponential; 

• notation state reference Cleans the set of all the mappings 
from references to states. 



272 Chapter 23: Variable objects 

The main feature of this scheme is in making a transition from the 
individual concepts (in a language) to the individual concepts in a 
domain. Such a transition is performed by the evaluating function 
II • II •. Next, the concept in PD' is teated as a process, using which 
the individuals are chosen and fixed. An individual is also considered 
as the process allowing to indicate the states. The more neutral is the 
terminology of a kind 'state-metastate', which can be used in place of 
'individual-concept' or instead 'state-individual'. 

Both the principle of conceptualization and the scheme of investi- 
gating the problem domain can be formulated not only at a qualitative 
level, but as the formal diagram, shown in Figure 23. 1 . In accordance 
with this figure, the individual concept is described by the formula <|), 
that is additionally equipped with the description operator I. Remind, 
that the notation 

Ix^{x) 

is considered as the descriptive sentence of a kind: 

'the (unique) x, such that (it has the property) <|)(a;)'. 



Describing the objects 

It turned out that from an intuitive point of view the description opera- 
tor, of course, serves the goals of describing one or another object. At 
first, for such a describing, the evaluation is performed which allows 
the language construction to be corresponded to the object from a do- 
main. To obtain, by this way, the image of of a language construction, 
take into account the reference, that is formally indicated by an index. 
In fixing the individuals of DOM the most important is to conform the 
condition fori G /: 

||Ia;$(2;)||i = d <^ {d} = {d e D\ \\<^(d)\\i = 1}, 



PD — Problem domain. 



Chapter 23; Variable objects 



273 



e 



ft 






<IJ 






n 


'c3 


43 


o 


e 


II 


:3 


^ 


'P' 


-r) 


133 




> 


c 


o 


T-t 


w 


X 


S 









(IJ 






^ 












rr( 






> 


(D 


^^ 




6fi 


C3 




kS 


=s 


Oh 


3 C 


T3 


(L) 


60 ^ 


> 




§ e 


-§ 


o 
o 


^ ^ 




60 d 
o 



t 

< 



60 



a 
o 
o 



t3 



4= 



« 43 





^ 


-j 






nj 


-o 


H 




O 


> 


■c 




+^ 


•n 


o 






^ 


sible 

is of s 


60 


Ul 




< 


H< 




j5 rt 

O 3 




Ul 


V3 


Cl,-^ 


UJ 






^:> 


a 

> 




"2 


CO .a 


60 


1-tH O 
kU (53 


t3 

n 






^ ^M 










Figure 23. 1 : Data object model 



274 Chapter 23: Variable objects 

which is the main characteristic of formalization, where the symbol 
' 1 ' is used as a truth value true. The variants of this principle are well 
known in mathematics, but they are in a considerable degree less used 
in the research area of such a subject as data objects. Indeed, all that 
is said here — this is a singularity of the individualizing the object dby 
the formula <|). The other aspect of characteristic of the formalism is 
the following reason. The descriptions in use have sufficient "selectiv- 
ity" to choose the individual from a problem domain. According this 
reason, the characteristic of DOM formalization, besides the fixing 
individual in a domain, is aimed to establish a connection with the 
systems of symbolic computations. Development and using of the 
systems of symbolic computations leads to applying the notion of a 
function in the sense of definition. Such a research is based on a pro- 
cess of transition from an arguments to the value, when this process 
is encoded by the definitions. The definitions usually are determined 
by the sentences of a researcher language. Next they are applied to 
the arguments, also determined by the sentences of the researcher 
language. In case of computer systems of symbolic computations, 
the definitions are understood like the programs, which, in turn, are 
applied to the programs. Since the objects under research are both 
the functions and their arguments, then an untyped system arises, 
that allows the self-applicability of a function, what is considered im- 
possible for the "usual" mathematical functions. As a main untyped 
system, the A-calculus is usually used, which is based on the notion 
of bound variable, or the combinatory logic, which avoids the notion 
of a variable. 



23.2 The main task 

Give a rather general formulation of the task that could be reduced to 
a creation of the object representation — the data object or meta- 
data object. 



Chapter 23; Variable objects 275 

Task 23.1. Build the object of a given form, using its determining 
properties <l>. 

Task formulation. Establish the definition of an object, using the 
principle of comprehension: 

C = ly: [D]\Jx : D{y{x) ^ $) = {a; : D | $}, (C) 

where [D] denotes a power set (a set of all the subsets) of D. 

Solution. A solution of the main task is based on the diagram shown 
in Figure 23. 1 . A particular application depends on a lot of factors and 
first of all — on the aims of using the object. Among these objects are 
the elementary types and indexed concepts. Besides that, a form 
of resulting object can be changed depending on the computational 
model in use. In the following subsections the different variants of the 
solution of main task are given, and this is a task to construe the data 
object model. 

23.2.1 Elementary types 

Consider the constructing of the definitions of the elementary types. 

Ht{I)—1. Type. Usually type is considered as the subset of a set, 
identified by a sort symbol. Thus, for sort D, the type T is 
determined by the description 

T =ly: [D]\/x : D{y{x) ^ $) = {x : D | $}, 

for which the inclusion T C D £ [D] holds. 

Ht{I)—2. Relation. The data object called a relation, is considered 
as a subset of cartesian product of the domains, identified by the 
sort symbols. Hence, for sorts A, B the relation R is defined by 
the description 

R = Iz: [A, B]yx : A\/y : B{z[x, y] ^ *) 
= {[x:A,y:B]\^}, 



276 Chapter 23: Variable objects 

for which the inclusion R C A x B holds. Here, to avoid com- 
plications, the definition of two placed relation R is considered. 

Ht{I)—3. Value of function. In developing the data bases a signif- 
icant attention is paid to the class of relations called the func- 
tional relations. To reach this aim the definition 

R'{t) = Iy:B.R{[t,y]) 

is introduced where t is a term of sort A. In this case the mem- 
bership R'{t) G B could be written. 

Ht{I)—^- Functional abstraction. This object is distinguished by 
an especially often usage in applicative programming systems 
to indicate the definition of a function. For the variable u of sort 
A and the term s of sort B the functional abstraction is defined 
by the description 

An : A.s = Iw : [A, BJVn : A^v : B{w[u, v] ^^ v = s) 
= {[u,v] \v= s}, 

for which the inclusion Xu.s C A x B holds. 

As it turned out, the means of descriptions have a sufficient power — 
they allow to express the derived operator of abstraction. Note, that 
in combinatory logic the abstraction operator is also expressed by the 
combinators. In this sense a certain similarity between the means of 
combinatory logic and the means of the descriptions can be observed. 

23.2.2 Typed variable objects 

Give a generalization of the means of typed data objects forthe case of 
definition of the sets that vary with the outer conditions. In this case 
the variable concepts are introduced which are the invariants of the 
corresponding object set for given conditions. 



Chapter 23; Variable objects 277 

Ht{I)—1- The conditions are taken into account as an index that 
characterizes the selected reference. The most typical cases of 
the definitions of the variable concepts are to be the unary type 
concept and binary relation concept. 

Ht{I)—2. Variable type concept. It arises in considering the pairs 
reference-individual and corresponds to the description 

C = C{I) = Iz : [I, T]\fi : I\fhi : T{z[i, hi] ^ $) 
= {[i,hi]\<^} C{h\h:I ^T} 
= Ht{I). 

In the case above Ht{I) is considered as a set of all the indi- 
viduals for the references from / and the type T. The definition 
allows a derivation of one particular case that plays a central 
role in building the computational models using the A-calculus. 
In case we take / as T, and individuals are assumed to be con- 
stants, then C maps such an individual h into the singleton {/i}: 

C -.h^h 

and, of course, C{h) G {h}. This immediately implies the 
equality 

C =lc:C ^C, 

i.e. C is the identity mapping Ic with the property 

C = CoC. 

Ht{I)—3. Binary relation concept. As this is the most general 
case of dependency between the objects, then it is not sufficient 
to restrict a consideration by the description 

= 4>{i) 

= Iz : [I, (T, T)] .\fi\fui : TWvi : T{z[i, [ui, vi]] ^ $) 

= {[h[ui,vi]]\<^} 

C {< u,v >\< u,v >: I ^ T xT} 



278 Chapter 23: Variable objects 

The important feature is that u is an element of Ht{I), and v is 
an element of Ht{I), i.e. u G Ht{I), v G H-ril)- Moreover, in 
defining the description for cj) the following equalities hold: 

= Iz: [(/,T),(/,r)].ViVmVm(z[[i,m], [«,««]] ^ ^) 
= {[[hui],[hvi]]\^} 

c {[uM\'^} 

= HTiI)xHr{I). 

Both the expressions for cj) turned out isomorphic and can be put into 
the basis of a type system. 

23.2.3 Computational models 

Consider the typed computational models of data objects. The main 
aim of type systems of DO^ is to apply it for simulating of execution 
either the constructions of DOML'^ or the program that, possibly, 
uses the constructions of DOML. Consider the way of interpretation 
the constructions of pure DOML or the constructions of DOML that, 
possibly, included into the host program, or, visa versa, contain the 
program (the functions) of programming system. This way is based 
on the defining and using the families of applicative pre-structures of 
the kind 

{{Hb},{sbc}) 

for arbitrary types B, C of type system of DO, where H is the do- 
main of objects of type B, and sbc is the applicator of evaluating the 
functions on the argument from Hb- 

Ht{I)—1- Construction of the model. The steps of building the 
computational data object model (CDOM) are as follows: 



"DO is the abbreviation for Data Objects. 

''DOML is the abbreviation for Data Object Manipulation Language. 



Chapter 23; Variable objects 279 

• introduce the functional space as explicit objects in a repre- 
senting category; 

• given the objects A B, build the explicit object (^4 -^ B); 

• equip it, for using, with the applicator mapping ebc '■ {B -^ 
C)xB —> C that given f : B —> C and x : B, returns f(x) : C, 
i.e. f,x^ f{x); 

• in evaluating ft.(a;, y), the mapping operator on two arguments 
h : A X B ^ C, the first of them x is fixed, and h{x,y) is 
considered as a function on y; 

• for connecting h with its values, a special abstractor function 
^ABC is introduced and typed by 

{kABch):A^{B^C); 

• given the operator h and argument x, the abstractor takes a 
form of {kABch){x) : B ^ C that allows to use applicator in 
evaluating on the second argument. 

A significant feature of this CDOM is an ability to use it sep- 
arately for concepts, individuals and states. At the same time, 
CDOM can be applied to the object on the whole. 

Ht{I)—2. Abstraction by two variables. In abstracting on two 
variables, all the features of the approach are revealed that car- 
ried over the case of more variables. To shorten the notation of 
the description, the symbols of sorts are omitted: 

A[a;,y].t = Xzlw\/x\/y{z = [x,y]&i.t = w). 

In turn, w is treated as a relation 

w = I(Nz\/T[d[z,T] *-> $] 



280 Chapter 23: Variable objects 

andr G w'{z). Sincethetermt depending on 2; takes the values 
from w'{z), them assume that t G w'{z). Corresponding or- 
dered pairs [z, t] are put into basis of the definition of the object 

Xz.t = X[x,y].t, 

that gives the needed description. 

Ht{I)—3>. Functional space. This object serves the aims of repre- 
senting of the set of functions from type A into type B that is 
written as the description 

A ^ B = {z:[A,B]\\/x€ A3y G B.z[x,y]} 

or, in more weak form, for sorts A, B and A ^ B. In the 
last case the defining formula has been changed to take into 
account the relation of sorts A, B with the types A, B. 

Ht{I)—^- Applicator. Using two descriptions above, write the de- 
scription for an evaluating morphism: 

£AB = X[z,x]Iy.z[x,y], 

that, given the function 2; G A ^ B and argument a; G A 
returns the value y G B, i.e. 

SAB ■■ [z,x] 1-^ z{x), 

or, more generally, £ab '■ [z, x] \-^ y. 

23.2.4 Indexed objects 

Building of CMDOM"* assumes the choosing and fixing the main 
building blocks of extensible programming environment. Every of 



*CMDOM is an abbreviation for Computational MetaData Object Model. 



Chapter 23; Variable objects 281 

this blocks is the dynamic metadata object in the sense that the refer- 
encing or evolving the events is captured. The steps below, aimed to 
capture dynamics, assume an introducing, by means of the DODL'^, 
a spectrum of MDO*^ that combines the abilities of ACS and type 
systems. The most important of these MDO are the indexed concept 
and indexed relation. 

Ht{I)—1- Indexed concept. Evaluation of the expressions, built as 
A-abstractions, is based on the property of extensibility. This 
property reveals in adding to the environment and tying up the 
individuals, conforming the body of A-abstraction. Considering 
the application (A.<l>)ft., where <|) is the body of A-abstraction, h 
is the individual (individual constant) from a domain, obtain the 
following equality: 

\\{\.^)h\\i= ||$||[i,/ii] 

for the reference i. By this way a tying up the individual h 
with the body of A-abstraction <|) is reduced to building of the 
concept, corresponding ||<|)|| and checkingthe membership h G 
||<|)||. Checking up of the membership is done by a selection 
from the relational Data Manipulation Language. The check- 
ing is performed by the following procedure: 

1 ) the reference i in correspondence with the data base is es- 
tablished; 

2) the type T of the individual h, selected from the data base is 
established; 

3) check up if the individual h does conform to the restriction <|); 

4) select all such individuals h' = hi that generate the extension 
of the concept C'{i) for which the following inclusion holds: 

C'{i) ISA T; 



^DODL means Data Object Definition Language. 
^MDO means MetaData Objects. 



282 Chapter 23: Variable objects 

5) all the selected pairs [i, hi] identify the individuals h in the 
world i of a set / and are accepted as the extension of the vari- 
able concept C(/); 

6) the natural inclusion C(/) C Ht{I) for the variable domain 
i7T(-f), defined by 

Ht{I) = {h\h:I^T} 

is preserved. 

Ht{I)—2. Dynamic of concept. The most effective application of 
the families of indexed concepts is the ability to consider their 
changes depending on the variations in a domain. Let in a 
domains the events evolve along the law / where f : B ^ 
I, i.e. the transition from the world / to the world B is per- 
formed. In this case the applying of the property of extensibility 
in evaluation of the A-abstractions has the specific features. For 
application (A.<l>)/i we obtain: 

||(A.<l>)7^||i = ||<l>||/[6,(/io/)5] 

for the reference i = fb. Thus, the tying up the individual 
h with the body of A-abstraction ^ is not reduced to check- 
ing the membership of individual h to the value ||<|)||, but to 
checking the membership of the image of h under evolving the 
events along the law/ in the world 6 for shifted evaluation ||<l>||/. 
Hence, checking of the membership is performed by the modi- 
fied procedure: 

1 ) the new reference B is established as an alternative to the old 
reference under evolving the events along the law /; 

2) the type T of an image of the individual h, selected out of the 
image of data base under the transformation /, is established; 

3) check if the image of the individual h does conform the re- 
striction <|) in the world b: 



Chapter 23; Variable objects 283 

4) select all such individuals h' = {ho f) that generate an 
extension of the concept C'Ab); the inclusion C'Ab) ISA T 
holds; 

5) all the selected pairs [6, hb] identify the individuals h in the 
world b from the set B and are accepted as an extension of the 
variable concept Cf{B); 

6) the natural inclusion Cf{B) C Ht{B) for the domain 
i7T(B), defined by 

Ht{B) = {h\h:B^T], 

is preserved. 

Ht{I)—3. Static of concept. The boundary case of the law of 
evolving the events is the identity (unitary) mapping. Then 
the notation 

f = li:I^I 

means that the law / of evolving the events does not lead to the 
changes in a domain. In evaluation of the A-abstraction obtain: 

\\{X.<^)h\\i = ||$||i,[i,/ii]. 

Thus, the tying up of the individual h with the body of A- 
abstraction of ^ does not need the modified procedure, but is 
completely similar to the procedure for indexed concept. A 
studyingof concept static leads to an important corollary. Since 
there are no changes neither in a domain (nor in data base D), 
then the references / and D can be seen as identical, assuming 
I = D. Then 

Ci.il) :h^h, 

i.e. the individual h is transformed to itself and 
Ci,(/) = C^,{D) = In. 

On the other hand, obtain Ci,(/) = C{I) and Ci : Ci ^ Ci, 
from where the following rule is derived: 



284 Chapter 23: Variable objects 



indexed concept is similar to identity mapping. 

More detailed, for any concepts A, B and the mapping f : A ^ 
B the following equalities 

A = AoA] f = BofoA, 

which are derivable directly from the equalities and the rule 
above, hold. 

Ht{I)—^- Functorial characteristic of concept. An analysis of 
dynamic and static of the concepts allows to separate the con- 
trol action on the concepts, one one hand, the the system of the 
concepts, on the other hand. It means, that a control performs 
a switching of the system of concepts depending on the law of 
evolving the events. The representation of a system of variable 
concepts leads to the formulation of the functorial charac- 
teristic of the concepts. A significant is the way of taking 
into account the law / of evolving the events — C is similar to 
contravariant functor: 

1 ) the law f : B ^ I \s assumed as a transition from the world / 
to the world B, i.e. from the knowledge level / to the knowledge 
level B etc.; 

2) obtain:/ = 1/ o / o 1^ and Cis = C{B), C\i = C{I); 

3) for the concept C/ = C/(i3) the following inclusion holds: 

Cif) : Cil) ^ CiB); 
Cf C C{B), 

because the type checking T for the individual h and its im- 
age under transformation / preserves a natural inclusion for the 
variable domains: 

C{I) C Hril) = {h \ h : I ^ T}; 
C{B) C Ht{B) = {h\h:B ^T}\ 

Cf = {ho f \ ho f :B ^T}C C{B). 



Chapter 23; Variable objects 285 

Ht{I)—5. Indexed relation. In the above an indexing of the one 
placed concepts was considered. In this case all the important 
features, connected with taking into account the evolving of 
events, were already revealed. However, in case of interac- 
tion with the data base the definition and maintenance of multi 
placed concepts is involved. To simplify the notations consider 
the indexing of two placed concept, corresponding to the binary 
relation. Its complete characteristic follows from the consider- 
ation of application (AA.<l>)m; for the formula <|) and individuals 
u and V. It is obtained: 

||(AA.<l>)m;||i = (||(AA.<l>)||i)(|N|i)(||^J||i) 
= k\\\.(^\\i{ui){vi) 

= {\\\M\[hui]){vi) 

= k\\^\\[i,ui]{vi) 
= \M\[[hui],vi] 

for the reference i. The other way of reasoning is also possible: 

\\{\.^)[u,v]\\i = k\\^\i{\\[u,v]\\i) 
= K\\^\\i[ui,vi\ 
= \\H[h[ui,vi]], 

in applying which it is assumed that <|) is a two placed operator 
(uncurried). The tying up the individual [ui,vi] with a body 
of A-abstraction ^ takes down to building the concept, cor- 
responding ||<|)||, and to checking up the membership [ui, vi] G 
||<|)||. In this case the individual is represented by an ordered 
pair, which every element is defined over the corresponding one 
placed concept: 

\\iX.^i)u\\i = ||*i||[i,H = U({i}); 
||(A.*2)^IK = \\'^2\\[i,vi] = V({i}). 

Checking the membership of individual wi = [ui,vi] to the 
concept ^ = ||<|) II is performed by the following procedure: 



286 Chapter 23: Variable objects 

1 ) the reference i is established in correspondence with the data 
base; 

2) the types T and T of the individuals ui and vi, selected from 
the data base (and paired) are established; 

3) check if the individual wi conforms the restriction <|); 

4) select all such individuals wi that generate an extension of 
the concept (^'(i); the following inclusion 

(/»'(i) ISA (T X T) 

holds; 

5) all the selected pairs [i, wi] identify the individuals w in the 
world i of the set / and are accepted as the extension of the 
variable concept = 0(/); 

6) the natural inclusion 0(7) C Htxt{I) for the variable do- 
main Htxt{I), defined by 

HTxTil) = {w\w:I^iTxT)} 

is preserved. 

Ht{I)—^- Dynamic of relations. A reflection of the changes in the 
domain reveals in the associated changes with the data base. 
Accepting f : B ^ I as a law of evolving the events, apply the 
property of extensibility in evaluating the A-abstractions. For 
the application {X.^)[u,v] obtain: 

\\{X.<^)[u,v]\\i = \\<^\\f[b,{<u,v>of)b]. 

This expression can be written in slightly modified form. The 
essence of this modifying is the following: 

||(A.*iH|(/6) = \\^t\\f[b,{uof)b], 
||(A.*2)^||(/6) = \\^2\\f[b,ivof)b], 

U O f £ Uj, V O f £ Vj. 



Chapter 23; Variable objects 287 

Then 

and 

< u,v > of e (f)f 

forcpf C (i? X T) X (B X T). Therefore, tying up the individual 
w with the body of A-abstraction ^ takes down to checking the 
membership of the image of w under evolving the events along 
the law f in the world b for shifted evaluation ||<l>||f. The details 
of checking are straightforward and are performed according 
the following procedure: 

1 ) as an alternative to the reference i the new reference b for 
the law of evolving the events / is established; 

2) the type T x T of the image of individual w, selected from 
the data base image under the transformation / is estab- 
lished; 

3) check if the image of individual w does conform the re- 
striction <|) in the world b; 

4) select all such individuals < u,v > of which generate an 
extension of the concept (t>'f{b); the inclusion 

(j)'j{b)ISAT: xT 

holds; 

5) all the selected pairs 

[b,{<u,v>of)b] 

identify the individuals 

< u,v > of 

in the world b of the set B, and are accepted as an exten- 
sion of the variable concept (/>j(i?) = (jif-, 



288 Chapter 23: Variable objects 

6) the natural inclusions 

4)f{B) C lJf{B) X \f{B) C Ht{B) X Hr{B) 
for the variable domain Ht{B) x Hq-^B), defined by 

Ht{B) X Hr{B) = {h \li : (B ^ T) X {B ^ T)} 
are preserved. 

23.3 Interpretation of evaluating environment 

The evaluation environment, represented by the objects, in practice, 
usually is equipped with a control structure — the system of scripts, 

— that determines its behavior. The examples of implementations of 
such structures are well known. From an intuitive point of view, a 
script is the system of instructions that determines the transitions 
from one states — the old states of computation, — to other ones 

— the new states. This is rather special treating of evaluations, how- 
ever enabling some suitabilities. Its implementing needs to involve 
the parameterized objects. As a main model of object is taken the 
representation of a variable set — the variable concept, — relatively 
new in computer science representation. The volume of an intuitive 
knowledge on what is the object, is replaced by an idealized entity, 
called functor-as-object. As known, the functors allow to operate 
with the higher order languages when an object is assumed as the 
mapping /rom objects into objects. 

The getting acquainted a notion store and associated methods of 
reasoning as above, not saying of the methods of the implementation, 
is considered as an ability to work at the "cutting edge" of the studies 
in an area of programming. 



Bibliography 



[I] Russian editions: 

[1] Aksenov K-E., Balovnev O.T., Wolfengagen V.E., Voskre- 
senskaya O.V., Gannochka A.V., Chuprikov M.Yu. A guide 
to practical works "Artificial Intelligence Systems" . — M.: 
MEPhI, 1985. - 92 p. (in Russian) 

[2] Barendregt H.P. The lambda calculus. Its syntax and se- 
mantics. — North-Holland Publishing Company: Amsterdam, 
N.Y., Oxford, 1981. 
(Russian edition: Moscow: Mir, 1985) 

[3] Belnap N.D., Steel T.B. The logic of questions and answers. 
— Yale University Press: New Haven, C.T., 1976. 
(Russian edition: Moscow: Progress, 1981) 

[4] Bulkin M.A., Gabovich Yu.R., Panteleev A.G. Methodical 
recommendations to programming and exploitaition of the 
interpretor for algorithmic language Lisp of OS ES. — Kiev: 
NllASS, 1981 . - 91 p. (in Russian) 

[5] Burge W. Recursive programming techniques. — Addison- 
Wesley: Reading, MA, 1978. 
(Russian edition: Moscow: Mashinostroyeniye, 1983) 

289 



290 



3LI0GRAPHY 



[6] CuvryH.B. Foundations of mathematical logic. — McGraw- 
Hill Book Company, Inc.: N.Y., San Francisco, Toronto, Lon- 
don, 1963. 
(Russian edition: Moscow: Mir, 1969) 

[7] Engeler E. Metamathematik der Elementarmathematik. — 
Springer- Verlag: N.Y., 1983. - 132 p. 
(Russian edition: Moscow: Mir, 1986) 

[8] Fourman M.P. Logic of topoi. — In: Handbook of mathe- 
matical logic. — ed. Barwise J., North-Holland Publishing 
Company: Amsterdam, N.Y., Oxford, 1977. 
(Russian edition: Moscow: Nauka, 1983) 

[9] Goldblatt R. Topoi: The categorial analysis of logic. — 
North-Holland Publishing Company: Amsterdam, New York, 
Oxford, 1979. 
(Russian edition: Moscow: Mir, 1983) 

[10] Henderson P. Functional programming: application and 
implementation. — Prentice-Hall: Englewood Cliffs, N.J., 
1980. 
(Russian edition: Moscow: Mir, 1983) 

[11] Hopcroft J.E., Motwani R., Ullman J.D. Introduction to au- 
tomata theory, languages, and computation. — 2nd ed., 
Addison-Wesley Publishing Company: Boston, San Fran- 
cisco, N.Y., 2001. 
(Russian edition: Moscow: Izdatelsky dom "Williams", 2002) 

[12] Ilyukhin A.A., Ismailova L.Yu., Shargatova Z.I. Expert sys- 
tems on the relational basis. — M.: MEPhI, 1990. (in Rus- 
sian) 

[13] Johnstone PT. Topos theory. — Academic Press, 1977. 
(Russian edition: Moscow: Nauka, 1986) 



Bibliography 291 



[14] Kleene S.C. Introduction to metamathematics. — D. Van 
Nostrand Company, Inc.: Princeton, N.J., 1952. 
(Russian edition: Moscow: IL, 1957) 

[15] Kuzichev A.S. Some properties of the Schonfinkel-Curry' s 
combinators. — Combinatorniy analiz, vipusk. 1 ., izdat. MGU, 
1971. (in Russian) 

[16] Kuzichev A.S. Deductive combinatory construction of the 
theory of functionalities. - DAN SSSR, 1973, Vol. 209, 
N° 3. (in Russian) 

[17] Kuzichev A.S. Consistent extensions of pure combinatory 
logic. — Vestnik Mosk. Univers., matem., mechan., N° 3, 
p. 76-81, 1973. (in Russian) 

[18] Kuzichev A.S. On the subject and methods of combinatory 
logic— Istoriya i metodologiya estesvennikh nauk, M.: MGU, 
vipusk 14, 1973, p. 131-141. (in Russian) 

[19] Kuzichev A.S. The system of lambda-conversion with de- 
ductive operator of the formal implication. — DAN SSSR, 
212, N° 6, 1973, p. 1290-1292. (in Russian) 

[20] Kuzichev A.S. The deductive operators of combinatory 
logic— Vestnik Mosk. Univers., matem., mechan., N° 3, 
p. 13-21, 1974. (in Russian) 

[21] Kuzichev A.S. On expressive power of the deductive sys- 
tems of lambda-conversion and combinatory logic— Vest- 
nik Mosk. Univers., matem., mechan., N° 6, p. 19-26, 1974. 
(in Russian) 

[22] Kuzichev A.S. Principle of combinatory completeness in 
mathematical logic. — Istorya i methodologiya estestvennikh 
nauk, sbornik MGU, vipusk 16, 1974. - p. 106-127. (in Rus- 
sian) 



292 



3LI0GRAPHY 



[23] Kuzichev A.S. Combinatory complete systems with the op- 
erators E, F, Q, U, 3, P, -., k, y, =. - Vestnik Mosk. 
Univers., matem., mechan., N° 6, 1976. (in Russian) 

[24] Kuzichev A.S. Operation of substitution in the systems 
with unrestricted principle of combinatory completeness. 

— Vestnik Mosk. Univers., matem., mechan., N° 5, 1976. (in 
Russian) 

[25] Kuzin L.T. Foundations of Cybernetics, Vol. 2. — M.: En- 
ergiya, 1979, 15-9. (in Russian) 

[26] Kuzin L.T. Foundations of Cybernetics. Vol. 1 . Mathemati- 
cal foundations of Cybernetics: Primary for the institutes. 

— 2nd ed., revised and completed. — M.: Energoatomizdat, 
1994. -576 p. (in Russian) 

[27] Maltsev A.l. Algorithms and recursive functions.— M.: 
Nauka, 1965. (in Russian) 

[28] Markov A.A. Impossibility of some algorithms in the the- 
ory of associative systems.— DAN SSSR, 1947, Vol. 55, 
N° 7; Vol. 58, N° 3. (in Russian) 

[29] Markov A.A. On logic of the constructive mathematics.— 
Vestnik Mosk. Univers., matem., mechan., N° 2, 7-29, 1970. 
(in Russian) 

[30] Markov A.A. On logic of the constructive mathematics.— 
M.: Znaniye, 1972. (in Russian) 

[31] Mendelson E. Introduction to mathematical logic. — 
Princeton: N.J., N.Y., Toronto, London, 1964. - 300 p. 
(Russian edition: Moscow: Nauka, 1971) 

[32] Panteleev A.G. On interpretor from the Lisp language for 
ES EVM. - Programmirovaniye, 1980, N° 3, p. 86-87 (in 
Russian) 



Bibliography 293 

[33] Pratt T.W., Zelkowitz M.V. Programming languages. Design 
and implementation. — 4th ed., Prentice Hall PTR: N.J., 
2001. 
(Russian edition: St.-Pb.: Piter, 2002) 

[34] Schoenfield J.R. Mathematical logic. — Addison-Wesley: 
Reading, MA, 1967. 
(Russian edition: Moscow: Nauka, 1975) 

[35] Sebesta R. Concepts of programming languages. — 4th ed., 
Benjamin Cummings: Redwood City, CA, 1998. 
(Russian edition: Moscow: Izdatelsky dom "Williams", 2001) 

[36] Shabunin L.V. On consistency of some calculi of combina- 
tory logic— Vestnik Mosk. Univers., matem., mechan., 1971, 
N° 6. (in Russian) 

[37] Smirnov V.A. (ed.) Semantics of modal and intensiaonal 
logics. — Moscow: Progress, 1981. (In Russian) 

[38] Smirnov V.A., Karpenko A.S., Sidorenko E.A. (eds.) Modal 
and intensional logics and their applications to the prob- 
lems of a methodology of science.— M.: Nauka, 1984.— 
368 p. (in Russian) 

[39] Stogniy A.A., Wolfengagen V.E., Kushnirov V.A., Sarkisyan 
V.I., Araksyan V.V., Shitikov A.V. Development of the inte- 
grated data bases.— Kiev: Technika, 1987. (in Russian) 

[40] Takeuti G. Proof theory. — North-Holland Publishing Com- 
pany: Amsterdam, London, 1975. 
(Russian edition: Moscow: Mir, 1978) 

[41] Wolfengagen V.E. Computational model of the relational 
calculus, oriented for knowledge representation . — M.: 
preprint MEPhI, 004-84, 1984. (in Russian) 



294 



3LI0GRAPHY 



[42] Wolfengagen V.E., Yatsuk V.Ya. Computational model of 
relational algebra. — Programmirovaniye, N° 5, M.: AN 
SSSR, 1985. - p. 64-76. (in Russian) 

[43] Wolfengagen V.E., Sagoyan K-A. Methodical recommenda- 
tions to practical classes in the course "Discrete mathe- 
matics" . The special chapters of discrete mathematics. — 
M.: MEPhl, 1987. - 56 p. (in Russian) 

[44] Wolfengagen V.E., Aksenov K-E., Ismailova L.Yu., Volshanik 
T.V. A guide to laboratory works in course "Discrete math- 
metics. Aplicative programming and supporting technolgy 
for relational systems". — M.: MEPhl, 1988 . — 56 p. (in 
Russian) 

[45] Wolfengagen V.E., Yatsuk V.Ya. Applicative computational 
systems and conceptual method of knowledge systems de- 
sign. - MO SSSR, 1987. (in Russian) 

[46] Wolfengagen V.E., Chepurnova I.V., Gavrilov A.V., Methodi- 
cal recommendations to practical classes in course "Dis- 
crete mathematics" . Special chapters of discrete mathe- 
matics. - M.: MEPhl, 1990. - 104 p. (in Russian) 

[47] Wolfengagen V.E., Goltseva L.V. Applicative computations 
based on combinators and X-calculus.— (The leader 
of project 'Applicative computational systems" Dr. 
L.Yu. Ismailova.) - M.: MEPhl, 1992. - 41 p. (in Russian) 
The basics of applicative computational systems are covered by 
the elementary means that provides the students and postgraduate 
students with short and sound guide that can be used for the 'first 
reading'. During several years this guide in various versions was used 
in the practical works and laboratory works in the corresponding 
partitions of computers science. The topics of using the combinators 
and A-calculus in implementing the applicative computations are 



Bibliography 295 

covered. The needed minimal theoretical background is included, 
and the main attention is paid to solving the exercises that explicate 
the main computational ideas, notions and definitions. To make the 
learning easier, the guide is equipped with the interactive program 
which can be used to support the introductory practical works. 
When using this Teaching Program, it should be taken that the 
solving the problems assumes the additional transformations of the 
epressions aimed to make the optimizations, eliminate the variables, 
and simplify the target executable expression. The applicative 
computations are delivered as a set of such methods and means. 
For the students and postgraduate students of all the specialities. It 
can be used for the initial self studying of the subject. 

[48] Wolfengagen V.E. Theory of computations. — M.: MEPhI, 
1993. -96 p. (in Russian) 

[49] Wolfengagen V.E. Categorical abstract machine.— M.: 
MEPhI, 1993. - 96 p.; - 2nd edition - M.: "Center JurlnfoR", 
2002. -96 p. (in Russian) 

The main attention is paid to analyse in depth the evaluation of the 
programming language constructions. The topics of compiling the 
code, its optimizing and execution are covered using the environ- 
ment of the categorical abstract machine. The series of examples of 
increasing complexity are used. 

[50] Wolfengagen V.E. Programming languages design and a 
theory of computations. — M.: MEPhI, 1993. — 189 p. (in 
Russian) 

[51] Wolfengagen V.E. Programming languages constructions. 
Methods of description.— M.: "Center JurlnfoR", 2001. — 
276 p. (in Russian) 

This book covers the basics concerning the development, implemen- 
tation and application of the constructions both of imperative and 



296 Bibliography 

functional programming languages. An attention is paid to the de- 
notational semantic allowing to reveal completely all the advantages 
of the object-oriented approach, that, after all, gives an ability to 
construe the resulting computational model of pure functional type. 
The detailed solutions for the exercises are included that are carefully 
commented to make it easier to learn the implementations of the 
constructions of various programming languages. 
This book can be used as a guide to the subject. It can be useful for the 
students, postgraduate students and the professionals in computer 
scince, information technologies and programming. 

[52] Wolfengagen V.E. Logic. Synopsis of the lectures: Reason- 
ing techniques. — M.: "Center JurlnfoR", 2001. — 137 p. (in 
Russian) 

This book covers the ways of rewriting the factual text into the 
symbolic language allowing the using of classic logical means. The 
ways and methods to use and validate the argumentation are covered. 
The numerous examples help to study the means of logical reasoning, 
inference and proof. The ways of using the comments in an inference 
are indicated that can assist to establish the truth or false of the 
demonstrated reasons. 

For the students and postgraduate students of the humanities. It can 
be used for the initial study of the subject and also for self studying. 

[53] Yanovskaya S.A. Foundations of mathematics and math- 
ematical logic— Mathematics in the USSR for thirty years. 
I9I7-I947.-M.-L.: Gostechizdat, 1948. (in Russian) 

[54] Zakharyaschev M.V., Yanov Yu.I. (eds.) Mathematical logic 
in programming.— M.: Mir, I99I. — 408 p. (in Russian) 



Bibliography 297 

[II] English editions: 

[55] Nested relations and complex objects in databases.— Lec- 
ture Notes in Computer Science, 361, 1989. 

[56] Amadio R.M., Curien P.-L. Domains and lambda-calculi.— 
Cambridge University Press, 1998. — 484 p. 
This book describes the mathematical aspects of the semantics 
of programming languages. The main goals are to provide formal 
tools to assess the meaning of programming constructs in both 
a language-independent and a machine-independent way, and to 
prove properties about progrms, such as whether they terminate, or 
whether their result is a solution of the problem they are supposed to 
solve. 

The dual aim is pursued: to provide the computer scientists to do 
some mathematics and to motivate of interested mathematicians in 
unfamiliar application areas from computer science. 

[57] Appel A. Compiling with continuations.— Cambridge Uni- 
versity Press, 1992. 

[58] Avron A., Honsel F., Mason I., and Pollak R. Using 
typed lambda-calculus to implement formal systems on a 
machine.— Journal of Automated Reasoning, 1995. 

[59] Backus J.W. Can programming be liberated from the von 
Neumann style? A functional style and its algebra of 
prog-rams.- Comm. ACM, 1978,v.21,N° 8, p. 614-641. 

[60] Backus J.W. The algebra of functional programs: func- 
tional level reasoning, linear equations and extended 
definitions.— Int. Col. on formalization of programming con- 
cepts, LNCS, v. 107, 1981, pp. 1-43. 

[61] Backus J.W., Williams J.H., Wimmers E.L. FL language 
manual (preliminary version).— IBM research report No RJ 
5339(54809), 1987. 



298 



3LI0GRAPHY 



[62] Banerji R.B. (ed.) Formal techniques in artificial intelli- 
gence: a sourcebook.— Studies in computer science and ar- 
tificial intelligence, 6, North-Holland, 1990. 

[63] Beery G., Levy J-J. Minimal and optimal computations of 
recursive programs.— J. Assoc. Comp. Machinery, Vol.26, No 
1, 1979. 

[64] Belnap N.D. (Jr.) /I useful four-valued logic. Modern uses of 
multiple-valued logic— Epstein G.,Dunn J.M. (eds.) Proceed- 
ings of the 1975 International Symposium of multiple-valued 
logic, Reidel, 1976. 

[65] Belnap N.D. (Jr.) How a computer should think.— Con- 
temporary aspects of philosophy. Proceedings of the Oxford 
International Symposium, 1976. 

[66] Bird R.S. An introduction to the theory of lists.— Logic 
programming and calculi of descrete design (ed. Broy M.), 
Springer- Verlag, 1986, pp. 5-42. 

[67] Bohm C. (ed.) Lambda calculus and computer science 
theory.— Proceedings of the Symposium held in Rome. March 
25-29, LNCS, vol.37, Berlin: Springer 1975. 

[68] Bonsanque M. Topological dualities in semantics.— PhD 
thesis, Vrije Universiteit Amsterdam, 1996. 

[69] Bunder M.V.W. Set Theory based on Combinatory Logic— 
Doctoral thesis. University of Amsterdam, 1969. 

[70] Bunder M.V.W. Propositional and predicate calculuses 
based on combinatory logic— Notre Dame Journal of Formal 
Logic, Vol. XV 1974, pp. 25-34. 

[71] Bunder M.V.W. The naturalness of illative combinatory 
logic as a basis for mathematics.— To H.B.Curry: Essays 



Bibliography 299 



on combinatory logic, lambda calculus and formalism.— Seldin 
J.R, Hindley J.R. (eds.), Academic Press, 1980, pp. 55-64. 

[72] Bucciarelli A. Logical reconstruction of bi-domains.— In: 
Proc. Typed Lambda Calculi and Applications, Springer Lec- 
ture Notes in Comp. Sci., 1210, 1997. 

[73] Church A. The calculi of lambda-conversion.— Princeton. 
1941, ed. 2, 1951. 

[74] Coppo M., Dezani M., Longo G. Applicative information 
systems- LNCS, 159, 1983, pp. 35-64. 

[75] Cousineau G., Curien P.-L., Mauny M. The categorical ab- 
stract machine.— LNCS, 201, Functional programming lan- 
guages computer architecture.— 1985, pp. 50-64. 

[76] Curien P.-L. Categorical combinatory logic— LNCS, 194, 
1985, pp. 139-151. 

[77] Curien P.-L. Typed categorical combinatory logic— LNCS, 
194, 1985, pp. 130-139. 

[78] Curry H.B., Feys R. Comfoinatorr/ /ogic— Vol. I.Amsterdam: 
North-Holland, 1958. 

[79] Curry H.B., Hindley J.R., Seldin J. P. Combinatory logic— 
Vol. II. Amsterdam, 1972. 

[80] Curry H.B. Some philosophical aspects of combinatory 
logic— Barwise J., Keisler H.J., Kunen K- (eds.) The Kleene 
Symposium.- North-Holland Publ. Co, 1980, p. 85-101. 

[81] Danforth S., Tomlison C. Type theories and object oriented 
programming.— ACM Computing Surveys, 1988, v.20. No 1, 
pp. 29-72. 



300 



3LI0GRAPHY 



[82] Darlington J., Henderson P., Turner D.A. (eds.) Functional 
programming and its applications.— Cambridge Univ. 
Press, Cambridge, 1982. 

[83] de Bruijn N.G. Lambda-calculus notations with nameless 
dummies: a tool for automatic formula manipulation.— 
Indag. Math. 1972, N 34, pp. 381-392. 

[84] Eisenbach S. (ed.) Functional programming: languages, 
tools and architectures.— Chichester: Horwood, 1987. 

[85] Fasel J.H., Keller R.M. (eds.) Graph reduction.- LNCS, 279, 
1986. 

[86] Fenstad J.E. et al. Situations, language and logic. — Dor- 
drecht: D. Reidel Publ. Comp., 1987. 

[87] Fitting M. First-order logic and automated theorem 
proving.— Springer- Verlag, 1990. 

[88] Frandsen G.S., Sturtivant C. What is an efficient implemen- 
tation of the lambda-calculus?— LNCS, 523, 1991, pp. 289- 
312. 

[89] Friedman H. Equality between functionals.— Proceedings 
of the Symposium on Logic. Boston, 1972—1973.— Lecture 
Notes in Mathematics, 453, 1975, pp. 22-37. 

[90] Gardenfors P. Induction, Conceptual spaces and AL— Pro- 
ceedings of the workshop on inductive reasoning, Riso Na- 
tional Lab, Rpskilde, 1987. 

[91] Henson M.S. Elements of functional languages.— Exford: 
Blackwell, 1987. 

[92] Hindley J.R. The principial type-scheme of an object in 
combinatory logic— Trans. Amer. Math. Soc, 1969, vol. 146. 



Bibliography 301 

[93] Hindley J., Lercher H., Seldin L Introduction to combinatory 
logic— Cambridge University Press, 1972. 
A general introduction which goes fairly deep; primarily mathemati- 
cal. 

[94] Howard W. The folmulas-as-type notion of construction.— 
Seldin J. P., Hindley J.R. (eds.), To H.B.Curry: Essays on com- 
binatory logic, lambda-calculus and formalism.— Amsterdam: 
Academic Press, 1980. 

[95] Hughes R.J.M. Super combinators: a new implementation 
method for applicative languages.— Proceedings of the 1982 
ACM symposium on LISP and functional programming, pp. 1 - 
10. 

[96] Hughes R.J.M. The design and implementation of prog- 
ramming languages.— PhD Thesis, University of Oxford, 
1984. 

[97] Hunt L.S. A Hope to FLIC translator with strictness 
analysis.— MSc dissertation. Department of Computing, Im- 
perial College, University of London, 1986. 

[98] Kelly P.H.J. Functional languages for loosely-coupled mul- 
tiprocessors.— PhD Thesis, Imperial College, University of 
London, 1987. 

[99] Lambek J., Scott P.J. Introduction to higher order catego- 
rical logic. — Cambridge Studies in Advanced Mathematics 7, 
Cambridge University Press, 1986, 1988, 1989, 1994. -293 p. 

[ 1 00] Landin P. The next 700 programming languages.— Commu- 
nications of the ACM, 3, 1966. 

[101] McCarthy J. A basis for a mathematical theory of compu- 
tation.— Computer programming and formal systems (eds.: 



302 



3LI0GRAPHY 



Braffort and Hirshberg), Amsterdam: North-Holland, 1963, 
pp. 33-69. 

102] Michaelson G. An introduction to functionat programming 
through lambda-calculus . — Addison Wesley Publ.Co, 1989, 
320 p. 

1 03] Milner R., Parrow J., Walker D. A calculus of mobile process. 
— Parts 1-2. — Information and Computation, 100(1), 1992, 
pp. 1-77 

104] Mycroft A. Abstract interpretation and optimizing trans- 
formations for applicative programmes.— PhD Thesis, De- 
partment of Computer Science, University of Edinburgh, 1981 . 

105] Peyton Jones S.L. The implementation of functional prog- 
ramming languages.— Prentice Hall Int., 1987. 

1 06] Pitts A. Relational properties of domains. — Information and 
Computation, 127, 1996, pp. 66-90. 

107] Rosser J.B./l mathematical logic without variables.— Knn. 
of Math., vol. 36, No 2, 1935. pp. 127-150. 

108] Schonfinkel M. Uber die Baustein der mathematischen 
Logik.- Math. Annalen, vol. 92, 1924, pp. 305-316. 

109] Schroeder-Heister P. Extentions of logic programming.— 
LNAI,475, 1991. 

1 10] Scott D.S. Advice on modal logic— Philosophical problems 
in logic. Some recent developments.— Lambert K- (ed.), Dor- 
drecht; Holland: Reidel, 1970. 

Ill] Scott D.S. Outline of a mathematical theory of computa- 
tion.— Proceedings of the 4-th Annual Princeton conference 
on information sciences and systems, 1970. 



Bibliography 303 



[1 12] Scott D.S. The lattice of flow diagrams.— Lecture Notes in 
Mathematics, 188, Symposium on Semantics of Algorithmic 
Languages.— Berlin, Heidelberg, New York: Springer- Verlag, 
1971, pp. 31 1-372. 

[1 13] Scott D.S. Some phylosophycal issues concerning theories 
of combinators. — Lambda Calculus and Computer Science 
Theory. — Bohm C. (ed.). Proceedings of the Symposium held 
in Rome, March 25-26, 1975, Lecture Notes in Computer 
Science, Vol. 37, Springer: Berlin, 1975. — pp. 346-370. 

[114] Scott D.S. Identity and existence in intuitionistic logic— 
In: Applications of Sheaves. Berlin: Springer, 1979, pp. 660- 
696. 

[1 15] Scott D.S. Lambda calculus: some models, some philoso- 
phy— The Kleene Symposium. Barwise, J., et al.(eds.). Stud- 
ies in Logic 101, North-Holland, 1980, pp. 381-421. 

[116] Scott D.S. Relating theories of the lambda calculus.— 
Hindley J., Seldin J. (eds.) To H.B.Curry: Essays on combi- 
natory logic, lambda calculus and formalism.— N.Y.<& L.: Aca- 
demic Press, 1980, pp. 403-450. 

[117] Scott D.S. Lectures on a mathematical theory of 
computation.— Oxford University Computing Laboratory 
Technical Monograph PRO- 19, 1981.- 148 p. 

[1 18] Scott D.S. Domains for denotational semantics.— LNCS, 
140, 1982, pp. 577-613. 

[119] Sioy i.^. Denotational semantics: The Scott-Strachey ap- 
proach to programming language theory.— M.l.T Press, 
Cambridge, Mass., 1977.— xxx+414 p. 



304 



3LI0GRAPHY 



120] Stoye W.R. The implementation of functional languages 
using custom hardware.— PhD Thesis, University of Cam- 
bridge, 1985. 

121] Szabo }A.^. Algebra of proofs.— Studies in Logic foundations 
of mathematics, v. 88. North-Holland Publ. Co, 1978.- 297 p. 

122] Talcott C. Rum: An intensional theory of function and 
control abstractions.— Foundations of logic and functional 
programming, LNCS, 306, 1986, pp. 3-44. 

123] Tello E.R. Object-Oriented Programming for Windows / 
Covers W/ndota^s 5.x.— Wiley and Sons, Inc., 1991. 

124] Turner D. A. A New Implementation Technique for Applica- 
tive Languages.— Software Practice and Experience.— No 9, 
1979, pp. 31-49. 

125] Turner D.A. Aspects of the implementation of program- 
ming languages.— PhD Thesis, University of Oxford, 1981 . 

126] Turner R. A theory of properties.— J. Symbolic logic, v. 52, 
1987, pp. 455-472. 

127] Wodsworth C.P Semantics and pragmatics of the lambda 
calculus.— PhD Thesis, University of Oxford, 1981 . 

128] Wolfengagen V.E. Frame theory and computations.— Com- 
puters and artificial intelligence. V.3, No 1, 1984, pp. 1-31. 

129] Wolfengagen V.E. Building the access pointers to a compu- 
tational environment. — In: electronic Workshops in Com- 
puting, Berlin Heidelberg New York: Springer- Verlag, 1998. 
pp. 1-13 
http : //ewic . springer . co .uk/ad.bis97/ 



Bibliography 305 



130] Wolfengagen V.E. Event driven objects. — In: Proceedings of 
the 1st International Workshop on Computer Science and In- 
formation Technologies, Moscow, Russia, 1999, Vol. 1. pp. 88- 
96 

131] Wolfengagen V.E. Functional notation for indexed con- 
cepts. — In: Proceedings of The 9th International Workshop on 
Functional and Logic Programming WFLP'2000, Benicassim, 
Spain, September 28-30, 2000 
http : //www.dsic .upv.es/~wflp2000/ 

132] Zhang The largest cartesian closed category of stable do- 
mains. — Theoretical Computer Science, 166, 1995, pp. 203- 
219. 

133] http://www.rbjones.com 

This Web-resource FACTASIA is aimed "to develop a vision for our 
future and to provide recourses for building the vision and the future", 
and also "to contribute to the values which shape our future and to the 
technology which helps us build it". The partition "Logic" includes 
combinatory logic and \-calculus, bibliography. 
See http: //www. rbj ones . com/rbjpub/logic/cl/ 

134] http: //ling. ucsd.edu/~barker/Lainbd.a/ski .html 
This is an easy on-line introduction in combinatory logic. 

135] http : //www. cwi .nl/~tromp/cl/cl .html 

The guide, bibliography and Java-applet are represented which allow 
to interpret the objects — expressions of an applicative language, — 
that are to be build by the rules of combinatory logic. 

136] http://www.brics.dk 

BRICS — Basic Research in Computer Science. 

This is a Research Center and International Postgraduate School. In 

the chapter "BRICS Publications" the "Lecture Series" is presented 



306 Bibliography 

that covers the courses in 9 main areas: discrete mathmatics, se- 
mantic of evaluations, logic in computer science, computation 
complexity, constructing and analysis of algorithms, program- 
ming languages, verification, distributed computations, criptol- 
ogy and data security. 

[137] http : //www. afm. sbu.ac .uk 
Formal Methods. 

This document contains the references to available Web-resourses 
on formal methods, that are useful for mathematical description and 
analysis of the properties of computer systems. The attention is paid 
to such formal methods that are useful to decrease the number of 
errors in the systems, especially at the early stages of development. 
These methods are complementary to such a method of error detec- 
tion as testing. 

[138] http : //liinwww. ira.uka.de/bibliography/ 
The Collection of Computer Science Bibliographies. 
This collection is accumulated from the different sources and covers 
many aspects of computer science. The bibliography is renewing 
monthly, thus containing the fresh versions. More than 1 .2 mln. ref- 
erences to the journal papers, conference proceedings and technical 
reports are partitioned in approximately 1400 bibliographies. More 
than 150000 references contain URLs to electronic copies of the 
papers available on-line. 

[139] http://www.ncstrl.org 

NCSTRL — Networked Computer Science Technical Reference Li- 
brary. 

This library is created in a framework of the Open Archives Initiative 
(http : //www . openarchives . org). 

[140] http : //xxx.lanl .gov/archive/cs/intro .html 
CoRR — The Computing Research Repository. 
Contains the papers from 1 993 in the computer science area, that are 



Bibliography 307 

classified in two ways: by subject and using the ACM Classification 
Scheme in computing of 1998. The ACM Classification Scheme is 
stable and covers all the partitions of computer science. The subjects 
are not pairwise distinct and do not cover all the topics. Nevertheless 
they reflect in computer science the areas of an active research. 

[141] http : //web . cl . cam . ac . uk/DeptInf o/CST/node 13 . html 
Foundations of Computer Science. 

The lecture notes of University of Cambridge aimed to cover the 
basics in programming. 

[142] http : //web . comlab . ox . ac .uk/oucl/courses/ 
topicsOl-02/lc 
Lambda Calculus. 

The lecture notes of Oxford University that cover the formal theory, 
rewriting systems, combinatory logic, Turing's completeness, and 
type systems. This is a short introduction to many branches of 
computer science, revealing the connections with lambda-calculus. 



308 



3LI0GRAPHY 



Index 



Curry, 147 


C[21,37,58 


unCurry, 148 


CP1,37,59 


'+r 


C[2],37, 58 


a = Xxyz.xy{yz), 89 


q3],37,60 


a= [xyz]{y{xyz)), 82 


F,38 




/ = Xx.x, 157 


Axiom 


7,35 


(FI), 96 


K = Xxy.x, 157 


(FK), 96 


P,38 


(FS), 96 


W, 37, 54 




r, 37, 61,68-71,200 


Basis 


Yo, 38, 70, 71 


I,B,C,S, 120 






Fi,38, 70, 71 


I,K,S, 114 






&, 38 


Cartesian product, 150 


$,37,61 


Category 


^, 37, 55 


C(£), 150 


S,38 


cartesian closed, 161 


3,38 


Characteristic 


-.,38 


combinatory, 46 


V,38 


Code 


addition A, 85 


categorical, 245 


cancellator, K, 50 


optimized, 245 


compositor, B, 50 


Combinator 


connector, S, 50 


B, 37,51 


cut subtraction L, 84 


52,37,56 


duplicator, W, 50 


B^, 37, 57 


identity, /, 50 


C, 37, 53 


minimum min, 84 



309 



310 



Index 



multiplication M, 86 


0,226 


pairing 2?, 83 


1,226 


permutator, C, 50 


Description 


predecessor TT, 83 


1,76 


successors, 82 


Domain 


symmetric difference R, 85 


Ht (I), 275 


Completeness 




combinatory, 75 


Equality 


Composition 


(ac), 229 


fog, 150 


(ass), 229 


Concept, 271 


(dpair), 229 


individual, 271 


(/si), 229 


of predicate, 155 


((7Mote),229 


Constructor 


(snd), 229 


Append, 164 


<Id,g>=<g>,2AQ 


Car, 164 


< M,N > w = {Mw,Nw) 


Cdr, 164 


235 


List, 164 


</,ff> = At.[/(t),ff(t)], 140 


Nil, 164 


[x, y] = Xr.rxy, 140 


Null, 164 


Xxy.xy = Xx.x, 77 


else, 128 


a o b= \x.a{hx), 149 


fi,2\\ 


id a = a, 150 


hd, 201 


Function 


i/, 128,201 


Curry ABC, 145 


if -FALSE, 214: 


Aabc, 140 


if-TRUE,2{4: 


Aabc/i, 140 


in, 221 


©,222 


let, 221 


£o<fco|3, g>:yl X B —f C 


then, 128 


140 


tl, 201 


£BC, 140 


where, 221 


e/, 201, 211 


Couple 


/ac, 202, 214, 219 


</,5>,254 


/i: Ax S^C, 145 


< x,y >, 140 


plus, 221 


Currying 


unCurry, 148 


Curry, 147 


predicate, 155 


de Bruiin's encoding 


Individual, 271 



Index 



311 



Instruction 
car, 238 
cdr, 238 
cons, 238 
cur, 238 
push, 238 
quote, 238 
skip, 246 
swap, 238 

Karoubi's shell 
£, 149 

Language 
Lisp, 164 

Number 

combinatory Zq, 82 
Numeral 

n = {SBY{KI), 87 

n = Xxy.{x")y, 87 

0,88 

1,88 

Object 

Append, 43 
Cor, 43 
Cdr, 43, 89 
Fst, 240, 248 
List, 43 
iViZ, 43, 90 
Null, 43, 89 
Snd, 240, 248 
y, 129 

A, 41, 230, 240 
5,240 
5,229 
£,41,230,240 



SBC- {B^C)xB^C, 151 

append, 4\, 128, 135 

car, 127, 134, 135 

cdr, 128, 134, 135 

concai, 41, 128, 135 

false, 134 

/i : (yi X B) ^ C, Aabc^ : 

A^ (B^C), 151 
identity, 135 
/engi/i, 41,89, 128, 135 
/isi, 134 
/isil,39, 133 
map, 41, 128, 135 
null, 129, 134 
postfix, 135 
product, A\, 128, 135 
ret;erse, 135 
sum,4\, 128, 135 
sumsquares, 135 
times, 127,202 
irwe, 134 
arithmetical 

Zo,82 

A, 85 

L, 84 

M, 86 

M, 85 

min, 84 

TT, 83 

a, 82 
modes of combining, 18 

Pair 

[/,5],254 

[x, y] = Xr.rxy, 157 
[x,y],140 
Pairing 

[x, y] = Xr.rxy, 145 



312 



Index 



Parameter 

actual, 48 

formal, 48 

substitutional, 48 
Postulate 

alpha, a, 35 

eta, rj, 77 

mu, 11, 35 

nu, V, 35 

sigma, a, 35 

xi, ^, 35 
Predicate 

variable, 156 
Principle 

(Beta), 245 

[©], 248 

of comprehension, 155,275 
Projection 

p: A X B ^ A,\AO 

q: A X B^B, 140 

Recursion 

stack, 65 
Reference, 271 
Rule 

(F), 96, 97 

(A), 97 

characteristic, 46 



Xx.P, 40 
Xx.PQ, 40 

Terms 

XV.E, 200 

Theory 

metatheory, 1 1 
subtheory, 1 1 

Type 

#(5), 99 
#(-B2), 104 
#(^3), 105 
#(C),111 
#(CP1), 105 
#(CP]), 106 

#(q2]), 107 
#(q3]), 108 

#(!?), Ill 
#(S'B), 100 
#(VF), 103 
#(X),95 

#(r), 109 

#(Z"), 102 
#(^o), 101 
#(Zi), 101 
#($), 109 



Semantic 

denotational, 250 

State, 271 

Supercombinator, 249 
a/p/ia, 202, 213 
feeto,202, 213 
gamma, 202, 213 



Term 



Glossary 



Algebra 

Often algebra means a system, which does not use the bound 
variable at all, i.e. all the variables in use are free. 

Algorithm (informally) 

Algorithm is a deterministic procedure that can be applied to 
any element of some class of symbolic inputs and that for every 
such input results, after all, in corresponding symbolic output. 

The essential features of the algorithm: 

* 1 ) algorithm is given by a set of instructions of finite size; 

*2) there is a computing device that is able to proceed with 
instructions and perform the computations; 

*3) there is an ability to choose, store and repeat the steps of 
computations; 

*4) let P be a set instructions in accordance with *1), and 
L be a computing device of *2). Then L interacts with P 
so, that for any given input the computation is performed 
discretely by steps, without analog devices and methods; 

*5) L interacts with P so that the computations move forward 
in a deterministic way, without access to stochastic meth- 
ods or devices, e.g. dice. 



313 



314 Glossary 

Alphabet 

Alphabet is a set of objects, called symbols or letters, which 
has a property of unlimited reproducing (in written form). 

Applicative computational systems 

Usually, the applicative computational system, or ACS, in- 
cludes the systems of object calculi based on combinatory logic 
and lambda-calculus. The only that is essentially developing 
in these systems, is a representation of an object. Combinatory 
logic contains the only metaoperator — application, or, in other 
terms, action of one object on another. The lambda-calculus 
contains two metaoperators — application and functional ab- 
straction that allows to bind one variable in the one object. 

The objects, generated in these systems, have a behavior of the 
functional entities with the following features: 

the number of argument places, or arity of an object is not fixed 
in advance, but reveals step by step, in interactions with 
other objects; 

in building the compound object one of the generic objects — 
the function, — is applied to the other one — to argument, 
— while in other contexts they can change their roles, 
i.e. the function and arguments are considered on equal 
rights; 

the self-applicability of functions is allowed, i.e. an object can 
be applied to itself. 

Axiomatic set theory 

The characteristics of such a theory are the following (see, e.g., 
[6]): (1) propositional functions are considered extensionally 
(the functions having the same truth values on the same ar- 
guments are identical); (2) propositional functions more that of 
one argument are reduced to the propositional functions of one 
argument, i.e. to classes; (3) there is the class which elements 



Glossary 315 



are called the sets; a class can be the element of other class if 
and only if it is a set; (4) the sets are characterized genetically, 
according to their building, so that too big classes, e.g. class of 
all the sets, could not be the sets. 

Calculus 

The calculus is a system with bound variables. In particular, 
A-calculus uses bound variables, and the only operator binding 
a variable, i.e. transforming a variable into formal parameter, is 
the operator of functional abstraction A. 

Category 

A category E contains the objects X, Y, ...and arrows /, 
g, ... . Any arrow / is attached to the object X, called the 
domain and the object Y , called codomain. This is written as 
f : X ^ Y. In addition the restrictions on using a compo- 
sition are imposed — taking into account the unitary (identity) 
map. The arrows are viewed as the representations of map- 
pings. Moreover, if g is an arbitrary arrow g : Y ^ Z with the 
domain Y that is the same as the codomain of /, then there is 
an arrow g o f : X ^ Z, called a composition of g with /. For 
any object Y there is an arrow 1 = ly : Y ^ Y , called the 
identity arrow for Y . The axioms of identity and associativity 
are assumed to be valid for all the arrows h : Z ^ W: 
Iy o f = f, g o Iy = g, h o {g o f) = {h o g) o f : X -> W . 

Class 

A notion of class is assumed to be intuitively clear. The classes 
of objects are usually considered as some objects. The proper 
classes (e.g., a class of numbers, houses, humans etc.) — are 
such the classes that are not the members of themselves (e.g., 
a class of all the notions). 

Class ( — conceptual) 

In a broad sense of the word this is a set of admissible elements 



316 Glossary 



of this class. 

Class ( — inductive) 

The inductive class is a conceptual class generated from the 
definite generic elements by the selected modes of combining. 
More rigorously, the class /C is inductive, if: 

(1) class /C includes the basis; 

(2) class /C is closed relatively the modes of combining; 

(3) class /C is a subclass of any class conforming the condi- 
tions (1 ) and (2). 

The notion of inductive class is used in two cases: 

( 1 ) the elements are the objects, and modes of combining are 
the operations; 

(2) the elements are the propositions, and the combinations 
are the connectives. 

Combinator 

The combinator is an object that relatively an evaluation reveals 
the property of being a constant. From a point of view of the A- 
calculus the combinator is a closed term. 

Combinatory logic 

In a narrow sense this is a branch of mathematical logic that 
studied the combinators and their properties. In the combina- 
tory logic the functional abstraction can be expressed in terms 
of usual operations, i.e. without using the format variables 
(parameters). 

Construction 

The process of deriving the object X belonging to the inductive 
class /C (see Class inductive) by the iterative use of the com- 
bining modes is considered as the construction X relatively /C. 



Glossary 317 

Dejinition 

The definition traditionally is regarded as an agreement con- 
cerning the usage of a language. Then a new symbol or com- 
bination of symbols, called definable, is introduced with the 
permission to substitute it in place of some other combination of 
symbols, called the defining one which value is already known 
from the data and previously introduced definitions. 

Dejinition ( — of function) 

The functions are introduced by the explicit definitions. Thus, 
starting with a variable x that denotes arbitrary object of type 
A, the expression b[x] denoting the object of type B{x) is con- 
structed. Next, the function / of type (Va; G A)B{x) with the 

scheme f{x) = b[x], where brackets indicate an occurrence 
of the variable x into the expression b[x], is defined. If B{x) for 
any object x of type A defines one and the same type B, then in 
place of '(Va; G A)B{xy the abbreviation A ^ B \s used. The 
last notation is accepted as the type of functions from A to B. 

Definition ( — recursive) 

The recursive definition of a function is such a definition in that 
the values of function for given arguments are directly deter- 
mined by the values of the same function for "simpler" argu- 
ments or by the values of "simpler" functions. The notion of 
'simpler' is augmented by a choice of formalization — the sim- 
plest, as a rule, are all the functions-constants. Such a method 
of formalization is suitable, because the recursive definitions 
can be considered as an algorithm {see Algorithm). 

Definitional equality 

def 

The binary relation of a definitional equality is denoted by ' = '. 
Its left part is definable, and its right part is defining. This is 
an equality relation (reflective, symmetric, and transitive). 



318 Glossary 

Description 

In building the logical means, among the terms are often used 
the descriptions — the constructions 'such . . . , that . . . '. The 
description corresponds to the term Ia;<|) that is canonically read 
as 'such and the only x, that <|) (for which <|) is true)'. 

Evaluation 

By the evaluation means such a mapping, when intensional 
objects are corresponded to the formal objects, and one and the 
same intensional object can be mapped in one or more different 
formal objects. 

Function 

See Definition of function. 

Function ( — of higher order) 

The function is called a 'higher order' function, if its arguments 
can in turn be the functions or it results in a function. 

Function ( — , computable by an algorithm) 

This is the mapping determined by a procedure, or by algo- 
rithm. 

Function ( — primitive recursive) 

The class of primitive recursive functions is the least class C of 
the total functions such that: 

i) all the constant functions Xxi . . .Xk-m are in C, 1 < 
fc, < m; 

ii) the successor function Xx.x + 1 is in C; 

iii) all the choice functions Xxi . . . x^.xi are mC,l < i <k; 

iv) if / is a function of k variables of C and gi, §2, . . ., gu are 
the functions of m variables of C, then the function 

Xxi . ..Xm-figiixi, . . .,Xm), ■ ■ ■,gk{xi, . . .,Xjn)) 



Glossary 319 

is in C, 1 < fc, m; 
v) if /i is a function of k+ 1 variables of C, and gxsa function of 
fc — 1 variables of C, then the only function / of A: variables 
that conforms the conditions 

/(0,X2,...,Xfc) = g{x2,...,Xk), 
f{y+l,X2,...,Xk) = h{y,f{y,X2,...,Xk),X2,...,Xk), 

is in C, 1 < k. 

Note that the 'function of zero variables of C means a fixed 
natural number. 

Functor ( — grammatical) 

The functor is regarded as the means to join the phrases to 
generate other phrases. 

Infix 

Infixes are the binary functors ("connectives", operators) that 
are written between the arguments. 

Interpretation ( — of a theory) 

By the interpretation of a theory relatively intensional domain 
(problem domain) we mean many-to-one mapping between 
the elementary propositions of a theory and definite intensional 
propositions regarding this intensional domain. 

Interpretation ( — of a term) 

An evaluation, or interpretation of the term M in the structure 
A^ is a mapping: 

II • ||- : terms x references -^ elements of A^ 

(see also Evaluation). 

Interpretation ( — adequate) 

An adequate, relatively complete interpretation maps every in- 
tensional proposition (interpretant of the intensional domain) 
into the theorem of a theory. 



320 Glossary 

X-term (lambda-term) 

A-term, or A-expression is an object derived by induction on 
complexity witli possible using of the operators of application 
and abstraction. 

Language 

The language in a broad sense of the word is determined by the 
introducing of agreements: (1) the alphabet is fixed; (2) the 
rules of constructing the certain combinations of the letters of 
alphabet are called the expressions, or words. 

Language ( — of researcher, orU-language) 

W-language is characterized by the following properties: 

( 1 ) singularity for every particular context; 

(2) presence of the means to formalize a terminology; 

(3) variability in a sense that it is a process relatively joining 
the new symbols or terms, and the usage of old terms is 
not necessary unchangeable; 

(4) W-language by need is inexact, but using it any reasonable 
degree of precision can be reached. 

Logic 

"Logic is an analysis and criticism of thought" (see Johnson 
W.E. Logic, part I, London, 1921; part II, London, 1922; part 
III, London, 1924.). When in studying logic the mathematical 
methods are used then the mathematical systems, that are by 
the definite ways related to the logic, are constructed. These 
systems are the subject of self standing studies and are con- 
sidered as a branch of mathematics. These systems constitute 
the mathematical logic. The mathematical logic deals with 
a task of explaining the nature of mathematical rigor because 
the mathematics is a deductive discipline, and the notion of a 



Glossary 321 



rigorous proof is the central notion of all its partitions. More- 
over, mathematical logic includes the studies of foundations of 
mathematics. 

Logic ( — mathematical) 

The mathematical logic describes a new direction in mathe- 
matics (see Mathematics modern), paying attention to the 
language in use, the modes of defining the abstract objects, and 
the laws of logic that are used in reasoning about these objects. 
Such a study have been attempted in logic to understand the 
nature of mathematical experience, enrich the mathematic with 
the most important results, and also to find out the applications 
to other branches of mathematics. 

Logic ( — modern mathematical) 

The modern mathematical logic follows from the works of Leib- 
nitz on the universal calculus that can include all the brainwork 
and, in particular, all the mathematics. 

Mathematics ( — modern) 

The modern mathematics can be described as a science of the 
abstract objects such as the real numbers, functions, algebraic 
systems etc. 

Name 

The name calls some actual or imaginable object. 

Numeral 

Combinatory logic or A-calculus allows to establish such com- 
binators or, respectively, terms that are similar to numbers. 
These representations of numbers are called the numerals. 
Numerals as the combinators conform to all the laws of com- 
binatory logic. Moreover, the combinators that represent the 
arithmetic operations, e.g., addition of numbers, can be con- 
structed. 



322 Glossary 

Ob-systeni 

The formal objects of ob-systems constitute an inductive class. 
The elements of this class are called the obs, or objects. The 
generic objects of inductive class are the atoms, and the modes 
of combining are the operations. The ob-systems are used to 
find out the significant, invariant assemblies of the objects. 

Object 

Object is a mathematical entity that is used in a theory. The 
object is a mathematical representation of the physical object 
of a problem domain ("outer world"). 

Object ( — arithmetical) 

Arithmetical objects are the combinatory representations of the 
numbers — they are numerals and also the corresponding com- 
binatory representations of the operations over numbers (see 
Numeral). 

Objects (system of — ) 

See System of objects. 

Object-oriented programming 

The object-oriented programming (OOP) is such a way of pro- 
gramming that enables a modularity of programs due to the 
partitioning a memory into the extents containing the data and 
procedures. The extents can be used as the samples which by 
request can be copied. 

Phrase ( — grammatical) 

The phrases are the names, sentences and functors. 

Possible worlds 

Possible worlds are considered as various set of individuals 
with the additional structure or without it. 

Postulates 

The inference rules and axioms are called by a term 'postulates'. 



Glossary 323 

Prefix 

The prefix is a functor (operator, "connective") that is written 
before the arguments. 

Process ( — effective) 

Assume that there are definite transformations that can be ac- 
tually performed over the certain elements. Assume that there 
also is a prescription defining the sequence of transformations 
that should be applied to some element one after other. It is 
said that the prescription defines an effective process to reach 
the certain aim relatively the element, if, when given this ele- 
ments, the prescription singularly determines such a sequence 
of transformations, that the aim is reached in a finite number of 
steps. 

Product 

The product is a set of tuples (n-tuples). Depending on the 
number of elements in a tuple, the product is attached with the 
arity. 

Projection 

The projection is a subset of corresponding cartesian product. 

Property 

The property is a propositional function defined over a(n) (arbi- 
trary) type A. 

Proposition 

A proposition is determined by such a way relatively which its 
proof can be considered. 

Relational system 

This is the system with a single basic predicate that is the binary 
relation. 



324 Glossary 



Representation 

The representation (of a system) is any way of considering the 
particular objects (of a domain) as the formal objects. The in- 
tensional (concrete) objects preserve a structure of the formal 
objects. 

Sentence 

The sentence expresses an assertion. 

Set ( — countable) 

Any set which elements can be enumerated, i.e. arranged as a 
general list where some element is placed in the first position, 
some element is placed in the second position etc., so that any 
elements of this set early or late occurs in this list, is called 
countable. 

Shell (Karoubi's — ) 

Karoubi's shell is a particular case of a category. 

Suffix 

Suffix is a functor that is written after the arguments. 

System ( — of objects) 

In a system of objects the formal objects constitute a homo- 
geneous inductive class (see Class inductive). The elements 
of this inductive class are regarded as the objects, its generic 
objects are atomic objects, and the modes of combining are 
the primitive generic operations. 

Thesis (Church's — ) 

It is impossible to prove the hypothesis that some standard for- 
malization gives the satisfactory analogs of a non-formal no- 
tion oi algorithm {see Algorithm) and algorithmic function 
(see Function, computable by an algorithm). Many of the 



Glossary 325 



mathematicians accept the hypothesis of that the standard for- 
malizations give a "reasonable rebuilding" of unavoidable inex- 
act non-formal notions, and the hypothesis is called Church's 
thesis. 

Theory 

The theory is a way of choosing the subclass of truth proposi- 
tions of the propositions belonging to the class of all the propo- 
sitions A. 

Theory ( — deductive) 

The theory T is a deductive one, if T is an inductive class of the 
(elementary) propositions (see Class inductive). 

Theory ( — of models) 

The model theory is a branch of mathematical logic, studying 
the connections between the formal language and its interpre- 
tations, or models. The main studying objects are the sen- 
tences (/) and algebraic systems Ai of the language L. 

Theory ( — consistent) 

The consistent theory is defined as such a theory that does not 
contain a class A of all the propositions. 

Theory ( — complete) 

The complete theory is such a deductive theory T that a joining 
to its axioms the elementary proposition which is not an ele- 
mentary theorem with saving its rules unchangeable, makes it 
inconsistent (contradictory). 

Theory ( — complete by Post) 

T is a complete theory, if every proposition of the class A of 
propositions is the consequence relatively T of any proposition 
X that is not in T. 



326 Glossary 

Theory ( — of recursion) 

The recursion theory studies the class of recursive, or effectively 
computable functions and its applications in mathematics. In 
a broad sense, the theory of recursion is considered as studying 
of the general processes of defining with a recursion not only 
over natural numbers, but over all the types of mathematical 
structures. 

Theory ( — of types) 

In a basis of this theory is put a principle of the hierarchy. 
This means that the logical notions — propositions, individuals, 
propositional functions, — are arranged as the hierarchy of 
types. It is essential, that an arbitrary function, as its argu- 
ments, has only the notions that are its predecessors in this 
hierarchy. 

Type doctrine 

The type doctrine is due to B. Russell according to whom any 
type can be assumed as a range of truth of the propositional 
function. Moreover, it is assumed that every function has a type 
(its domain). In the type doctrine the principle of replacing a 
type (of proposition) by definitionally equal type (propo- 
sition) holds. 

Unsolvability 

The mathematical sense of some result concerning unsolvabil- 
ity means that some particular set is not recursive. 

Value 

The values constitute a conceptual class that contains the in- 
tensional objects which are assigned to the formal objects by 
the evaluation. 

Variable 

The variable is a "variable, or changeable object", that can be 
replaced (using a substitution). 



Glossary 327 

Variable ( — bound) 

This is an object that participates in the operation having one 
or more formal parameters. Binding the variable have a sense 
relatively such an operation. 

Variable ( — indefinite) 

This is an (atomic) object that (in ob-system) is not restricted. 

Variable ( — substitutive) 

This is such an object in place of that the substitutions by the 
explicitly formulated substitution rule are allowed. 



328 



Glossary 



Practical work 



Sources 

Initially the practical work in applicative computations was included 
in a general practical work in the course "The systems of artificial in- 
telligence" delivered in MEPhI (L.T. Kuzin, [25]). This practical work 
was prepared by the group of authors in the topics of deductive in- 
ference, relational algebra and relational calculus, conceptual knowl- 
edge representation and frames. Lisp programming (K-E. Aksenov, 
O.T. Balovnev, V.E. Wolfengagen, O.V. Voskresenskaya, A.V. Gan- 
nochka, M.Yu. Chuprikov, [ ]; A.G. Panteleev, [32], M.A.Bulkin, 
Yu.R. Gabovich, A.G. Panteleev, [4]). Its essential part was the re- 
lational DBMS Lisp/R, that implemented one of the ways to develop 
the initial computational ideas. This method was based on the em- 
bedded computational systems and covered in (O.V. Voskresenskaya, 
[ 1 ]), which is included in the list of dissertations on p. 334. 

Applicative computations 

The variant of course delivered in MEPhI on the basis of this book 
(e.g., as "Special topics of discrete mathematics" or "Foundations 
of computer science") is equipped with the practical works that are 
in (V.E. Wolfengagen, L.V Goltseva, [ ]). Further development can 
be found in (L.V. Goltseva, [7]) and (A.V. Gavrilov, [ ]), included in 
the list of dissertations on p. 334. The software for practical work is 

329 



330 Practical WORK 

implemented for IBM PC and is distributed in a machine form. 

Structure of practical work 

The practical work covers the main notions and notations used in 
applicative computational systems and allows to learn it completely: 
from the language and notational agreements to the metatheorems 
on the corresponding formal systems. It gives the basic knowledge on 
usage the applicative computational systems (ACS) as a foundation 
of the functional languages, functional programming systems and 
purely object languages. 

The central notion in use is a term considered as the representa- 
tion of an object. The term syntactically corresponds to the program 
in a functional language. 

At this reason the first chapter of the guide to practical work deals 
with the technique of correct syntactical transformations — arranging 
the parentheses, — for the terms of different kinds. 

The second chapter is intended to learn the reductions in ACS. 
An execution of the functional program results in the value obtained 
at the end of computations. In ACS the normal form of a term cor- 
responds to the result of performing the reduction. According to the 
Church-Rosser theorem, the normal form is not depending on the or- 
der of the reduction steps that allows to build the various strategies of 
computations in the functional programming systems. A simulation 
of the A-abstraction in combinatory logic can be considered as an ex- 
ample of interpretation the logical systems by means of combinatory 
logic. 

The pair of combinators K and S constitute the basis for arbi- 
trary A-term, while the combinators /, B, C, S are the basis only 
for such terms that have no free variables. Using of these two bases 
for disassembling the terms from two chapters of the practical work 
gives a sufficient completeness of covering the topics because there 
are represented both the arbitrary A-terms and combinatory terms 



Practical WORK 331 

that are the A-terms without free variables. 

The last chapter of the practical work is the most creative because 
it covers the building of your own combinatory systems. It is shown 
how, joining the additional combinators to the basis combinators, 
increase the expressive power of the implemented environment. 

As a whole, every of the chapters of practical works gives the 
learner a skill in the certain unit of questions and can be used as a 
separate laboratory work. In case the practical works are used as a 
computerized book then the chapters can be compiled and arranged in 
accordance with the learner's experience or such a way that is needed 
for an instructor. 



Independent recourses 

http: //www. rb Jones .com A purpose of Web-resource FACTA- 
SIA is "to develop a vision for our future and to provide recourses 
for building the vision and the future", and also "to contribute to the 
values which shape our future and to the technology which helps 
us build it". The partition "Logic" includes combinatory logic and 
X-calculus, bibliography. See http: //www. rbj ones .com/rbjpub/ 
logic/cl/ 

http://www.cwi.nl/~troinp/cl/cl.htiiil The guide, bibliogra- 
phy and Java-applet are represented which allow to interpret the ob- 
jects — expressions of an applicative language, — that are to be build 
by the rules of combinatory logic. 

http : //ling . ucsd . edu/~barker/Lambda/ski . html A simple 
on-line introduction to combinatory logic is represented. 

http : //tunes . org/~iepos/oldpage/lambda.html 
Introduction to the lambda-calculus and combinatory logic. 



332 Practical WORK 



http://foldoc.doc.ic.ac.uk This is FOLDOC — Free On- 
Line Dictionary of Computing. 

http://dmoz.org/Science/Math/ Contains references and bib- 
liography. The chapter '/Logic_and_Foundations' contains 
'/ComputationaLLogic', that has a reference to 
'/Combinatory _Logic_and_Lambda_Calculus/'. 

http : //www . cl . cam . ac . uk/Research/TSG 

The directions of academic and research activity of the world known 

University of Cambridge Computer Laboratory. 

http: //web.comlab.ox.ac .uk/oucl The Oxford University 

Computing Laboratory (OUCL) which is the world known depart- 
ment on computer science. The URL http : //web . comlab . ox . ac . 
uk/oucl/strachey contains the references on a termly series of Dis- 
tinguished Lectures named after Christopher Strachey (1916-1975), 
the first Professor of Computation at Oxford University. He was the 
first leader of Programming Research Group (PRO), founded in 1965 
— and was succeeded by Sir Tony Hoare in 1977, — and with Dana 
Scott he founded the field of denotational semantics, providing a 
firm mathematical foundation for programming languages. 



Dissertations 



[1] Voskresenskaya O.V., Methods of development tlie relational 
database management system, Candidate of Technical Sciences The- 
sis, 05.13.06 — Computer aided management systems, Moscow Engi- 
neering Physical Institute, Dissertational Council K.053.03.04 MEPhI, 
Moscow, 1985. 

[2] Alexandrova I.A., Development of information support and software 
for the systems of organizational type on the basis of conceptual 
models, Candidate of Technical Sciences Thesis, 05.13.06 — Computer 
aided management systems, Moscow Engineering Physical Institute, 
Dissertational Council K.053.03.04 MEPhI, Moscow, 1986. 

[3] Ismailova L.Yu., Development of software for relational data pro- 
cessing in expert systems. Candidate of Technical Sciences Thesis, 
05.13.1 1 — Mathematical means and software for computing machines, 
complexes, systems and networks, Moscow Engineering Physical Insti- 
tute, Dissertational Council K.053.03.04 MEPhI, Moscow, 1989. 

[4] Volkov I.A., Exploration and development of methods for analysis 
and trustworthy support of information about R&D in the area of 
medicine. Candidate of Technical Sciences Thesis, 05.13.06 — Com- 
puter aided management systems; 14.00.33 — Social hygiene and public 
health, Moscow Engineering Physical Institute, Dissertational Council 
D-053.03.04 MEPhI, Moscow, 1990. 

[5] Wolfengagen V.E., Conceptual method of data bank design. Doc- 
tor of Technical Sciences Thesis, 05.13.11 — Mathematical means 



333 



334 Dissertations 



and software for computing machines, complexes, systems and net- 
works, Moscow Engineering Physical Institute, Dissertational Council 
D-053.03.04MEPhI, Moscow, 1990. 

{ Summary. This Doctoral Thesis describes the conceptual method of data bank 
design which is determined as an approach to develop, apply and manage the 
databases and metadata bases. This approach covers the accommodations to the 
variable problem domain and its representation, e.g., by increasing/decreasing 
the level of details being described. The topics concerning the management of 
databases and metadata bases deal with an integration of data objects, meta- 
data objects and programs. A unified computational environment preserves the 
extensibility of data object model. The representations of data and metadata are 
specified by the variety of data and metadata objects which are embedded into a 
computational framework. 

The design procedure is based on a choice of multilevel conceptualization to cap- 
ture the semantic features of data/metadata interconnections. The variety of data 
and metadata objects can be expanded without violation of the computational 
environment properties. 

All the topics give a conceptual framework for thinking about computations with 
the objects. Several areas of theoretical computer science are covered, including 
type free and typed A-calculus and combinatory logic with applications, eval- 
uation of expressions, computations in a category. The topics, covered in this 
Thesis accumulated much experience in teaching these subjects in postgraduate 
computer science courses. } 

[6] Gavrilov A.V., Tunable programming system for the categorical 
computaions, Candidate of Technical Sciences Thesis, 05.13.11 — 
Mathematical means and software for computing machines, complexes, 
systems and networks, Moscow Engineering Physical Institute, Disser- 
tational Council D-053.03.04 MEPhI, Moscow, 1995. 

[7] Goltseva L.V., Applicative computational system with the inten- 
sional relations, Candidate of Technical Sciences Thesis, 05.13.11 — 
Mathematical means and software for computing machines, complexes, 
systems and networks, Moscow Engineering Physical Institute, Disser- 
tational Council D-053.03.04 MEPhI, Moscow, 1995. 

[8] Zykov S.V., Exploring and implementation of the integrated corpo- 
rative information system for solving the tasks of personnel man- 
agement, Candidate of Technical Sciences Thesis, 05.13.11 — Math- 
ematical means and software for computing machines, complexes and 



Dissertations 335 



computer networks, Moscow Engineering Physical Institute, Disserta- 
tional Council D-053.03.04 MEPhI, Moscow, 2000. 

[9] Zabrodin A.L., Exploring and Implementation of the software for 
data management in computer aided systems of operative control 
of communication, Candidate of Technical Sciences Thesis, 05.13.11 — 
Mathematical means and software for computing machines, complexes 
and computer networks, Moscow Engineering Physical Institute, Dis- 
sertational Council D-053.03.04 MEPhI, Moscow, 2000. 

[10] Gorelov B.B. Exploring and implementation of distributed infor- 
mation system for financial data management, Candidate of Tech- 
nical Sciences Thesis, 05.13.11 — Mathematical means and software 
for computing machines, complexes and computer networks, Moscow 
Engineering Physical Institute, Dissertational Council D-212. 130.03 
MEPhI, Moscow, 2003. 



About the Author 



Viacheslav Wolfengagen received his Candidate of Technical Sci- 
ence degree in 1977 and the Doctor of Technical Science degree in 
1990 from Moscow Engineering Physics Institute. He is a full profes- 
sor of theoretical computer science and discrete mathematics at the 
Cybernetics Department of MEPhI and a professor of programming 
languages at the Cryptology and Discrete Mathematics Department 
of MEPhl. Since 1994 he has been with the Institute for Contempo- 
rary Education "JurlnfoR-MSU" in Moscow where he is currently a 
head of the Department of Advanced Computer Studies and Informa- 
tion Technologies. 

He chaired the 1999-2003 International Workshops in Com- 
puter Science and Information Technologies (CSIT). He is author 
of the books Logic: Techniques of Reasoning (2001, Center "Jur- 
InfoR"), Constructions in Programming Languages: Methods of 
Description (2001, Center "JurlnfoR"), Categorical Abstract Ma- 
chine: Introduction to Computations (2002, Center "JurlnfoR"), 
and Combinatory Logic in Programming: Computations with 
Objects through Examples and Exercises (2003, MEPhI — Center 
"JurlnfoR"). 

His research interests include data models, database design, soft- 
ware development databases, object and object-oriented program- 
ming and design, computation theory, programming languages, ap- 
plicative computational systems. He was a manager of research 
and development projects Logical Applicative Modeling Base of 
DAta LAMBDA (version 3, project 93-01-00943 granted by RFBR), 
Categorical Object-Oriented Abstract Machine COOAM (project 
96-01-01923 granted by RFBR), Metadata Objects for Proxy- 
Based Computational Environment {project 99-01-01229 granted 
by RFBR). 



Viacheslav Wolfengagen 



Combinatory logic in programming 

Computations with objects through examples and exercises 



Scientific editor 

Typesetting 

Proof-reading 

Cover design 



L. Yu. Ismallova 

Author 

L.M. Zinchenko 

O. V. Martina 



Signed to publishing 04.01 .2003. Offset print. 
Offset paper. Format 6084/16. Pr. sh. 21,25. Cond. pr. sh. 19,8. 
Copies 1500 Order N° 

"Center JurlnfoR" Ltd. 

103006, Moscow, Vorotnikovsky per., 7, phone (095) 956-25-12, 

http://www.jurinfor.ru, e-mail: info@jurinfor.ru 

License for publishing 

ID N° 03088 issued by October 23, 2000 

The production conforms the conditions of the 

Public Health Department of the Russian Federation. 

Sanitary-epidemiologic Certificate 

N° 77.99.02.953.D.003230.06.01 issued by June 9, 2001 

Tax incentive — All-Russia Classifier of Production 

-005-93, volume 2; 953000 - books, booklets 

Printed in a full accordance with 

the quality of given transparencies 

in the Typography "Nauka" 
121099, Moscow, Shubinsky per., 6 

ISBN 5-89I58-I0I-9 




9I78589III58I012 



All rights reserved "Center JurlnfoR" Ltd. 
103006, Moscow, Vorotnikovsky per., 7, phone (095)956-25-12 



